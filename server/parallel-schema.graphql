### This file was generated by Nexus Schema
### Do not make changes to this file directly

"""
JSON with AWS S3 url and required form data to make a POST request
"""
type AWSPresignedPostData {
  fields: JSONObject!
  url: String!
}

type AccessActivatedEvent implements PetitionEvent {
  access: PetitionAccess!
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
  user: User
}

type AccessActivatedFromPublicPetitionLinkEvent implements PetitionEvent {
  access: PetitionAccess!
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
}

type AccessActivatedFromPublicPetitionLinkUserNotification implements PetitionUserNotification {
  access: PetitionAccess!
  createdAt: DateTime!
  id: GID!
  isRead: Boolean!
  petition: PetitionBase!
}

type AccessDeactivatedEvent implements PetitionEvent {
  access: PetitionAccess!
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  reason: String!
  type: PetitionEventType!
  user: User
}

type AccessDelegatedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  newAccess: PetitionAccess!
  originalAccess: PetitionAccess!
  petition: Petition
  type: PetitionEventType!
}

type AccessOpenedEvent implements PetitionEvent {
  access: PetitionAccess!
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
}

type AsyncFieldCompletionResponse {
  type: String!
  url: String!
}

type BulkCreateContactsReturnType {
  contacts: [Contact!]!
  errors: [JSON!]
}

enum BulkSendSigningMode {
  """
  Allow configured signer(s) to sign every petition on the batch
  """
  COPY_SIGNATURE_SETTINGS

  """
  Disable eSignature on every petition of this batch.
  """
  DISABLE_SIGNATURE

  """
  Let recipients of each group to choose who will sign the petitions.
  """
  LET_RECIPIENT_CHOOSE
}

enum ChangePasswordResult {
  INCORRECT_PASSWORD
  INVALID_NEW_PASSWORD
  SUCCESS
}

type CommentCreatedUserNotification implements PetitionUserNotification {
  comment: PetitionFieldComment!
  createdAt: DateTime!
  field: PetitionField!
  id: GID!
  isRead: Boolean!
  petition: PetitionBase!
}

type CommentDeletedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  deletedBy: UserOrPetitionAccess
  field: PetitionField
  id: GID!
  isInternal: Boolean!
  petition: Petition
  type: PetitionEventType!
}

type CommentPublishedEvent implements PetitionEvent {
  comment: PetitionFieldComment
  createdAt: DateTime!
  data: JSONObject!
  field: PetitionField
  id: GID!
  isInternal: Boolean!
  petition: Petition
  type: PetitionEventType!
}

"""
Information from the connection.
"""
type ConnectionMetadata {
  browserName: String
  browserVersion: String
  country: String
  ip: String
}

"""
A contact in the system.
"""
type Contact implements Timestamps {
  """
  The petition accesses for this contact
  """
  accesses(
    """
    Number of elements to take from the list.
    """
    limit: Int

    """
    Number of elements to skip from the list.
    """
    offset: Int
  ): PetitionAccessPagination!

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  The email of the contact.
  """
  email: String!

  """
  The first name of the contact.
  """
  firstName: String!

  """
  The full name of the contact.
  """
  fullName: String!
  hasBouncedEmail: Boolean!

  """
  The ID of the contact.
  """
  id: GID!

  """
  The last name of the contact.
  """
  lastName: String

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

type ContactPagination {
  """
  The requested slice of items.
  """
  items: [Contact!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

input CreateContactInput {
  email: String!
  firstName: String!
  lastName: String
}

interface CreatedAt {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""
The effective permission for a petition and user
"""
type EffectivePetitionUserPermission {
  """
  wether user is subscribed or not to emails and alerts of the petition
  """
  isSubscribed: Boolean!

  """
  The type of the permission.
  """
  permissionType: PetitionPermissionType!
  user: User!
}

enum EntityType {
  Contact
  Organization
  Petition
  User
}

enum FeatureFlag {
  AUTO_ANONYMIZE
  CUSTOM_HOST_UI
  DEVELOPER_ACCESS
  ES_TAX_DOCUMENTS_FIELD
  EXPORT_CUATRECASAS
  GHOST_LOGIN
  HIDE_RECIPIENT_VIEW_CONTENTS
  ON_BEHALF_OF
  PETITION_ACCESS_RECIPIENT_URL_FIELD
  PETITION_PDF_EXPORT
  PETITION_SIGNATURE
  PUBLIC_PETITION_LINK_PREFILL_SECRET_UI
  REMOVE_PARALLEL_BRANDING
  REMOVE_WHY_WE_USE_PARALLEL
  SKIP_FORWARD_SECURITY
}

type FileUpload {
  contentType: String!
  filename: String!
  isComplete: Boolean!
  size: Int!
}

type FileUploadDownloadLinkResult {
  file: FileUpload
  result: Result!
  url: String
}

input FileUploadInput {
  contentType: String!
  filename: String!
  size: Int!
}

type FileUploadReplyResponse {
  presignedPostData: AWSPresignedPostData!
  reply: PetitionFieldReply!
}

enum FilterSharedWithLogicalOperator {
  AND
  OR
}

enum FilterSharedWithOperator {
  IS_OWNER
  NOT_IS_OWNER
  NOT_SHARED_WITH
  SHARED_WITH
}

scalar GID

type GenerateUserAuthTokenResponse {
  apiKey: String!
  userAuthToken: UserAuthenticationToken!
}

type GroupPermissionAddedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  permissionGroup: UserGroup
  permissionType: PetitionPermissionType!
  petition: Petition
  type: PetitionEventType!
  user: User
}

type GroupPermissionEditedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  permissionGroup: UserGroup
  permissionType: PetitionPermissionType!
  petition: Petition
  type: PetitionEventType!
  user: User
}

type GroupPermissionRemovedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  permissionGroup: UserGroup
  petition: Petition
  type: PetitionEventType!
  user: User
}

input ImageOptions {
  resize: ImageOptionsResize
}

input ImageOptionsResize {
  fit: ImageOptionsResizeFit
  height: Int
  width: Int
}

enum ImageOptionsResizeFit {
  contain
  cover
  fill
  inside
  outside
}

"""
The types of integrations available.
"""
enum IntegrationType {
  SIGNATURE
  SSO
  USER_PROVISIONING
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
  @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject
  @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
A public template on landing page
"""
type LandingTemplate {
  backgroundColor: String
  categories: [String!]
  descriptionHtml: String
  fieldCount: Int!
  fields: [LandingTemplateField!]!
  hasConditionals: Boolean!
  id: GID!
  imageUrl(small: Boolean): String
  locale: PetitionLocale!
  name: String
  organizationName: String!
  ownerAvatarUrl: String
  ownerFullName: String!
  publicLinkUrl: String
  shortDescription: String
  slug: String!
  updatedAt: DateTime!
}

type LandingTemplateCategorySample {
  category: String!
  templates(
    """
    Number of elements to take from the list.
    """
    limit: Int
    locale: PetitionLocale!

    """
    Number of elements to skip from the list.
    """
    offset: Int
  ): LandingTemplatePagination!
}

"""
A public template field
"""
type LandingTemplateField {
  id: GID!
  title: String
  type: PetitionFieldType!
}

type LandingTemplatePagination {
  """
  The requested slice of items.
  """
  items: [LandingTemplate!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

type MessageCancelledEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  message: PetitionMessage!
  petition: Petition
  reason: String!
  type: PetitionEventType!
  user: User
}

type MessageEmailBouncedUserNotification implements PetitionUserNotification {
  access: PetitionAccess!
  createdAt: DateTime!
  id: GID!
  isRead: Boolean!
  petition: PetitionBase!
}

type MessageScheduledEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  message: PetitionMessage!
  petition: Petition
  type: PetitionEventType!
}

type MessageSentEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  message: PetitionMessage!
  petition: Petition
  type: PetitionEventType!
}

type Mutation {
  """
  set user status to ACTIVE.
  """
  activateUser(userIds: [GID!]!): [User!]!

  """
  Adds permissions on given parallel and users
  """
  addPetitionPermission(
    message: String

    """
    Wether to notify the user via email or not.
    """
    notify: Boolean = false
    permissionType: PetitionPermissionTypeRW!
    petitionIds: [GID!]!

    """
    Subscribe to notifications.
    """
    subscribe: Boolean = true
    userGroupIds: [GID!]
    userIds: [GID!]
  ): [PetitionBase!]!

  """
  Add users to a user group
  """
  addUsersToUserGroup(userGroupId: GID!, userIds: [GID!]!): UserGroup!

  """
  Updates the status of a PENDING petition field replies to APPROVED or REJECTED
  """
  approveOrRejectPetitionFieldReplies(
    petitionId: GID!
    status: PetitionFieldReplyStatus!
  ): Petition!

  """
  Clones the petition and assigns the given user as owner and creator.
  """
  assignPetitionToUser(
    """
    Global ID of the petition
    """
    petitionId: ID!

    """
    Global ID of the user
    """
    userId: GID!
  ): SupportMethodResponse!

  """
  Load contacts from an excel file, creating the ones not found on database
  """
  bulkCreateContacts(file: Upload!): BulkCreateContactsReturnType!

  """
  Submits multiple replies on a petition at once given a JSON input where the keys are field aliases and values are the replie(s) for that field.
  """
  bulkCreatePetitionReplies(petitionId: GID!, replies: JSONObject!): Petition!

  """
  Cancels a scheduled petition message.
  """
  cancelScheduledMessage(messageId: GID!, petitionId: GID!): PetitionMessage
  cancelSignatureRequest(petitionSignatureRequestId: GID!): PetitionSignatureRequest!
  changeOrganization(orgId: GID): Result!

  """
  Changes the password for the current logged in user.
  """
  changePassword(newPassword: String!, password: String!): ChangePasswordResult!

  """
  Changes the type of a petition Field
  """
  changePetitionFieldType(
    fieldId: GID!
    force: Boolean = false
    petitionId: GID!
    type: PetitionFieldType!
  ): PetitionField!

  """
  Clones a petition field
  """
  clonePetitionField(fieldId: GID!, petitionId: GID!): PetitionField!

  """
  Clone petition.
  """
  clonePetitions(keepTitle: Boolean = false, petitionIds: [GID!]!): [PetitionBase!]!

  """
  Clones the user group with all its members
  """
  cloneUserGroup(locale: String, userGroupIds: [GID!]!): [UserGroup!]!

  """
  Closes an open petition.
  """
  closePetition(petitionId: GID!): Petition!

  """
  Marks a petition as COMPLETED.
  If the petition has a signature configured and does not require a review, starts the signing process.
  """
  completePetition(
    additionalSigners: [PublicPetitionSignerDataInput!]
    message: String
    petitionId: GID!
  ): Petition!

  """
  Create a contact.
  """
  createContact(data: CreateContactInput!): Contact!

  """
  Creates an event subscription for the user's petitions
  """
  createEventSubscription(
    eventTypes: [PetitionEventType!]
    eventsUrl: String!
    fromTemplateId: GID
    name: String
  ): PetitionEventSubscription!

  """
  Creates a task for exporting an xlsx file with petition text replies and sends it to the queue
  """
  createExportExcelTask(petitionId: GID!): Task!

  """
  Creates a task for exporting a ZIP file with petition replies and sends it to the queue
  """
  createExportRepliesTask(pattern: String, petitionId: GID!): Task!

  """
  Creates a reply to a file upload field.
  """
  createFileUploadReply(
    fieldId: GID!
    file: FileUploadInput!
    petitionId: GID!
  ): FileUploadReplyResponse!

  """
  Notifies the backend that the upload is complete.
  """
  createFileUploadReplyComplete(petitionId: GID!, replyId: GID!): PetitionFieldReply!

  """
  Creates a new organization.
  """
  createOrganization(
    """
    Email of the organization owner
    """
    email: String!

    """
    First name of the organization owner
    """
    firstName: String!

    """
    Last name of the organization owner
    """
    lastName: String!
    locale: PetitionLocale!

    """
    Name of the organization
    """
    name: String!

    """
    Temporary password of the organization owner
    """
    password: String!
    status: OrganizationStatus!
  ): SupportMethodResponse!

  """
  Creates a new PDF_DOCUMENT theme on the user's organization
  """
  createOrganizationPdfDocumentTheme(isDefault: Boolean!, name: String!): Organization!

  """
  Creates a new user in the same organization as the context user
  """
  createOrganizationUser(
    email: String!
    firstName: String!
    lastName: String!
    locale: String
    role: OrganizationRole!
    userGroupIds: [GID!]
  ): User!

  """
  Create parallel.
  """
  createPetition(
    locale: PetitionLocale
    name: String

    """
    GID of petition to base from
    """
    petitionId: GID

    """
    Type of petition to create
    """
    type: PetitionBaseType = PETITION
  ): PetitionBase!

  """
  Generates and returns a signed url to upload a petition attachment to AWS S3
  """
  createPetitionAttachmentUploadLink(
    data: FileUploadInput!
    petitionId: GID!
  ): PetitionAttachmentUploadData!

  """
  Creates a petition field
  """
  createPetitionField(petitionId: GID!, position: Int, type: PetitionFieldType!): PetitionField!

  """
  Generates and returns a signed url to upload a field attachment to AWS S3
  """
  createPetitionFieldAttachmentUploadLink(
    data: FileUploadInput!
    fieldId: GID!
    petitionId: GID!
  ): PetitionFieldAttachmentUploadData!

  """
  Create a petition field comment.
  """
  createPetitionFieldComment(
    content: String!
    isInternal: Boolean
    petitionFieldId: GID!
    petitionId: GID!
  ): PetitionFieldComment!

  """
  Creates a reply on a petition field
  """
  createPetitionFieldReply(fieldId: GID!, petitionId: GID!, reply: JSON!): PetitionFieldReply!

  """
  Creates a task for printing a PDF of the petition and sends it to the queue
  """
  createPrintPdfTask(includeNdLinks: Boolean, petitionId: GID!, skipAttachments: Boolean): Task!

  """
  Creates a public link from a user's template
  """
  createPublicPetitionLink(
    description: String!
    prefillSecret: String
    slug: String
    templateId: GID!
    title: String!
  ): PublicPetitionLink!

  """
  Creates a new signature integration on the user's organization
  """
  createSignatureIntegration(
    apiKey: String!
    isDefault: Boolean
    name: String!
    provider: SignatureOrgIntegrationProvider!
  ): SignatureOrgIntegration! @deprecated(reason: "use createSignaturitIntegration")

  """
  Creates a new Signaturit integration on the user's organization
  """
  createSignaturitIntegration(
    apiKey: String!
    isDefault: Boolean
    name: String!
  ): SignatureOrgIntegration!

  """
  Creates a tag in the user's organization
  """
  createTag(color: String!, name: String!): Tag!

  """
  Creates a task for exporting a report grouping the replies of every petition coming from the same template
  """
  createTemplateRepliesReportTask(petitionId: GID!, timezone: String!): Task!

  """
  Creates a task for generating a JSON report of the template usage
  """
  createTemplateStatsReportTask(templateId: GID!): Task!

  """
  Creates a new user in the specified organization.
  """
  createUser(
    """
    Email of the user
    """
    email: String!

    """
    First name of the user
    """
    firstName: String!

    """
    Last name of the user
    """
    lastName: String!
    locale: PetitionLocale!

    """
    ID of the organization
    """
    organizationId: Int!

    """
    Temporary password of the user
    """
    password: String!

    """
    Role of the user
    """
    role: OrganizationRole!
  ): SupportMethodResponse!

  """
  Creates a group in the user's organization
  """
  createUserGroup(name: String!, userIds: [GID!]!): UserGroup!

  """
  Deactivates the specified active petition accesses.
  """
  deactivateAccesses(accessIds: [GID!]!, petitionId: GID!): [PetitionAccess!]!

  """
  Updates user status to INACTIVE, transfers their owned petitions to another user in the org or delete all petitions.
  """
  deactivateUser(deletePetitions: Boolean, transferToUserId: GID, userIds: [GID!]!): [User!]!

  """
  Delete contacts.
  """
  deleteContacts(
    """
    Pass true to force deleting contacts with active accesses. Their accesses will be set as INACTIVE
    """
    force: Boolean
    ids: [GID!]!
  ): Result!

  """
  Deletes event subscriptions
  """
  deleteEventSubscriptions(ids: [GID!]!): Result!
  deleteOrganizationPdfDocumentTheme(orgThemeId: GID!): Organization!

  """
  Soft-deletes any given petition on the database.
  """
  deletePetition(
    """
    Global ID of the petition
    """
    petitionId: ID!
  ): SupportMethodResponse!

  """
  Remove a petition attachment
  """
  deletePetitionAttachment(attachmentId: GID!, petitionId: GID!): Result!

  """
  Deletes a petition field.
  """
  deletePetitionField(fieldId: GID!, force: Boolean = false, petitionId: GID!): PetitionBase!

  """
  Remove a petition field attachment
  """
  deletePetitionFieldAttachment(attachmentId: GID!, fieldId: GID!, petitionId: GID!): PetitionField!

  """
  Delete a petition field comment.
  """
  deletePetitionFieldComment(
    petitionFieldCommentId: GID!
    petitionFieldId: GID!
    petitionId: GID!
  ): PetitionField!

  """
  Deletes a reply to a petition field.
  """
  deletePetitionReply(petitionId: GID!, replyId: GID!): PetitionField!

  """
  Delete parallels.
  """
  deletePetitions(
    """
    If true, this will do a dry-run of the mutation to throw possible errors but it will not perform any modification in DB
    """
    dryrun: Boolean = false
    force: Boolean = false
    ids: [GID!]!
  ): Success!

  """
  Deletes a signature integration of the user's org. If there are pending signature requests using this integration, you must pass force argument to delete and cancel requests
  """
  deleteSignatureIntegration(force: Boolean = false, id: GID!): Result!

  """
  Removes the tag from every petition and soft-deletes it
  """
  deleteTag(id: GID!): Result!

  """
  Deletes a group
  """
  deleteUserGroup(ids: [GID!]!): Result!

  """
  generates a signed download link for the xlsx file containing the listings of a dynamic select field
  """
  dynamicSelectFieldFileDownloadLink(fieldId: GID!, petitionId: GID!): FileUploadDownloadLinkResult!

  """
  Edits permissions on given parallel and users
  """
  editPetitionPermission(
    permissionType: PetitionPermissionType!
    petitionIds: [GID!]!
    userGroupIds: [GID!]
    userIds: [GID!]
  ): [Petition!]!

  """
  Generates a download link for a file reply.
  """
  fileUploadReplyDownloadLink(
    petitionId: GID!

    """
    If true will use content-disposition inline instead of attachment
    """
    preview: Boolean
    replyId: GID!
  ): FileUploadDownloadLinkResult!

  """
  Generates a new API token for the context user
  """
  generateUserAuthToken(tokenName: String!): GenerateUserAuthTokenResponse!

  """
  Get the user who owns an API Token
  """
  getApiTokenOwner(token: String!): SupportMethodResponse!

  """
  Returns an object with signed download url and filename for tasks with file output
  """
  getTaskResultFile(preview: Boolean, taskId: GID!): TaskResultFile!

  """
  Returns a signed download url for tasks with file output
  """
  getTaskResultFileUrl(preview: Boolean, taskId: GID!): String!
    @deprecated(reason: "use getTaskResultFile instead")
  loginAs(userId: GID!): Result!

  """
  marks a Signature integration as default
  """
  markSignatureIntegrationAsDefault(id: GID!): OrgIntegration!

  """
  Adds, edits or deletes a custom property on the petition
  """
  modifyPetitionCustomProperty(key: String!, petitionId: GID!, value: String): PetitionBase!

  """
  Generates a download link for a petition attachment
  """
  petitionAttachmentDownloadLink(
    attachmentId: GID!
    petitionId: GID!
  ): FileUploadDownloadLinkResult!

  """
  Tells the backend that the petition attachment was correctly uploaded to S3
  """
  petitionAttachmentUploadComplete(attachmentId: GID!, petitionId: GID!): PetitionAttachment!

  """
  Generates a download link for a field attachment
  """
  petitionFieldAttachmentDownloadLink(
    attachmentId: GID!
    fieldId: GID!
    petitionId: GID!
  ): FileUploadDownloadLinkResult!

  """
  Tells the backend that the field attachment was correctly uploaded to S3
  """
  petitionFieldAttachmentUploadComplete(
    attachmentId: GID!
    fieldId: GID!
    petitionId: GID!
  ): PetitionFieldAttachment!
  publicCheckVerificationCode(code: String!, keycode: ID!, token: ID!): VerificationCodeCheck!

  """
  Marks a filled petition as COMPLETED.
  If the petition does not require a review, starts the signing process. Otherwise sends email to user.
  """
  publicCompletePetition(
    additionalSigners: [PublicPetitionSignerDataInput!]
    keycode: ID!
    message: String
  ): PublicPetition!

  """
  Creates and sends the petition linked to the PublicPetitionLink to the contact passed in args
  """
  publicCreateAndSendPetitionFromPublicLink(
    contactEmail: String!
    contactFirstName: String!
    contactLastName: String!

    """
    Set to true to force the creation + send of a new petition if the contact already has an active access on this public link
    """
    force: Boolean
    prefill: String
    slug: ID!
  ): Result!

  """
  Creates a reply to a file upload field.
  """
  publicCreateFileUploadReply(
    data: FileUploadInput!
    fieldId: GID!
    keycode: ID!
  ): PublicCreateFileUploadReply!

  """
  Create a petition field comment.
  """
  publicCreatePetitionFieldComment(
    content: String!
    keycode: ID!
    petitionFieldId: GID!
  ): PublicPetitionFieldComment!

  """
  Creates a reply on a petition field as recipient.
  """
  publicCreatePetitionFieldReply(
    fieldId: GID!
    keycode: ID!
    reply: JSON!
  ): PublicPetitionFieldReply!

  """
  Starts an export pdf task in a recipient context
  """
  publicCreatePrintPdfTask(keycode: ID!): Task!

  """
  Lets a recipient delegate access to the petition to another contact in the same organization
  """
  publicDelegateAccessToContact(
    email: String!
    firstName: String!
    keycode: ID!
    lastName: String!
    messageBody: JSON!
  ): PublicPetitionAccess!

  """
  Delete a petition field comment.
  """
  publicDeletePetitionFieldComment(
    keycode: ID!
    petitionFieldCommentId: GID!
    petitionFieldId: GID!
  ): PublicPetitionField!

  """
  Deletes a reply to a petition field.
  """
  publicDeletePetitionFieldReply(keycode: ID!, replyId: GID!): PublicPetitionField!

  """
  Notifies the backend that the upload is complete.
  """
  publicFileUploadReplyComplete(keycode: ID!, replyId: GID!): PublicPetitionFieldReply!

  """
  Generates a download link for a file reply on a public context.
  """
  publicFileUploadReplyDownloadLink(
    keycode: ID!

    """
    If true will use content-disposition inline instead of attachment
    """
    preview: Boolean
    replyId: GID!
  ): FileUploadDownloadLinkResult!

  """
  Returns a signed download url for tasks with file output on a recipient context
  """
  publicGetTaskResultFileUrl(keycode: ID!, taskId: GID!): String!

  """
  Marks the specified comments as read.
  """
  publicMarkPetitionFieldCommentsAsRead(
    keycode: ID!
    petitionFieldCommentIds: [GID!]!
  ): [PublicPetitionFieldComment!]!

  """
  Cancel a reminder for a contact.
  """
  publicOptOutReminders(
    keycode: ID!
    other: String!
    reason: String!
    referer: String
  ): PublicPetitionAccess!

  """
  Generates a download link for a field attachment on a public context.
  """
  publicPetitionFieldAttachmentDownloadLink(
    attachmentId: GID!
    fieldId: GID!
    keycode: ID!

    """
    If true will use content-disposition inline instead of attachment
    """
    preview: Boolean
  ): FileUploadDownloadLinkResult!

  """
  Resets the user password and resend the Invitation email. Only works if cognito user has status FORCE_CHANGE_PASSWORD
  """
  publicResetTemporaryPassword(email: String!, locale: String): Result!
  publicSendReminder(contactEmail: String!, slug: ID!): Result!
  publicSendVerificationCode(keycode: ID!): VerificationCodeRequest!

  """
  Starts the completion of an async field
  """
  publicStartAsyncFieldCompletion(fieldId: GID!, keycode: ID!): AsyncFieldCompletionResponse!

  """
  Update a petition field comment.
  """
  publicUpdatePetitionFieldComment(
    content: String!
    keycode: ID!
    petitionFieldCommentId: GID!
    petitionFieldId: GID!
  ): PublicPetitionFieldComment!

  """
  Creates a reply on a petition field as recipient.
  """
  publicUpdatePetitionFieldReply(
    keycode: ID!
    reply: JSON!
    replyId: GID!
  ): PublicPetitionFieldReply!

  """
  Reactivates the specified inactive petition accesses.
  """
  reactivateAccesses(accessIds: [GID!]!, petitionId: GID!): [PetitionAccess!]!

  """
  Removes permissions on given parallel and users
  """
  removePetitionPermission(
    petitionIds: [GID!]!

    """
    Set to true if you want to remove all permissions on the petitions. This will ignore the provided userIds
    """
    removeAll: Boolean
    userGroupIds: [GID!]
    userIds: [GID!]
  ): [PetitionBase]!

  """
  Removes users from a user group
  """
  removeUsersFromGroup(userGroupId: GID!, userIds: [GID!]!): UserGroup!

  """
  Reopens the petition
  """
  reopenPetition(petitionId: GID!): Petition!

  """
  Sends the AccountVerification email with confirmation code to unconfirmed user emails
  """
  resendVerificationCode(email: String!, locale: String): Result!

  """
  Removes the Signaturit Branding Ids of selected organization.
  """
  resetSignaturitOrganizationBranding(orgId: Int!): SupportMethodResponse!

  """
  Resets the user password and resend the Invitation email. Only works if cognito user has status FORCE_CHANGE_PASSWORD
  """
  resetTemporaryPassword(email: String!, locale: String): Result!

  """
  Resets the given user password on AWS Cognito and sends an email with new temporary.
  """
  resetUserPassword(email: String!, locale: PetitionLocale!): SupportMethodResponse!

  """
  Restores the 'fonts' section of the organization document theme to its default values
  """
  restoreDefaultOrganizationDocumentThemeFonts: Organization!
    @deprecated(reason: "use restoreDefaultOrganizationPdfDocumentThemeFonts")
  restoreLogin: Result!

  """
  Soft-deletes a given auth token, making it permanently unusable.
  """
  revokeUserAuthToken(authTokenIds: [GID!]!): Result!

  """
  Sends different petitions to each of the specified contact groups, creating corresponding accesses and messages
  """
  sendPetition(
    body: JSON!
    bulkSendSigningMode: BulkSendSigningMode
    contactIdGroups: [[GID!]!]!
    petitionId: GID!
    remindersConfig: RemindersConfigInput
    scheduledAt: DateTime
    senderId: GID
    subject: String!
  ): [SendPetitionResult!]!

  """
  Sends an email to all contacts of the petition confirming the replies are ok
  """
  sendPetitionClosedNotification(
    attachPdfExport: Boolean!
    emailBody: JSON!
    force: Boolean = false
    pdfExportTitle: String
    petitionId: GID!
  ): Petition!

  """
  Sends a reminder for the specified petition accesses.
  """
  sendReminders(accessIds: [GID!]!, body: JSON, petitionId: GID!): Result!

  """
  Sends a reminder email to the pending signers
  """
  sendSignatureRequestReminders(petitionSignatureRequestId: GID!): Result!

  """
  Set the delegades of a user
  """
  setUserDelegates(delegateIds: [GID!]!): User!

  """
  Sets the locale passed as arg as the preferred language of the user to see the page
  """
  setUserPreferredLocale(locale: String!): User!

  """
  Shares our SignaturIt production APIKEY with the passed Org, creates corresponding usage limits and activates PETITION_SIGNATURE feature flag.
  """
  shareSignaturitApiKey(
    """
    How many credits allow the org to use in the given period
    """
    limit: Int!

    """
    Numeric ID of the Organization
    """
    orgId: Int!

    """
    Period of the usage limit. e.g.: 1 month, 1 year, 20 days, etc...
    """
    period: String!
  ): SupportMethodResponse!

  """
  Generates a download link for the signed PDF petition.
  """
  signedPetitionDownloadLink(
    """
    If true, downloads the audit trail instead of the signed document
    """
    downloadAuditTrail: Boolean
    petitionSignatureRequestId: GID!

    """
    If true will use content-disposition inline instead of attachment
    """
    preview: Boolean
  ): FileUploadDownloadLinkResult!

  """
  Starts the completion of an async field
  """
  startAsyncFieldCompletion(fieldId: GID!, petitionId: GID!): AsyncFieldCompletionResponse!
  startSignatureRequest(message: String, petitionId: GID!): PetitionSignatureRequest!

  """
  Switches automatic reminders for the specified petition accesses.
  """
  switchAutomaticReminders(
    accessIds: [GID!]!
    petitionId: GID!
    remindersConfig: RemindersConfigInput
    start: Boolean!
  ): [PetitionAccess!]!

  """
  Tags a petition
  """
  tagPetition(petitionId: GID!, tagId: GID!): PetitionBase!

  """
  Transfers the ownership of an organization to a given user. Old owner will get ADMIN role
  """
  transferOrganizationOwnership(
    """
    Numeric ID of the organization
    """
    organizationId: Int!

    """
    Global ID of the new owner
    """
    userId: GID!
  ): SupportMethodResponse!

  """
  Transfers petition ownership to a given user. The original owner gets a WRITE permission on the petitions.
  """
  transferPetitionOwnership(petitionIds: [GID!]!, userId: GID!): [PetitionBase!]!

  """
  Removes the given tag from the given petition
  """
  untagPetition(petitionId: GID!, tagId: GID!): PetitionBase!

  """
  Updates a contact.
  """
  updateContact(data: UpdateContactInput!, id: GID!): Contact!

  """
  Updates an existing event subscription for the user's petitions
  """
  updateEventSubscription(id: GID!, isEnabled: Boolean!): PetitionEventSubscription!

  """
  Activate or deactivate an organization feature flag
  """
  updateFeatureFlag(
    featureFlag: FeatureFlag!

    """
    Numeric ID of the organization
    """
    orgId: Int!

    """
    Feature flag value
    """
    value: Boolean!
  ): SupportMethodResponse!

  """
  Updates the positions of the petition fields
  """
  updateFieldPositions(fieldIds: [GID!]!, petitionId: GID!): PetitionBase!

  """
  Updates the file of a FILE_UPLOAD reply. The previous file will be deleted from AWS S3 when client notifies of upload completed via updateFileUploadReplyComplete mutation.
  """
  updateFileUploadReply(
    file: FileUploadInput!
    petitionId: GID!
    replyId: GID!
  ): FileUploadReplyResponse!

  """
  Notifies the backend that the new file was successfully uploaded to S3. Marks the file upload as completed and deletes the old file.
  """
  updateFileUploadReplyComplete(petitionId: GID!, replyId: GID!): PetitionFieldReply!

  """
  Updates the metadata of a public landing template.
  """
  updateLandingTemplateMetadata(
    """
    for example: #A0FFCE
    """
    backgroundColor: String

    """
    comma-separated list of categories
    """
    categories: String

    """
    short description for the template
    """
    description: String
    image: Upload

    """
    must be URL-friendly
    """
    slug: String

    """
    global ID of the template
    """
    templateId: ID!
  ): SupportMethodResponse!

  """
  Updates the period after closed petitions of this organization are automatically anonymized.
  """
  updateOrganizationAutoAnonymizePeriod(months: Int): Organization!

  """
  updates the theme of the organization brand
  """
  updateOrganizationBrandTheme(data: OrganizationBrandThemeInput!): Organization!

  """
  updates the theme of the PDF documents of the organization
  """
  updateOrganizationDocumentTheme(data: OrganizationDocumentThemeInput!): Organization!
    @deprecated(reason: "use updateOrganizationPdfDocumentTheme")

  """
  Updates the limits of a given org. If 'Update Only Current Period' is left unchecked, the changes will be reflected on the next period.
  """
  updateOrganizationLimits(
    """
    How many credits allow the org to use in the given period
    """
    amount: Int!

    """
    Numeric ID of the Organization
    """
    orgId: Int!

    """
    e.g.: 1 month, 1 year, 20 days, etc...
    """
    period: String

    """
    End current period and start new with this arguments
    """
    startNewPeriod: Boolean!
    type: OrganizationUsageLimitName!
    updateOnlyCurrentPeriod: Boolean!
  ): SupportMethodResponse!

  """
  Updates the logo of an organization
  """
  updateOrganizationLogo(file: Upload!, isIcon: Boolean): Organization!

  """
  updates the PDF_DOCUMENT theme of the organization
  """
  updateOrganizationPdfDocumentTheme(
    data: OrganizationPdfDocumentThemeInput
    isDefault: Boolean
    name: String
    orgThemeId: GID!
  ): Organization!

  """
  Changes the organization preferred tone
  """
  updateOrganizationPreferredTone(tone: Tone!): Organization!

  """
  Applies a given tier to the organization
  """
  updateOrganizationTier(
    """
    Numeric ID of the Organization
    """
    orgId: Int!

    """
    e.g.: FREE, APPSUMO1, APPSUMO2, APPSUMO3...
    """
    tier: String!
  ): SupportMethodResponse!

  """
  Updates the role of another user in the organization.
  """
  updateOrganizationUser(role: OrganizationRole!, userGroupIds: [GID!], userId: GID!): User!

  """
  Updates the user limit for a organization
  """
  updateOrganizationUserLimit(
    """
    How many users allow the org to create
    """
    limit: Int!

    """
    Numeric ID of the organization
    """
    orgId: Int!
  ): SupportMethodResponse!

  """
  Updates a petition.
  """
  updatePetition(data: UpdatePetitionInput!, petitionId: GID!): PetitionBase!

  """
  Updates a petition field.
  """
  updatePetitionField(
    data: UpdatePetitionFieldInput!
    fieldId: GID!
    force: Boolean = false
    petitionId: GID!
  ): PetitionField!

  """
  Update a petition field comment.
  """
  updatePetitionFieldComment(
    content: String!
    petitionFieldCommentId: GID!
    petitionFieldId: GID!
    petitionId: GID!
  ): PetitionFieldComment!

  """
  Updates the status of a petition field reply.
  """
  updatePetitionFieldRepliesStatus(
    petitionFieldId: GID!
    petitionFieldReplyIds: [GID!]!
    petitionId: GID!
    status: PetitionFieldReplyStatus!
  ): PetitionField!

  """
  Updates a reply on a petition field
  """
  updatePetitionFieldReply(petitionId: GID!, reply: JSON!, replyId: GID!): PetitionFieldReply!

  """
  Updates the metadata of the specified petition field reply
  """
  updatePetitionFieldReplyMetadata(
    metadata: JSONObject!
    petitionId: GID!
    replyId: GID!
  ): PetitionFieldReply!

  """
  Updates the metadata of the specified petition
  """
  updatePetitionMetadata(metadata: JSONObject!, petitionId: GID!): Petition!

  """
  Updates the subscription flag on a PetitionPermission
  """
  updatePetitionPermissionSubscription(isSubscribed: Boolean!, petitionId: GID!): Petition!

  """
  Updates the restriction preferences
  """
  updatePetitionRestriction(
    isRestricted: Boolean!
    password: String
    petitionId: GID!
  ): PetitionBase!

  """
  Updates the read status of a user's notification.
  If one of the following args is defined, the other two must be undefined:
    - petitionUserNotificationIds
    - petitionIds
    - petitionFieldCommentIds
  """
  updatePetitionUserNotificationReadStatus(
    filter: PetitionUserNotificationFilter
    isRead: Boolean!
    petitionFieldCommentIds: [GID!]
    petitionIds: [GID!]
    petitionUserNotificationIds: [GID!]
  ): [PetitionUserNotification!]!

  """
  Updates the info and permissions of a public link
  """
  updatePublicPetitionLink(
    description: String
    isActive: Boolean
    prefillSecret: String
    publicPetitionLinkId: GID!
    slug: String
    title: String
  ): PublicPetitionLink!

  """
  Updates template_public from template
  """
  updatePublicTemplateVisibility(
    """
    Public visiblity of template
    """
    isPublic: Boolean!

    """
    global ID of the template
    """
    templateId: GID!
  ): SupportMethodResponse!
  updateSignatureRequestMetadata(
    metadata: JSONObject!
    petitionSignatureRequestId: GID!
  ): PetitionSignatureRequest!

  """
  Updates the name and color of a given tag
  """
  updateTag(data: UpdateTagInput!, id: GID!): Tag!

  """
  Updates the template default permissions
  """
  updateTemplateDefaultPermissions(
    permissions: [UserOrUserGroupPermissionInput!]!
    templateId: GID!
  ): PetitionTemplate!
  updateTemplateDocumentTheme(orgThemeId: GID!, templateId: GID!): PetitionBase!

  """
  Updates the user with the provided data.
  """
  updateUser(firstName: String, lastName: String): User!

  """
  Updates the name of a given user group
  """
  updateUserGroup(data: UpdateUserGroupInput!, id: GID!): UserGroup!

  """
  Uploads the xlsx file used to parse the options of a dynamic select field, and sets the field options
  """
  uploadDynamicSelectFieldFile(fieldId: GID!, file: Upload!, petitionId: GID!): PetitionField!

  """
  Uploads a user avatar image
  """
  uploadUserAvatar(
    image: Upload!

    """
    Global ID of the user
    """
    userId: GID!
  ): SupportMethodResponse!

  """
  Triggered by new users that want to sign up into Parallel
  """
  userSignUp(
    captcha: String!
    email: String!
    firstName: String!
    industry: String
    lastName: String!
    licenseCode: String

    """
    Preferred locale for AWS Cognito CustomMessages.
    """
    locale: String
    organizationLogo: Upload
    organizationName: String!
    password: String!
    position: String
    role: String
  ): User!

  """
  Runs backend checks to validate signature credentials.
  """
  validateSignatureCredentials(
    credentials: JSONObject!
    provider: SignatureOrgIntegrationProvider!
  ): JSONObject!
  verifyPublicAccess(
    ip: String
    keycode: ID!
    token: ID!
    userAgent: String
  ): PublicAccessVerification!
}

interface OrgIntegration {
  id: GID!

  """
  Wether this integration is the default to be used if the user has more than one of the same type
  """
  isDefault: Boolean!

  """
  Custom name of this integration, provided by the user
  """
  name: String!

  """
  The type of the integration.
  """
  type: IntegrationType!
}

type OrgIntegrationPagination {
  """
  The requested slice of items.
  """
  items: [OrgIntegration!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

"""
An object describing the license of an organization
"""
type OrgLicense {
  externalId: String!
  name: String!
  source: OrgLicenseSource!
}

enum OrgLicenseSource {
  APPSUMO
}

"""
An organization in the system.
"""
type Organization implements Timestamps {
  _id: Int! @deprecated(reason: "Temporal solution for support methods, don't use")

  """
  The total number of active users
  """
  activeUserCount: Int!
  anonymizePetitionsAfterMonths: Int
  brandTheme: JSONObject

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  Custom host used in petition links and public links.
  """
  customHost: String

  """
  Whether the organization has an SSO provider configured.
  """
  hasSsoProvider: Boolean!

  """
  URL of the organization logo
  """
  iconUrl(options: ImageOptions): String

  """
  The ID of the organization.
  """
  id: GID!

  """
  A paginated list with enabled integrations for the organization
  """
  integrations(
    """
    Number of elements to take from the list.
    """
    limit: Int

    """
    Number of elements to skip from the list.
    """
    offset: Int

    """
    Filter by integration type.
    """
    type: IntegrationType
  ): OrgIntegrationPagination!

  """
  Wether the 'fonts' section of the document theme has been changed from its default values or not
  """
  isPdfDocumentThemeFontsDirty: Boolean!
    @deprecated(reason: "Not used anymore. Use themes.pdfDocument[0].isDirty")

  """
  Current license for the organization
  """
  license: OrgLicense

  """
  URL of the organization logo
  """
  logoUrl(options: ImageOptions): String

  """
  The name of the organization.
  """
  name: String!
  pdfDocumentTheme: JSONObject!
    @deprecated(reason: "Not used anymore. Use themes.pdfDocument[0].data")
  pdfDocumentThemes: [OrganizationTheme!]!

  """
  The preferred tone of organization.
  """
  preferredTone: Tone!

  """
  The status of the organization.
  """
  status: OrganizationStatus!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
  usageLimits: OrganizationUsageLimit!

  """
  The users in the organization.
  """
  users(
    exclude: [GID!]
    includeInactive: Boolean

    """
    Number of elements to take from the list.
    """
    limit: Int

    """
    Number of elements to skip from the list.
    """
    offset: Int

    """
    Optional text to search in the collection.
    """
    search: String

    """
    Sorting to use on the collection
    """
    sortBy: [OrganizationUsers_OrderBy!]
  ): UserPagination!
}

input OrganizationBrandThemeInput {
  color: String
  fontFamily: String
}

input OrganizationDocumentThemeInput {
  legalText: OrganizationDocumentThemeInputLegalText
  marginBottom: Float
  marginLeft: Float
  marginRight: Float
  marginTop: Float
  showLogo: Boolean
  textColor: String
  textFontFamily: String
  textFontSize: Float
  title1Color: String
  title1FontFamily: String
  title1FontSize: Float
  title2Color: String
  title2FontFamily: String
  title2FontSize: Float
}

input OrganizationDocumentThemeInputLegalText {
  en: JSON
  es: JSON
}

type OrganizationPagination {
  """
  The requested slice of items.
  """
  items: [Organization!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

input OrganizationPdfDocumentThemeInput {
  legalText: OrganizationPdfDocumentThemeInputLegalText
  marginBottom: Float
  marginLeft: Float
  marginRight: Float
  marginTop: Float
  showLogo: Boolean
  textColor: String
  textFontFamily: String
  textFontSize: Float
  title1Color: String
  title1FontFamily: String
  title1FontSize: Float
  title2Color: String
  title2FontFamily: String
  title2FontSize: Float
}

input OrganizationPdfDocumentThemeInputLegalText {
  en: JSON
  es: JSON
}

"""
The roles of a user within an organization.
"""
enum OrganizationRole {
  ADMIN
  COLLABORATOR
  NORMAL
  OWNER
}

"""
The status of the organization.
"""
enum OrganizationStatus {
  """
  Used for regular clients
  """
  ACTIVE

  """
  Used on churned clients
  """
  CHURNED

  """
  Used for demoing the product
  """
  DEMO

  """
  Used for development or testing purposes
  """
  DEV

  """
  Root client
  """
  ROOT
}

type OrganizationTheme {
  data: JSONObject!
  id: GID!
  isDefault: Boolean!
  name: String!
}

type OrganizationUsageLimit {
  petitions: OrganizationUsagePetitionLimit!
  signatures: OrganizationUsageSignaturesLimit
  users: OrganizationUsageUserLimit!
}

enum OrganizationUsageLimitName {
  PETITION_SEND
  SIGNATURIT_SHARED_APIKEY
}

type OrganizationUsagePetitionLimit {
  limit: Int!
  used: Int!
}

type OrganizationUsageSignaturesLimit {
  limit: Int!
  used: Int!
}

type OrganizationUsageUserLimit {
  limit: Int!
}

"""
Order to use on Organization.users
"""
enum OrganizationUsers_OrderBy {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  fullName_ASC
  fullName_DESC
  lastActiveAt_ASC
  lastActiveAt_DESC
  lastName_ASC
  lastName_DESC
}

type OwnershipTransferredEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  owner: User
  petition: Petition
  previousOwner: User
  type: PetitionEventType!
  user: User
}

"""
A petition
"""
type Petition implements PetitionBase {
  """
  The accesses for this petition
  """
  accesses: [PetitionAccess!]!

  """
  How many months to wait since the petition is closed to anonymize.
  """
  anonymizeAfterMonths: Int

  """
  Purpose of the anonymization
  """
  anonymizePurpose: String

  """
  The attachments linked to this petition
  """
  attachments: [PetitionAttachment!]!

  """
  Time when the petition was closed.
  """
  closedAt: DateTime

  """
  The closing email body of the petition.
  """
  closingEmailBody: JSON

  """
  The body of the optional completing message to be show to recipients
  """
  completingMessageBody: JSON

  """
  The subject of the optional completing message to be show to recipients
  """
  completingMessageSubject: String

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  The current signature request.
  """
  currentSignatureRequest: PetitionSignatureRequest

  """
  Custom user properties
  """
  customProperties: JSONObject!

  """
  The deadline of the petition.
  """
  deadline: DateTime

  """
  The effective permissions on the petition
  """
  effectivePermissions: [EffectivePetitionUserPermission!]!

  """
  The body of the petition.
  """
  emailBody: JSON

  """
  The subject of the petition.
  """
  emailSubject: String

  """
  The events for the petition.
  """
  events(
    """
    Number of elements to take from the list.
    """
    limit: Int

    """
    Number of elements to skip from the list.
    """
    offset: Int
  ): PetitionEventPagination!

  """
  The number of fields in the petition.
  """
  fieldCount: Int!

  """
  The definition of the petition fields.
  """
  fields: [PetitionField!]!

  """
  The template used for this petition
  """
  fromTemplate: PetitionTemplate

  """
  The template GID used for this petition
  """
  fromTemplateId: GID

  """
  The ID of the petition or template.
  """
  id: GID!
  isAnonymized: Boolean!

  """
  Wether the completion message will be shown to the recipients or not.
  """
  isCompletingMessageEnabled: Boolean!

  """
  Whether the contents card is hidden in the recipient view.
  """
  isRecipientViewContentsHidden: Boolean! @deprecated(reason: "Don't use this")
  isRestricted: Boolean!
  isRestrictedWithPassword: Boolean!

  """
  The locale of the parallel.
  """
  locale: PetitionLocale!

  """
  Metadata for this petition.
  """
  metadata: JSONObject!

  """
  The effective permission of the logged user. Will return null if the user doesn't have access to the petition (e.g. on public templates).
  """
  myEffectivePermission: EffectivePetitionUserPermission

  """
  The name of the petition.
  """
  name: String
  organization: Organization!
  owner: User!

  """
  The permissions linked to the petition
  """
  permissions: [PetitionPermission!]!

  """
  The progress of the petition.
  """
  progress: PetitionProgress!

  """
  The reminders configuration for the petition.
  """
  remindersConfig: RemindersConfig
  selectedDocumentTheme: OrganizationTheme!

  """
  Date when the petition was first sent
  """
  sentAt: DateTime

  """
  The signature configuration for the petition.
  """
  signatureConfig: SignatureConfig

  """
  The list of signature requests.
  """
  signatureRequests: [PetitionSignatureRequest!]!

  """
  Whether to skip the forward security check on the recipient view.
  """
  skipForwardSecurity: Boolean!

  """
  The status of the petition.
  """
  status: PetitionStatus!

  """
  The tags linked to the petition
  """
  tags: [Tag!]!

  """
  The preferred tone of organization.
  """
  tone: Tone!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

"""
A petition access
"""
type PetitionAccess implements Timestamps {
  """
  The contact of this access.
  """
  contact: Contact

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  The original user who granted the access as other user.
  """
  delegateGranter: User

  """
  The user who granted the original access.
  """
  granter: User

  """
  The ID of the petition access.
  """
  id: GID!

  """
  When the next reminder will be sent.
  """
  nextReminderAt: DateTime

  """
  The petition for this message access.
  """
  petition: Petition
  recipientUrl: String!

  """
  Number of reminders sent.
  """
  reminderCount: Int!
  reminders: [PetitionReminder!]!

  """
  Whether automatic reminders are active or not for this petition access
  """
  remindersActive: Boolean!

  """
  The reminder settings of the petition.
  """
  remindersConfig: RemindersConfig

  """
  Number of reminders left.
  """
  remindersLeft: Int!

  """
  Whether contact has opted out from receiving reminders for this petition
  """
  remindersOptOut: Boolean!

  """
  The status of the petition access
  """
  status: PetitionAccessStatus!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

type PetitionAccessPagination {
  """
  The requested slice of items.
  """
  items: [PetitionAccess!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

"""
The status of a petition access.
"""
enum PetitionAccessStatus {
  """
  The petition is accessible by the contact.
  """
  ACTIVE

  """
  The petition is not accessible by the contact.
  """
  INACTIVE
}

type PetitionAnonymizedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
}

type PetitionAttachment implements CreatedAt {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!
  file: FileUpload!
  id: GID!
}

type PetitionAttachmentUploadData {
  attachment: PetitionAttachment!
  presignedPostData: AWSPresignedPostData!
}

interface PetitionBase {
  """
  How many months to wait since the petition is closed to anonymize.
  """
  anonymizeAfterMonths: Int

  """
  Purpose of the anonymization
  """
  anonymizePurpose: String

  """
  The attachments linked to this petition
  """
  attachments: [PetitionAttachment!]!

  """
  The closing email body of the petition.
  """
  closingEmailBody: JSON

  """
  The body of the optional completing message to be show to recipients
  """
  completingMessageBody: JSON

  """
  The subject of the optional completing message to be show to recipients
  """
  completingMessageSubject: String

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  Custom user properties
  """
  customProperties: JSONObject!

  """
  The effective permissions on the petition
  """
  effectivePermissions: [EffectivePetitionUserPermission!]!

  """
  The body of the petition.
  """
  emailBody: JSON

  """
  The subject of the petition.
  """
  emailSubject: String

  """
  The number of fields in the petition.
  """
  fieldCount: Int!

  """
  The definition of the petition fields.
  """
  fields: [PetitionField!]!

  """
  The ID of the petition or template.
  """
  id: GID!
  isAnonymized: Boolean!

  """
  Wether the completion message will be shown to the recipients or not.
  """
  isCompletingMessageEnabled: Boolean!

  """
  Whether the contents card is hidden in the recipient view.
  """
  isRecipientViewContentsHidden: Boolean! @deprecated(reason: "Don't use this")
  isRestricted: Boolean!
  isRestrictedWithPassword: Boolean!

  """
  The locale of the parallel.
  """
  locale: PetitionLocale!

  """
  Metadata for this petition.
  """
  metadata: JSONObject!

  """
  The effective permission of the logged user. Will return null if the user doesn't have access to the petition (e.g. on public templates).
  """
  myEffectivePermission: EffectivePetitionUserPermission

  """
  The name of the petition.
  """
  name: String
  organization: Organization!
  owner: User!

  """
  The permissions linked to the petition
  """
  permissions: [PetitionPermission!]!

  """
  The reminders configuration for the petition.
  """
  remindersConfig: RemindersConfig
  selectedDocumentTheme: OrganizationTheme!

  """
  The signature configuration for the petition.
  """
  signatureConfig: SignatureConfig

  """
  Whether to skip the forward security check on the recipient view.
  """
  skipForwardSecurity: Boolean!

  """
  The tags linked to the petition
  """
  tags: [Tag!]!

  """
  The preferred tone of organization.
  """
  tone: Tone!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

type PetitionBasePagination {
  """
  The requested slice of items.
  """
  items: [PetitionBase!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

enum PetitionBaseType {
  PETITION
  TEMPLATE
}

type PetitionClonedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
  user: User
}

type PetitionClosedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
  user: User
}

type PetitionClosedNotifiedEvent implements PetitionEvent {
  access: PetitionAccess!
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
  user: User
}

type PetitionCompletedEvent implements PetitionEvent {
  completedBy: UserOrPetitionAccess
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
}

type PetitionCompletedUserNotification implements PetitionUserNotification {
  completedBy: UserOrPetitionAccess
  createdAt: DateTime!
  id: GID!
  isRead: Boolean!
  petition: PetitionBase!
}

type PetitionCreatedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
  user: User
}

type PetitionDeletedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
}

interface PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
}

type PetitionEventPagination {
  """
  The requested slice of items.
  """
  items: [PetitionEvent!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

type PetitionEventSubscription {
  eventTypes: [PetitionEventType!]
  eventsUrl: String!
  fromTemplate: PetitionTemplate
  id: GID!
  isEnabled: Boolean!
  name: String
}

enum PetitionEventType {
  ACCESS_ACTIVATED
  ACCESS_ACTIVATED_FROM_PUBLIC_PETITION_LINK
  ACCESS_DEACTIVATED
  ACCESS_DELEGATED
  ACCESS_OPENED
  COMMENT_DELETED
  COMMENT_PUBLISHED
  GROUP_PERMISSION_ADDED
  GROUP_PERMISSION_EDITED
  GROUP_PERMISSION_REMOVED
  MESSAGE_CANCELLED
  MESSAGE_SCHEDULED
  MESSAGE_SENT
  OWNERSHIP_TRANSFERRED
  PETITION_ANONYMIZED
  PETITION_CLONED
  PETITION_CLOSED
  PETITION_CLOSED_NOTIFIED
  PETITION_COMPLETED
  PETITION_CREATED
  PETITION_DELETED
  PETITION_MESSAGE_BOUNCED
  PETITION_REMINDER_BOUNCED
  PETITION_REOPENED
  RECIPIENT_SIGNED
  REMINDERS_OPT_OUT
  REMINDER_SENT
  REPLY_CREATED
  REPLY_DELETED
  REPLY_UPDATED
  SIGNATURE_CANCELLED
  SIGNATURE_COMPLETED
  SIGNATURE_OPENED
  SIGNATURE_REMINDER
  SIGNATURE_STARTED
  TEMPLATE_USED
  USER_PERMISSION_ADDED
  USER_PERMISSION_EDITED
  USER_PERMISSION_REMOVED
}

"""
A field within a petition.
"""
type PetitionField {
  """
  The alias of the petition field.
  """
  alias: String

  """
  A list of files attached to this field.
  """
  attachments: [PetitionFieldAttachment!]!
  commentCount: Int!

  """
  The comments for this field.
  """
  comments: [PetitionFieldComment!]!

  """
  The description of the petition field.
  """
  description: String

  """
  The field GID used from which this field was cloned
  """
  fromPetitionFieldId: GID
  hasCommentsEnabled: Boolean!

  """
  The ID of the petition field.
  """
  id: GID!

  """
  Determines if the field can be moved or deleted.
  """
  isFixed: Boolean!

  """
  Determines if the field is visible by the recipients.
  """
  isInternal: Boolean!

  """
  Determines if the field accepts replies
  """
  isReadOnly: Boolean!

  """
  Determines if this field allows multiple replies.
  """
  multiple: Boolean!

  """
  Determines if this field is optional.
  """
  optional: Boolean!

  """
  The options of the petition field.
  """
  options: JSONObject!
  petition: PetitionBase!
  position: Int!

  """
  The replies to the petition field
  """
  replies: [PetitionFieldReply!]!

  """
  Determines if the field is visible in PDF export.
  """
  showInPdf: Boolean!

  """
  The title of the petition field.
  """
  title: String

  """
  The type of the petition field.
  """
  type: PetitionFieldType!
  unreadCommentCount: Int!

  """
  A JSON object representing the conditions for the field to be visible
  """
  visibility: JSONObject
}

"""
A file attachment on the petition
"""
type PetitionFieldAttachment implements CreatedAt {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!
  field: PetitionField!
  file: FileUpload!
  id: GID!
}

type PetitionFieldAttachmentUploadData {
  attachment: PetitionFieldAttachment!
  presignedPostData: AWSPresignedPostData!
}

"""
A comment on a petition field
"""
type PetitionFieldComment {
  """
  The author of the comment.
  """
  author: UserOrPetitionAccess

  """
  The content of the comment.
  """
  content: String!

  """
  Time when the comment was created.
  """
  createdAt: DateTime!
  field: PetitionField!

  """
  The ID of the petition field comment.
  """
  id: GID!
  isAnonymized: Boolean!

  """
  Whether the comment has been edited after being published.
  """
  isEdited: Boolean!

  """
  Whether the comment is internal (only visible to org users) or public (visible for users and accesses)
  """
  isInternal: Boolean!

  """
  Whether the comment has been read or not.
  """
  isUnread: Boolean!
}

"""
The progress of the petition
"""
type PetitionFieldProgress {
  """
  Number of optional fields not replied or validated
  """
  optional: Int!

  """
  Number of fields with a reply and not validated
  """
  replied: Int!

  """
  Total number of fields in the petition
  """
  total: Int!

  """
  Number of fields validated
  """
  validated: Int!
}

"""
A reply to a petition field
"""
type PetitionFieldReply implements Timestamps {
  """
  The content of the reply.
  """
  content: JSONObject!

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  The petition field for this reply.
  """
  field: PetitionField

  """
  The ID of the petition field reply.
  """
  id: GID!
  isAnonymized: Boolean!

  """
  Metadata for this reply.
  """
  metadata: JSONObject!

  """
  The status of the reply.
  """
  status: PetitionFieldReplyStatus!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!

  """
  The last updater of the field reply.
  """
  updatedBy: UserOrPetitionAccess
}

"""
The status of a petition.
"""
enum PetitionFieldReplyStatus {
  """
  The reply has been approved.
  """
  APPROVED

  """
  The reply has not been approved or rejected.
  """
  PENDING

  """
  The reply has been rejected.
  """
  REJECTED
}

"""
Type of a petition field
"""
enum PetitionFieldType {
  """
  A options list.
  """
  CHECKBOX

  """
  A datepicker field.
  """
  DATE

  """
  A dynamic select field.
  """
  DYNAMIC_SELECT

  """
  A tax documents/info field.
  """
  ES_TAX_DOCUMENTS

  """
  A file upload field.
  """
  FILE_UPLOAD

  """
  A heading field.
  """
  HEADING

  """
  A only numbers field.
  """
  NUMBER

  """
  A phone formatted field.
  """
  PHONE

  """
  A select field.
  """
  SELECT

  """
  A short text field.
  """
  SHORT_TEXT

  """
  A text field.
  """
  TEXT
}

input PetitionFilter {
  locale: PetitionLocale
  sharedWith: PetitionSharedWithFilter
  status: [PetitionStatus!]
  tagIds: [GID!]
  type: PetitionBaseType
}

"""
The locale used for rendering the petition to the contact.
"""
enum PetitionLocale {
  en
  es
}

"""
A petition message
"""
type PetitionMessage implements CreatedAt {
  """
  The access of this petition message.
  """
  access: PetitionAccess!

  """
  Tells when the email bounced.
  """
  bouncedAt: DateTime

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  Tells when the email was delivered.
  """
  deliveredAt: DateTime

  """
  The body of the petition message on HTML format.
  """
  emailBody: String

  """
  The subject of the petition message.
  """
  emailSubject: JSON

  """
  The ID of the petition message.
  """
  id: GID!
  isAnonymized: Boolean!

  """
  Tells when the email was opened for the first time.
  """
  openedAt: DateTime

  """
  Time at which the message will be sent.
  """
  scheduledAt: DateTime

  """
  The sender of this petition message.
  """
  sender: User!

  """
  If already sent, the date at which the email was sent.
  """
  sentAt: DateTime

  """
  The status of the petition message
  """
  status: PetitionMessageStatus!
}

type PetitionMessageBouncedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  message: PetitionMessage!
  petition: Petition
  type: PetitionEventType!
}

"""
The status of a petition message.
"""
enum PetitionMessageStatus {
  """
  The message was scheduled but has been cancelled.
  """
  CANCELLED

  """
  The message has been processed.
  """
  PROCESSED

  """
  The message is being processed.
  """
  PROCESSING

  """
  The message has been scheduled to be sent at a specific time.
  """
  SCHEDULED
}

interface PetitionPermission implements Timestamps {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  wether user is subscribed or not to emails and alerts of the petition
  """
  isSubscribed: Boolean!

  """
  The type of the permission.
  """
  permissionType: PetitionPermissionType!

  """
  The petition linked to the permission.
  """
  petition: Petition!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

"""
The type of permission for a petition user.
"""
enum PetitionPermissionType {
  OWNER
  READ
  WRITE
}

"""
The READ and WRITE permissions for a petition user.
"""
enum PetitionPermissionTypeRW {
  READ
  WRITE
}

"""
The progress of a petition.
"""
type PetitionProgress {
  """
  The progress of the petition exlude internal fields.
  """
  external: PetitionFieldProgress!

  """
  The progress of the petition include internal fields.
  """
  internal: PetitionFieldProgress!
}

type PetitionReminder implements CreatedAt {
  """
  The access of this petition message.
  """
  access: PetitionAccess!

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  The body of the message in HTML format.
  """
  emailBody: String
  id: GID!

  """
  The sender of this petition message.
  """
  sender: User

  """
  The type of the reminder.
  """
  type: PetitionReminderType!
}

type PetitionReminderBouncedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  reminder: PetitionReminder!
  type: PetitionEventType!
}

"""
The type of a petition reminder.
"""
enum PetitionReminderType {
  """
  The reminder has been sent by the system according to the reminders configuration.
  """
  AUTOMATIC

  """
  The reminder has been sent manually by a user.
  """
  MANUAL
}

type PetitionReopenedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
  user: User
}

type PetitionSharedUserNotification implements PetitionUserNotification {
  createdAt: DateTime!
  id: GID!
  isRead: Boolean!
  owner: User!
  permissionType: PetitionPermissionTypeRW!
  petition: PetitionBase!
  sharedWith: UserOrUserGroup
}

input PetitionSharedWithFilter {
  filters: [PetitionSharedWithFilterLine!]!
  operator: FilterSharedWithLogicalOperator!
}

input PetitionSharedWithFilterLine {
  operator: FilterSharedWithOperator!
  value: ID!
}

enum PetitionSignatureCancelReason {
  CANCELLED_BY_USER
  DECLINED_BY_SIGNER
  REQUEST_ERROR
  REQUEST_RESTARTED
}

type PetitionSignatureRequest implements Timestamps {
  auditTrailFilename: String
  cancelReason: String

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  The environment of the petition signature.
  """
  environment: SignatureOrgIntegrationEnvironment!
  id: GID!
  isAnonymized: Boolean!

  """
  Metadata for this signature request.
  """
  metadata: JSONObject!
  petition: Petition!

  """
  The signature configuration for the request.
  """
  signatureConfig: SignatureConfig!
  signedDocumentFilename: String
  signerStatus: [PetitionSignatureRequestSignerStatus!]!

  """
  The status of the petition signature.
  """
  status: PetitionSignatureRequestStatus!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

type PetitionSignatureRequestSignerStatus {
  declinedAt: DateTime
  openedAt: DateTime
  sentAt: DateTime
  signedAt: DateTime
  signer: PetitionSigner!

  """
  The signing status of the individual contact.
  """
  status: String!
}

enum PetitionSignatureRequestStatus {
  CANCELLED
  COMPLETED
  ENQUEUED
  PROCESSED
  PROCESSING
}

"""
Information about a signer of the petition
"""
type PetitionSigner {
  contactId: GID
  email: String!
  firstName: String!
  fullName: String!
  lastName: String
}

"""
The status of a petition.
"""
enum PetitionStatus {
  """
  The petition has been closed by a user.
  """
  CLOSED

  """
  The petition has been completed.
  """
  COMPLETED

  """
  The petition has not been sent yet.
  """
  DRAFT

  """
  The petition has been sent and is awaiting completion.
  """
  PENDING
}

"""
A petition template
"""
type PetitionTemplate implements PetitionBase {
  """
  How many months to wait since the petition is closed to anonymize.
  """
  anonymizeAfterMonths: Int

  """
  Purpose of the anonymization
  """
  anonymizePurpose: String

  """
  The attachments linked to this petition
  """
  attachments: [PetitionAttachment!]!
  backgroundColor: String
  categories: [String!]

  """
  The closing email body of the petition.
  """
  closingEmailBody: JSON

  """
  The body of the optional completing message to be show to recipients
  """
  completingMessageBody: JSON

  """
  The subject of the optional completing message to be show to recipients
  """
  completingMessageSubject: String

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  Custom user properties
  """
  customProperties: JSONObject!
  defaultPermissions: [TemplateDefaultPermission!]!

  """
  Description of the template.
  """
  description: JSON

  """
  HTML excerpt of the template description.
  """
  descriptionExcerpt: String

  """
  HTML description of the template.
  """
  descriptionHtml: String

  """
  The effective permissions on the petition
  """
  effectivePermissions: [EffectivePetitionUserPermission!]!

  """
  The body of the petition.
  """
  emailBody: JSON

  """
  The subject of the petition.
  """
  emailSubject: String

  """
  The number of fields in the petition.
  """
  fieldCount: Int!

  """
  The definition of the petition fields.
  """
  fields: [PetitionField!]!

  """
  The ID of the petition or template.
  """
  id: GID!
  imageUrl(options: ImageOptions): String
  isAnonymized: Boolean!

  """
  Wether the completion message will be shown to the recipients or not.
  """
  isCompletingMessageEnabled: Boolean!

  """
  Whether the template is publicly available or not
  """
  isPublic: Boolean!

  """
  Whether the contents card is hidden in the recipient view.
  """
  isRecipientViewContentsHidden: Boolean! @deprecated(reason: "Don't use this")
  isRestricted: Boolean!
  isRestrictedWithPassword: Boolean!

  """
  The locale of the parallel.
  """
  locale: PetitionLocale!

  """
  Metadata for this petition.
  """
  metadata: JSONObject!

  """
  The effective permission of the logged user. Will return null if the user doesn't have access to the petition (e.g. on public templates).
  """
  myEffectivePermission: EffectivePetitionUserPermission

  """
  The name of the petition.
  """
  name: String
  organization: Organization!
  owner: User!

  """
  The permissions linked to the petition
  """
  permissions: [PetitionPermission!]!

  """
  The public link linked to this template
  """
  publicLink: PublicPetitionLink

  """
  The reminders configuration for the petition.
  """
  remindersConfig: RemindersConfig
  selectedDocumentTheme: OrganizationTheme!

  """
  The signature configuration for the petition.
  """
  signatureConfig: SignatureConfig

  """
  Whether to skip the forward security check on the recipient view.
  """
  skipForwardSecurity: Boolean!

  """
  The tags linked to the petition
  """
  tags: [Tag!]!

  """
  The preferred tone of organization.
  """
  tone: Tone!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

type PetitionTemplatePagination {
  """
  The requested slice of items.
  """
  items: [PetitionTemplate!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

"""
The permission for a petition and user group
"""
type PetitionUserGroupPermission implements PetitionPermission & Timestamps {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  The group linked to the permission
  """
  group: UserGroup!

  """
  wether user is subscribed or not to emails and alerts of the petition
  """
  isSubscribed: Boolean!

  """
  The type of the permission.
  """
  permissionType: PetitionPermissionType!

  """
  The petition linked to the permission.
  """
  petition: Petition!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

interface PetitionUserNotification {
  createdAt: DateTime!
  id: GID!
  isRead: Boolean!
  petition: PetitionBase!
}

"""
The types of notifications available for filtering
"""
enum PetitionUserNotificationFilter {
  ALL
  COMMENTS
  COMPLETED
  OTHER
  SHARED
  UNREAD
}

"""
The permission for a petition and user
"""
type PetitionUserPermission implements PetitionPermission & Timestamps {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  wether user is subscribed or not to emails and alerts of the petition
  """
  isSubscribed: Boolean!

  """
  The type of the permission.
  """
  permissionType: PetitionPermissionType!

  """
  The petition linked to the permission.
  """
  petition: Petition!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!

  """
  The user linked to the permission
  """
  user: User!
}

type PublicAccessVerification {
  brandTheme: JSONObject
  cookieName: String
  cookieValue: String
  email: String
  isAllowed: Boolean!
  orgLogoUrl: String
  orgName: String
  tone: Tone
}

"""
A public view of a contact
"""
type PublicContact {
  """
  The email of the user.
  """
  email: String!

  """
  The first name of the user.
  """
  firstName: String!

  """
  The full name of the user.
  """
  fullName: String!

  """
  The ID of the contact.
  """
  id: GID!

  """
  The last name of the user.
  """
  lastName: String
}

type PublicCreateFileUploadReply {
  presignedPostData: AWSPresignedPostData!
  reply: PublicPetitionFieldReply!
}

type PublicLicenseCode {
  code: String!
  details: JSONObject!
  source: String!
}

"""
A public view of an organization
"""
type PublicOrganization {
  brandTheme: JSONObject

  """
  If this organization has the REMOVE_PARALLEL_BRANDING feature flag enabled
  """
  hasRemoveParallelBranding: Boolean!

  """
  The ID of the organization.
  """
  id: GID!

  """
  The logo of the organization.
  """
  logoUrl(options: ImageOptions): String

  """
  The name of the organization.
  """
  name: String!

  """
  The preferred tone of organization.
  """
  tone: Tone!
}

"""
A public view of the petition
"""
type PublicPetition implements Timestamps {
  """
  The body of the optional completing message to be show to recipients.
  """
  completingMessageBody: String

  """
  The subject of the optional completing message to be show to recipients
  """
  completingMessageSubject: String

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  The deadline of the petition.
  """
  deadline: DateTime

  """
  The field definition of the petition.
  """
  fields: [PublicPetitionField!]!

  """
  If this organization has the REMOVE_PARALLEL_BRANDING feature flag enabled
  """
  hasRemoveParallelBranding: Boolean!
    @deprecated(reason: "Use PublicOrganization.hasRemoveParallelBranding")

  """
  The ID of the petition.
  """
  id: GID!

  """
  Wether the completion message will be shown to the recipients or not.
  """
  isCompletingMessageEnabled: Boolean!

  """
  Whether the contents card is hidden in the recipient view.
  """
  isRecipientViewContentsHidden: Boolean! @deprecated(reason: "Don't use this")

  """
  The locale of the parallel.
  """
  locale: PetitionLocale!

  """
  The organization of the petition.
  """
  organization: PublicOrganization!

  """
  The recipients of the petition
  """
  recipients: [PublicContact!]!

  """
  The signature config of the petition
  """
  signatureConfig: PublicSignatureConfig
  signatureStatus: PublicSignatureStatus

  """
  The status of the petition.
  """
  status: PetitionStatus!

  """
  The preferred tone of organization.
  """
  tone: Tone!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

"""
A public view of a petition access
"""
type PublicPetitionAccess {
  contact: PublicContact
  granter: PublicUser
  message: PublicPetitionMessage
  petition: PublicPetition
}

"""
A field within a petition.
"""
type PublicPetitionField {
  """
  Alias of the petition field.
  """
  alias: String

  """
  A list of files attached to this field.
  """
  attachments: [PetitionFieldAttachment!]!
  commentCount: Int!

  """
  The comments for this field.
  """
  comments: [PublicPetitionFieldComment!]!

  """
  The description of the petition field.
  """
  description: String
  hasCommentsEnabled: Boolean!

  """
  The ID of the petition field.
  """
  id: GID!

  """
  Determines if the field is visible by the recipients.
  """
  isInternal: Boolean!

  """
  Determines if the field accepts replies
  """
  isReadOnly: Boolean!

  """
  Determines if this field allows multiple replies.
  """
  multiple: Boolean!

  """
  Determines if this field is optional.
  """
  optional: Boolean!

  """
  The options of the petition field.
  """
  options: JSONObject!
  petition: PublicPetition!

  """
  The replies to the petition field
  """
  replies: [PublicPetitionFieldReply!]!

  """
  The title of the petition field.
  """
  title: String

  """
  The type of the petition field.
  """
  type: PetitionFieldType!
  unreadCommentCount: Int!

  """
  A JSON object representing the conditions for the field to be visible
  """
  visibility: JSONObject
}

"""
A comment on a petition field
"""
type PublicPetitionFieldComment {
  """
  The author of the comment.
  """
  author: PublicUserOrContact

  """
  The content of the comment.
  """
  content: String!

  """
  Time when the comment was created.
  """
  createdAt: DateTime!
  field: PublicPetitionField!

  """
  The ID of the petition field comment.
  """
  id: GID!
  isAnonymized: Boolean!

  """
  Whether the comment has been read or not.
  """
  isUnread: Boolean!
}

"""
A reply to a petition field
"""
type PublicPetitionFieldReply implements Timestamps {
  """
  The public content of the reply
  """
  content: JSONObject!

  """
  Time when the resource was created.
  """
  createdAt: DateTime!
  field: PublicPetitionField!

  """
  The ID of the petition field reply.
  """
  id: GID!
  isAnonymized: Boolean!

  """
  The status of the petition field reply.
  """
  status: PetitionFieldReplyStatus!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

type PublicPetitionLink {
  description: String!
  id: GID!
  isActive: Boolean!
  owner: User!
  prefillSecret: String
  slug: String!
  template: PetitionTemplate!
  title: String!
  url: String!
}

"""
A public message in a petition
"""
type PublicPetitionMessage {
  """
  The ID of the message.
  """
  id: GID!

  """
  Subject of a email.
  """
  subject: String
}

input PublicPetitionSignerDataInput {
  email: String!
  firstName: String!
  lastName: String!
}

type PublicPublicPetitionLink {
  description: String!
  isActive: Boolean!

  """
  If the organization has enough credits to send a petition with this public link or not
  """
  isAvailable: Boolean!
  owner: PublicUser!
  slug: String!
  title: String!
}

"""
The public signature settings of a petition
"""
type PublicSignatureConfig {
  """
  The signers assigned by the petition recipient
  """
  additionalSigners: [PetitionSigner!]!

  """
  If true, allows the recipients or users of the petition to select additional signers
  """
  allowAdditionalSigners: Boolean!

  """
  If true, lets the user review the replies before starting the signature process
  """
  review: Boolean!

  """
  The contacts that need to sign the generated document.
  """
  signers: [PetitionSigner!]!
}

enum PublicSignatureStatus {
  COMPLETED
  STARTED
}

"""
A public view of a user
"""
type PublicUser {
  """
  The email of the user.
  """
  email: String!

  """
  The first name of the user.
  """
  firstName: String

  """
  The full name of the user.
  """
  fullName: String!

  """
  The ID of the user.
  """
  id: GID!

  """
  The last name of the user.
  """
  lastName: String

  """
  The organization of the user.
  """
  organization: PublicOrganization!
}

union PublicUserOrContact = PublicContact | PublicUser

type Query {
  access(keycode: ID!): PublicPetitionAccess
  contact(id: GID!): Contact

  """
  The contacts of the user
  """
  contacts(
    exclude: [GID!]

    """
    Number of elements to take from the list.
    """
    limit: Int

    """
    Number of elements to skip from the list.
    """
    offset: Int

    """
    Optional text to search in the collection.
    """
    search: String

    """
    Sorting to use on the collection
    """
    sortBy: [QueryContacts_OrderBy!]
  ): ContactPagination!

  """
  Matches the emails passed as argument with a Contact in the database. Returns a list of nullable Contacts
  """
  contactsByEmail(emails: [String!]!): [Contact]!

  """
  Checks if the provided email is available to be registered as a user on Parallel
  """
  emailIsAvailable(email: String!): Boolean!
  getSlugForPublicPetitionLink(petitionName: String): String!

  """
  Get users or groups from IDs
  """
  getUsersOrGroups(ids: [ID!]!): [UserOrUserGroup!]!

  """
  Decodes the given Global ID into an entity in the database.
  """
  globalIdDecode(
    """
    Global ID to decode
    """
    id: ID!
  ): SupportMethodResponse!

  """
  Encodes the given ID into a Global ID.
  """
  globalIdEncode(
    """
    ID to encode
    """
    id: Int!
    type: EntityType!
  ): SupportMethodResponse!
  isValidPublicPetitionLinkSlug(slug: String!): Boolean!
  landingTemplateBySlug(slug: String!): LandingTemplate
  landingTemplateCategorySamples: [LandingTemplateCategorySample!]!
  landingTemplates(
    categories: [String!]

    """
    Number of elements to take from the list.
    """
    limit: Int
    locale: PetitionLocale!

    """
    Number of elements to skip from the list.
    """
    offset: Int
  ): LandingTemplatePagination!
  me: User!
  metadata(keycode: ID): ConnectionMetadata!
  organization(id: GID!): Organization

  """
  The organizations registered in Parallel.
  """
  organizations(
    """
    Number of elements to take from the list.
    """
    limit: Int

    """
    Number of elements to skip from the list.
    """
    offset: Int

    """
    Optional text to search in the collection.
    """
    search: String

    """
    Sorting to use on the collection
    """
    sortBy: [QueryOrganizations_OrderBy!]

    """
    Optional status to filter for.
    """
    status: OrganizationStatus
  ): OrganizationPagination!
  petition(id: GID!): PetitionBase
  petitionEvents(
    """
    Filter events that happened before the specified event id
    """
    before: GID
    eventTypes: [PetitionEventType!]
  ): [PetitionEvent!]!

  """
  A field of the petition.
  """
  petitionField(petitionFieldId: GID!, petitionId: GID!): PetitionField!

  """
  The petitions of the user
  """
  petitions(
    filters: PetitionFilter

    """
    Number of elements to take from the list.
    """
    limit: Int

    """
    Number of elements to skip from the list.
    """
    offset: Int

    """
    Optional text to search in the collection.
    """
    search: String

    """
    Sorting to use on the collection
    """
    sortBy: [QueryPetitions_OrderBy!]
  ): PetitionBasePagination!
  petitionsById(ids: [GID!]!): [PetitionBase]!
  publicLicenseCode(code: String!, token: ID!): PublicLicenseCode
  publicOrgLogoUrl(id: GID!): String

  """
  The comments for this field.
  """
  publicPetitionField(keycode: ID!, petitionFieldId: GID!): PublicPetitionField!
  publicPetitionLinkBySlug(prefill: String, slug: ID!): PublicPublicPetitionLink
  publicTask(keycode: ID!, taskId: GID!): Task!
  publicTemplateCategories: [String!]!
  realMe: User!

  """
  Search user groups
  """
  searchUserGroups(excludeUserGroups: [GID!], search: String!): [UserGroup!]!

  """
  Search users and user groups
  """
  searchUsers(
    excludeUserGroups: [GID!]
    excludeUsers: [GID!]
    includeGroups: Boolean
    includeInactive: Boolean
    search: String!
  ): [UserOrUserGroup!]!
  subscriptions: [PetitionEventSubscription!]!

  """
  Paginated list of tags in the organization
  """
  tags(
    """
    Number of elements to take from the list.
    """
    limit: Int

    """
    Number of elements to skip from the list.
    """
    offset: Int

    """
    Optional text to search in the collection.
    """
    search: String
  ): TagPagination!
  task(id: GID!): Task!

  """
  The available templates
  """
  templates(
    category: String
    isOwner: Boolean
    isPublic: Boolean!

    """
    Number of elements to take from the list.
    """
    limit: Int
    locale: PetitionLocale

    """
    Number of elements to skip from the list.
    """
    offset: Int

    """
    Optional text to search in the collection.
    """
    search: String
  ): PetitionTemplatePagination!
  userGroup(id: GID!): UserGroup

  """
  Paginated list of user groups in the organization
  """
  userGroups(
    """
    Number of elements to take from the list.
    """
    limit: Int

    """
    Number of elements to skip from the list.
    """
    offset: Int

    """
    Optional text to search in the collection.
    """
    search: String

    """
    Sorting to use on the collection
    """
    sortBy: [QueryUserGroups_OrderBy!]
  ): UserGroupPagination!
}

"""
Order to use on Query.contacts
"""
enum QueryContacts_OrderBy {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  fullName_ASC
  fullName_DESC
  lastName_ASC
  lastName_DESC
}

"""
Order to use on Query.organizations
"""
enum QueryOrganizations_OrderBy {
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
}

"""
Order to use on Query.petitions
"""
enum QueryPetitions_OrderBy {
  createdAt_ASC
  createdAt_DESC
  lastUsedAt_ASC
  lastUsedAt_DESC
  name_ASC
  name_DESC
  sentAt_ASC
  sentAt_DESC
}

"""
Order to use on Query.userGroups
"""
enum QueryUserGroups_OrderBy {
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
}

type RecipientSignedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  signer: PetitionSigner
  type: PetitionEventType!
}

type ReminderEmailBouncedUserNotification implements PetitionUserNotification {
  access: PetitionAccess!
  createdAt: DateTime!
  id: GID!
  isRead: Boolean!
  petition: PetitionBase!
}

type ReminderSentEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  reminder: PetitionReminder!
  type: PetitionEventType!
}

"""
The reminder settings of a petition
"""
type RemindersConfig {
  """
  The amount of days between reminders.
  """
  offset: Int!

  """
  The time at which the reminder should be sent.
  """
  time: String!

  """
  The timezone the time is referring to.
  """
  timezone: String!

  """
  Whether to send reminders only from monday to friday.
  """
  weekdaysOnly: Boolean!
}

"""
The reminders settings for the petition
"""
input RemindersConfigInput {
  """
  The amount of days between reminders.
  """
  offset: Int!

  """
  The time at which the reminder should be sent.
  """
  time: String!

  """
  The timezone the time is referring to.
  """
  timezone: String!

  """
  Whether to send reminders only from monday to friday.
  """
  weekdaysOnly: Boolean!
}

type RemindersOptOutEvent implements PetitionEvent {
  access: PetitionAccess!
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  other: String
  petition: Petition
  reason: String!
  type: PetitionEventType!
}

type RemindersOptOutNotification implements PetitionUserNotification {
  access: PetitionAccess!
  createdAt: DateTime!
  id: GID!
  isRead: Boolean!
  other: String
  petition: PetitionBase!
  reason: String!
}

type ReplyCreatedEvent implements PetitionEvent {
  createdAt: DateTime!
  createdBy: UserOrPetitionAccess
  data: JSONObject!
  field: PetitionField
  id: GID!
  petition: Petition
  reply: PetitionFieldReply
  type: PetitionEventType!
}

type ReplyDeletedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  deletedBy: UserOrPetitionAccess
  field: PetitionField
  id: GID!
  petition: Petition
  type: PetitionEventType!
}

type ReplyUpdatedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  field: PetitionField
  id: GID!
  petition: Petition
  reply: PetitionFieldReply
  type: PetitionEventType!
  updatedBy: UserOrPetitionAccess
}

"""
Represents the result of an operation.
"""
enum Result {
  FAILURE
  SUCCESS
}

type SendPetitionResult {
  accesses: [PetitionAccess!]
  petition: Petition
  result: Result!
}

type SignatureCancelledEvent implements PetitionEvent {
  cancelType: PetitionSignatureCancelReason!
  cancelledBy: UserOrPetitionAccess
  canceller: PetitionSigner
  cancellerReason: String
  createdAt: DateTime!
  data: JSONObject!
  errorCode: String
  extraErrorData: JSON
  id: GID!
  petition: Petition
  type: PetitionEventType!
}

type SignatureCancelledUserNotification implements PetitionUserNotification {
  createdAt: DateTime!
  errorCode: String
  extraErrorData: JSON
  id: GID!
  isRead: Boolean!
  petition: PetitionBase!
}

type SignatureCompletedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
}

type SignatureCompletedUserNotification implements PetitionUserNotification {
  createdAt: DateTime!
  id: GID!
  isRead: Boolean!
  petition: PetitionBase!
}

"""
The signature settings of a petition
"""
type SignatureConfig {
  """
  If true, allows the recipients or users of the petition to select additional signers
  """
  allowAdditionalSigners: Boolean!

  """
  The signature integration selected for this signature config.
  """
  integration: SignatureOrgIntegration

  """
  If true, lets the user review the replies before starting the signature process
  """
  review: Boolean!

  """
  The signers of the generated document.
  """
  signers: [PetitionSigner]!

  """
  The timezone used to generate the document.
  """
  timezone: String!

  """
  Title of the signature document
  """
  title: String
}

"""
The signature settings for the petition
"""
input SignatureConfigInput {
  """
  If true, allows the recipients or users of the petition to select additional signers
  """
  allowAdditionalSigners: Boolean!

  """
  The Global ID of the signature integration to be used.
  """
  orgIntegrationId: GID!

  """
  If true, lets the user review the replies before starting the signature process
  """
  review: Boolean!
  signersInfo: [SignatureConfigInputSigner!]!

  """
  The timezone used to generate the document.
  """
  timezone: String!

  """
  The title of the signing document
  """
  title: String
}

"""
The signer that need to sign the generated document.
"""
input SignatureConfigInputSigner {
  contactId: GID
  email: String!
  firstName: String!
  lastName: String
}

type SignatureOpenedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  signer: PetitionSigner
  type: PetitionEventType!
}

type SignatureOrgIntegration implements OrgIntegration {
  """
  Environment of this integration, to differentiate between sandbox and production-ready integrations
  """
  environment: SignatureOrgIntegrationEnvironment!
  id: GID!

  """
  Wether this integration is the default to be used if the user has more than one of the same type
  """
  isDefault: Boolean!

  """
  Custom name of this integration, provided by the user
  """
  name: String!
  provider: SignatureOrgIntegrationProvider!

  """
  The type of the integration.
  """
  type: IntegrationType!
}

enum SignatureOrgIntegrationEnvironment {
  DEMO
  PRODUCTION
}

enum SignatureOrgIntegrationProvider {
  SIGNATURIT
}

type SignatureReminderEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
  user: User
}

type SignatureStartedEvent implements PetitionEvent {
  bouncedAt: DateTime
  createdAt: DateTime!
  data: JSONObject!
  deliveredAt: DateTime
  id: GID!
  openedAt: DateTime
  petition: Petition
  type: PetitionEventType!
}

type SsoOrgIntegration implements OrgIntegration {
  id: GID!

  """
  Wether this integration is the default to be used if the user has more than one of the same type
  """
  isDefault: Boolean!

  """
  Custom name of this integration, provided by the user
  """
  name: String!

  """
  The type of the integration.
  """
  type: IntegrationType!
}

"""
Represents a successful execution.
"""
enum Success {
  SUCCESS
}

"""
Return type for all support methods
"""
type SupportMethodResponse {
  message: String
  result: Result!
}

type Tag {
  """
  The color of the tag in hex format (example: #FFFFFF)
  """
  color: String!

  """
  Time when the resource was created.
  """
  createdAt: DateTime!
  id: GID!
  name: String!
}

type TagPagination {
  """
  The requested slice of items.
  """
  items: [Tag!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

type Task {
  id: GID!
  name: TaskName!
  output: JSONObject
  progress: Int
  status: TaskStatus!
}

enum TaskName {
  EXPORT_EXCEL
  EXPORT_REPLIES
  PRINT_PDF
  TEMPLATE_REPLIES_REPORT
  TEMPLATE_STATS_REPORT
}

type TaskResultFile {
  filename: String!
  url: String!
}

enum TaskStatus {
  COMPLETED
  ENQUEUED
  FAILED
  PROCESSING
}

interface TemplateDefaultPermission implements Timestamps {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!
  id: GID!

  """
  wether user is will be subscribed or not to emails and alerts of the generated petition
  """
  isSubscribed: Boolean!

  """
  The type of the permission.
  """
  permissionType: PetitionPermissionType!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

"""
The permission for a petition and user group
"""
type TemplateDefaultUserGroupPermission implements TemplateDefaultPermission & Timestamps {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  The group linked to the permission
  """
  group: UserGroup!
  id: GID!

  """
  wether user is will be subscribed or not to emails and alerts of the generated petition
  """
  isSubscribed: Boolean!

  """
  The type of the permission.
  """
  permissionType: PetitionPermissionType!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

"""
The permission for a petition and user
"""
type TemplateDefaultUserPermission implements TemplateDefaultPermission & Timestamps {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!
  id: GID!

  """
  wether user is will be subscribed or not to emails and alerts of the generated petition
  """
  isSubscribed: Boolean!

  """
  The type of the permission.
  """
  permissionType: PetitionPermissionType!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!

  """
  The user linked to the permission
  """
  user: User!
}

type TemplateUsedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  petition: Petition
  type: PetitionEventType!
}

interface Timestamps {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

"""
The preferred tone of organization
"""
enum Tone {
  FORMAL
  INFORMAL
}

input UpdateContactInput {
  firstName: String
  lastName: String
}

input UpdatePetitionFieldInput {
  alias: String
  description: String
  hasCommentsEnabled: Boolean
  isInternal: Boolean
  multiple: Boolean
  optional: Boolean
  options: JSONObject
  showInPdf: Boolean
  title: String
  visibility: JSONObject
}

input UpdatePetitionInput {
  anonymizeAfterMonths: Int
  anonymizePurpose: String
  closingEmailBody: JSON
  completingMessageBody: JSON
  completingMessageSubject: String
  deadline: DateTime
  description: JSON
  emailBody: JSON
  emailSubject: String
  isCompletingMessageEnabled: Boolean
  isRecipientViewContentsHidden: Boolean
  locale: PetitionLocale
  name: String
  remindersConfig: RemindersConfigInput
  signatureConfig: SignatureConfigInput
  skipForwardSecurity: Boolean
}

input UpdateTagInput {
  color: String
  name: String
}

input UpdateUserGroupInput {
  name: String
}

"""
The `Upload` scalar type represents a file upload.
"""
scalar Upload

"""
A user in the system.
"""
type User implements Timestamps {
  """
  URL to the user avatar
  """
  avatarUrl(options: ImageOptions): String
  canCreateUsers: Boolean!

  """
  Time when the resource was created.
  """
  createdAt: DateTime!

  """
  Users that the user can send on behalf of
  """
  delegateOf: [User!]!

  """
  Users that the user allows to send on their behalf
  """
  delegates: [User!]!

  """
  The email of the user.
  """
  email: String!

  """
  The first name of the user.
  """
  firstName: String

  """
  The full name of the user.
  """
  fullName: String
  hasFeatureFlag(featureFlag: FeatureFlag!): Boolean!

  """
  The ID of the user.
  """
  id: GID!

  """
  The initials of the user.
  """
  initials: String
  isSsoUser: Boolean!
  isSuperAdmin: Boolean!
  lastActiveAt: DateTime

  """
  The last name of the user.
  """
  lastName: String

  """
  Read and unread user notifications about events on their petitions
  """
  notifications(
    """
    Return notifications after the specified date.
    """
    before: DateTime
    filter: PetitionUserNotificationFilter

    """
    Number of elements to take from the list.
    """
    limit: Int
  ): UserNotifications_Pagination!
  organization: Organization!

  """
  Organizations this user belongs to
  """
  organizations: [Organization!]!
  preferredLocale: String
  role: OrganizationRole!
  status: UserStatus!

  """
  Lists the API tokens this user has.
  """
  tokens: [UserAuthenticationToken!]!
  unreadNotificationIds: [ID!]!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
  userGroups: [UserGroup!]!
}

type UserAuthenticationToken implements CreatedAt {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!
  hint: String
  id: GID!
  lastUsedAt: DateTime
  tokenName: String!
}

type UserGroup implements Timestamps {
  """
  Time when the resource was created.
  """
  createdAt: DateTime!
  id: GID!
  initials: String!
  memberCount: Int!
  members: [UserGroupMember!]!
  name: String!

  """
  Time when the resource was last updated.
  """
  updatedAt: DateTime!
}

type UserGroupMember {
  """
  The time the user was added to the user group.
  """
  addedAt: DateTime!
  id: GID!
  user: User!
}

type UserGroupPagination {
  """
  The requested slice of items.
  """
  items: [UserGroup!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

type UserNotifications_Pagination {
  """
  Whether this resource has more items.
  """
  hasMore: Boolean!

  """
  The requested slice of items.
  """
  items: [PetitionUserNotification!]!
}

union UserOrPetitionAccess = PetitionAccess | User

union UserOrUserGroup = User | UserGroup

input UserOrUserGroupPermissionInput {
  isSubscribed: Boolean!
  permissionType: PetitionPermissionType!
  userGroupId: GID
  userId: GID
}

type UserPagination {
  """
  The requested slice of items.
  """
  items: [User!]!

  """
  The total count of items in the list.
  """
  totalCount: Int!
}

type UserPermissionAddedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  permissionType: PetitionPermissionType!
  permissionUser: User
  petition: Petition
  type: PetitionEventType!
  user: User
}

type UserPermissionEditedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  permissionType: PetitionPermissionType!
  permissionUser: User
  petition: Petition
  type: PetitionEventType!
  user: User
}

type UserPermissionRemovedEvent implements PetitionEvent {
  createdAt: DateTime!
  data: JSONObject!
  id: GID!
  permissionUser: User
  petition: Petition
  type: PetitionEventType!
  user: User
}

type UserProvisioningOrgIntegration implements OrgIntegration {
  id: GID!

  """
  Wether this integration is the default to be used if the user has more than one of the same type
  """
  isDefault: Boolean!

  """
  Custom name of this integration, provided by the user
  """
  name: String!

  """
  The type of the integration.
  """
  type: IntegrationType!
}

enum UserStatus {
  ACTIVE
  INACTIVE
}

type VerificationCodeCheck {
  remainingAttempts: Int
  result: Result!
}

type VerificationCodeRequest {
  expiresAt: DateTime!
  remainingAttempts: Int!
  token: ID!
}
