// eslint-disable-next-line @typescript-eslint/no-var-requires
require("dotenv").config();
import camelCase from "camelcase";
import { promises as fs } from "fs";
import Knex from "knex";
import path from "path";
import { format } from "prettier";
import { groupBy, indexBy } from "remeda";

const EXCLUDED_TABLES = ["migrations", "migrations_lock"];

const knex = Knex({
  client: "pg",
  connection: {
    host: process.env.DB_HOST!,
    database: process.env.DB_DATABASE!,
    user: process.env.DB_USER!,
    password: process.env.DB_PASSWORD!,
  },
});

interface DbEnum {
  name: string;
  values: string[];
}

interface DbColumn {
  name: string;
  type: string;
  isNullable: boolean;
  hasDefault: boolean;
  position: number;
}

interface DbTable {
  primaryKey: string;
  name: string;
  tableName: string;
  columns: DbColumn[];
}

async function generateTypes(dist: string) {
  const tableNames = await getTableNames();
  const enums = await getDefinedEnums();
  const tables = await getDefinedTables(tableNames, enums);
  const contents = /* ts */ `/**
 * This file was automatically generated by generate-db-types
 * Do not make changes to this file directly
 */

type Maybe<T> = T | null;

type PartialProps<T, K extends keyof T = never> = Omit<T, K> & Partial<Pick<T, K>>;

  ${Array.from(enums.values())
    .map(
      ({ name, values }) => `
export type ${name} = ${values
        .sort((a, b) => a.localeCompare(b))
        .map((value) => `"${value}"`)
        .join(" | ")};`
    )
    .join("\n")}

export interface TableTypes {
  ${Array.from(tables.values())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(({ name, tableName }) => `${tableName}: ${name};`)
    .join("\n  ")}
}

export interface TableCreateTypes {
  ${Array.from(tables.values())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(({ name, tableName }) => `${tableName}: Create${name};`)
    .join("\n  ")}
}

export interface TablePrimaryKeys {
  ${Array.from(tables.values())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(({ tableName, primaryKey }) => `${tableName}: "${primaryKey}";`)
    .join("\n  ")}
}

  ${Array.from(tables.values())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(
      (table) => `
export interface ${table.name} {
  ${table.columns
    .sort((a, b) => a.position - b.position)
    .map((c) => {
      return `${c.name}: ${c.isNullable ? `Maybe<${c.type}>` : c.type};`;
    })
    .join("\n  ")}
}

export type Create${table.name} = PartialProps<
  Omit<${table.name}, "${table.primaryKey}">,
  ${table.columns
    .filter(
      (c) => c.name !== table.primaryKey && (c.hasDefault || c.isNullable)
    )
    .map((c) => `"${c.name}"`)
    .join("|")}
>;`
    )
    .join("\n")}
  `;
  await fs.writeFile(dist, format(contents, { parser: "typescript" }));
}

async function query<T>(sql: string, bindings?: any[]) {
  const result = await knex.raw(sql, bindings as any);
  return result.rows as T[];
}

async function getTableNames() {
  const rows = await query<{
    table_name: string;
  }>(/* sql */ `
      select table_name
      from information_schema.tables
      where table_schema = 'public'
  `);
  const tableNames = rows
    .map((t) => t.table_name)
    .filter((t) => !EXCLUDED_TABLES.includes(t))
    .sort();
  return tableNames;
}

async function getDefinedEnums() {
  const rows = await query<{
    typname: string;
    enumlabel: string;
  }>(/* sql */ `
      select 
        t.typname, e.enumlabel
      from pg_catalog.pg_type as t
        join pg_catalog.pg_enum as e on t.oid = e.enumtypid
        join pg_catalog.pg_namespace as n on n.oid = t.typnamespace
      where n.nspname = 'public'
        order by t.typname, e.enumsortorder
  `);
  const result = new Map<string, DbEnum>();
  for (const { typname: name, enumlabel: value } of rows) {
    if (!result.has(name)) {
      result.set(name, {
        name: camelCase(name, { pascalCase: true }),
        values: [],
      });
    }
    result.get(name)!.values.push(value);
  }
  return result;
}

async function getDefinedTables(tables: string[], enums: Map<string, DbEnum>) {
  const columns = groupBy(
    await query<{
      table_name: string;
      column_name: string;
      udt_name: string;
      is_nullable: "YES" | "NO";
      column_default: string | null;
      ordinal_position: number;
    }>(
      /* sql */ `
      select
        table_name, column_name, udt_name, is_nullable, column_default, ordinal_position
      from information_schema.columns
        where table_name in (${tables.map(() => "?").join(", ")})
    `,
      [...tables]
    ),
    (c) => c.table_name
  );
  const primaryKeys = indexBy(
    await query<{ table_name: string; column_name: string }>(
      /* sql */ `
      select
        tc.table_name, ccu.column_name
      from information_schema.table_constraints as tc
        join information_schema.constraint_column_usage as ccu
          on tc.constraint_schema = ccu.constraint_schema and tc.constraint_name = ccu.constraint_name
        where tc.constraint_type = 'PRIMARY KEY'
          and tc.table_name in (${tables.map(() => "?").join(", ")})
    `,
      [...tables]
    ),
    (pk) => pk.table_name
  );
  return new Map<string, DbTable>(
    Object.entries(columns).map(([tableName, columns]) => [
      tableName,
      {
        name: camelCase(tableName, { pascalCase: true }),
        tableName: tableName,
        columns: columns.map((column) => ({
          name: column.column_name,
          type: getColumnType(column.udt_name, enums),
          isNullable: column.is_nullable === "YES",
          hasDefault: !!column.column_default,
          position: column.ordinal_position,
        })),
        primaryKey: primaryKeys[tableName].column_name,
      },
    ])
  );
}

function getColumnType(type: string, enums: Map<string, DbEnum>): string {
  if (type.startsWith("_")) {
    return `${getColumnType(type.slice(1), enums)}[]`;
  }
  switch (type) {
    case "bpchar":
    case "char":
    case "varchar":
    case "text":
    case "citext":
    case "uuid":
    case "bytea":
    case "inet":
    case "time":
    case "timetz":
    case "interval":
    case "name":
      return "string";
    case "int2":
    case "int4":
    case "int8":
    case "float4":
    case "float8":
    case "numeric":
    case "money":
    case "oid":
      return "number";
    case "bool":
      return "boolean";
    case "json":
    case "jsonb":
      return "any";
    case "date":
    case "timestamp":
    case "timestamptz":
      return "Date";
    default:
      if (enums.has(type)) {
        return enums.get(type)!.name;
      } else {
        throw new Error(`Unrecognized type "${type}"`);
      }
  }
}

async function main() {
  try {
    await generateTypes(path.join(__dirname, "../src/db/__types.ts"));
  } catch (e) {
    console.log(e);
  } finally {
    await knex.destroy();
  }
}

main().then();
