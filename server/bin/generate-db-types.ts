// eslint-disable-next-line @typescript-eslint/no-var-requires
require("dotenv").config();
import camelCase from "camelcase";
import { promises as fs } from "fs";
import Knex from "knex";
import path from "path";
import { format } from "prettier";
import { groupBy, indexBy } from "remeda";

const EXCLUDED_TABLES = ["migrations", "migrations_lock"];

const knex = Knex({
  client: "pg",
  connection: {
    host: process.env.DB_HOST!,
    database: process.env.DB_DATABASE!,
    user: process.env.DB_USER!,
    password: process.env.DB_PASSWORD!,
  },
});

interface DbEnum {
  name: string;
  values: string[];
}

interface DbColumn {
  name: string;
  type: string;
  nullable: boolean;
  hasDefault: boolean;
  position: number;
}

interface DbTable {
  primaryKey: string;
  name: string;
  tableName: string;
  columns: DbColumn[];
}

async function generateTypes(dist: string) {
  const tableNames = await getTableNames();
  const enums = await getDefinedEnums();
  const tables = await getDefinedTables(tableNames, enums);
  const contents = `/**
 * This file was automatically generated by generate-db-types
 * Do not make changes to this file directly
 */

export type Maybe<T> = T | null;
  ${Array.from(enums.values())
    .map(
      ({ name, values }) => `
export type ${name} = ${values.map((value) => `"${value}"`).join(" | ")};`
    )
    .join("\n")}

export interface TableTypes {
  ${Array.from(tables.values())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(({ name, tableName }) => `${tableName}: ${name};`)
    .join("\n  ")}
}

export interface TableCreateTypes {
  ${Array.from(tables.values())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(({ name, tableName }) => `${tableName}: Create${name};`)
    .join("\n  ")}
}

export interface TablePrimaryKeys {
  ${Array.from(tables.values())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(({ tableName, primaryKey }) => `${tableName}: "${primaryKey}";`)
    .join("\n  ")}
}

  ${Array.from(tables.values())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(
      ({ name, columns, primaryKey }) => `
export interface ${name} {
  ${columns
    .sort((a, b) => a.position - b.position)
    .map((c) => `${c.name}: ${c.nullable ? `Maybe<${c.type}>` : c.type};`)
    .join("\n  ")}
}

export interface Create${name} {
  ${columns
    .filter((c) => c.name !== primaryKey)
    .map(
      (c) =>
        `${c.name}${c.hasDefault || c.nullable ? "?" : ""}: ${
          c.nullable ? `Maybe<${c.type}>` : c.type
        };`
    )
    .join("\n  ")}
}`
    )
    .join("\n")}
  `;
  await fs.writeFile(dist, format(contents, { parser: "typescript" }));
}

async function getTableNames() {
  const rows = await knex
    .select("table_name")
    .from("information_schema.tables")
    .where("table_schema", "public");
  const tableNames = rows
    .map((t) => t.table_name as string)
    .filter((t) => !EXCLUDED_TABLES.includes(t))
    .sort();
  return tableNames;
}

async function getDefinedEnums() {
  const rows = await knex
    .select(
      "t.typname as name",
      "e.enumlabel as value",
      "e.enumsortorder as order"
    )
    .from("pg_catalog.pg_type as t")
    .join("pg_catalog.pg_enum as e", "t.oid", "=", "e.enumtypid")
    .join("pg_catalog.pg_namespace as n", "n.oid", "=", "t.typnamespace")
    .where("n.nspname", "public")
    .orderBy(["name", "order"]);
  const result = new Map<string, DbEnum>();
  for (const { name, value } of rows) {
    if (!result.has(name)) {
      result.set(name, {
        name: camelCase(name, { pascalCase: true }),
        values: [],
      });
    }
    result.get(name)!.values.push(value);
  }
  return result;
}

async function getDefinedTables(tables: string[], enums: Map<string, DbEnum>) {
  const columns = groupBy(
    await knex
      .select(
        "table_name",
        "column_name ",
        "udt_name",
        "is_nullable",
        "column_default",
        "ordinal_position"
      )
      .from("information_schema.columns")
      .whereIn("table_name", tables),
    (c) => c.table_name
  );
  const primaryKeys = indexBy(
    await knex
      .select("tc.table_name", "ccu.column_name")
      .from("information_schema.table_constraints as tc")
      .join("information_schema.constraint_column_usage as ccu", function () {
        this.on("tc.constraint_schema", "ccu.constraint_schema").andOn(
          "tc.constraint_name",
          "ccu.constraint_name"
        );
      })
      .where("tc.constraint_type", "PRIMARY KEY")
      .whereIn("tc.table_name", tables),
    (pk) => pk.table_name
  );
  return new Map<string, DbTable>(
    Object.entries(columns).map(([tableName, columns]) => [
      tableName,
      {
        name: camelCase(tableName, { pascalCase: true }),
        tableName: tableName,
        columns: columns.map((column) => ({
          name: column.column_name,
          type: getColumnType(column.udt_name, enums),
          nullable: column.is_nullable === "YES",
          hasDefault: !!column.column_default,
          position: column.ordinal_position,
        })),
        primaryKey: primaryKeys[tableName].column_name,
      },
    ])
  );
}

function getColumnType(type: string, enums: Map<string, DbEnum>): string {
  if (type.startsWith("_")) {
    return `${getColumnType(type.slice(1), enums)}[]`;
  }
  switch (type) {
    case "bpchar":
    case "char":
    case "varchar":
    case "text":
    case "citext":
    case "uuid":
    case "bytea":
    case "inet":
    case "time":
    case "timetz":
    case "interval":
    case "name":
      return "string";
    case "int2":
    case "int4":
    case "int8":
    case "float4":
    case "float8":
    case "numeric":
    case "money":
    case "oid":
      return "number";
    case "bool":
      return "boolean";
    case "json":
    case "jsonb":
      return "any";
    case "date":
    case "timestamp":
    case "timestamptz":
      return "Date";
    default:
      if (enums.has(type)) {
        return enums.get(type)!.name;
      } else {
        throw new Error(`Unrecognized type "${type}"`);
      }
  }
}

async function main() {
  try {
    await generateTypes(path.join(__dirname, "../src/db/__types.ts"));
  } catch (e) {
    console.log(e);
  } finally {
    await knex.destroy();
  }
}

main().then();
