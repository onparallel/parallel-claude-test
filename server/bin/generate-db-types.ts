require("dotenv").config();
import camelCase from "camelcase";
import { promises as fs } from "fs";
import Knex from "knex";
import path from "path";
import { format } from "prettier";

const EXCLUDED_TABLES = ["migrations", "migrations_lock"];

const knex = Knex({
  client: "pg",
  connection: {
    host: process.env.DB_HOST!,
    database: process.env.DB_DATABASE!,
    user: process.env.DB_USER!,
    password: process.env.DB_PASSWORD!
  }
});

interface DbEnum {
  name: string;
  values: string[];
}

interface DbColumn {
  name: string;
  type: string;
  nullable: boolean;
  hasDefault: boolean;
  position: number;
}

interface DbTable {
  name: string;
  columns: DbColumn[];
}

async function generateTypes(dist: string) {
  const tableNames = await getTableNames();
  const enums = await getDefinedEnums();
  const tables = await getDefinedTables(tableNames, enums);
  const contents = `/**
 * This file was automatically generated by generate-db-types
 * Do not make changes to this file directly
 */

export type Maybe<T> = T | null;
  ${Array.from(enums.values())
    .map(
      ({ name, values }) => `
export type ${name} = ${values.map(value => `"${value}"`).join(" | ")};`
    )
    .join("\n")}
    
  ${Array.from(tables.values())
    .sort((a, b) => a.name.localeCompare(b.name))
    .map(
      ({ name, columns }) => `
export interface ${name} {
  ${columns
    .sort((a, b) => a.position - b.position)
    .map(c => `${c.name}: ${c.nullable ? `Maybe<${c.type}>` : c.type};`)
    .join("\n  ")}
}

export interface Create${name} {
  ${columns
    .map(
      c =>
        `${c.name}${c.hasDefault || c.nullable ? "?" : ""}: ${
          c.nullable ? `Maybe<${c.type}>` : c.type
        };`
    )
    .join("\n  ")}
}`
    )
    .join("\n")}
  `;
  await fs.writeFile(dist, format(contents, { parser: "typescript" }));
}

async function getTableNames() {
  const rows = await knex
    .select("table_name")
    .from("information_schema.tables")
    .where("table_schema", "public");
  const tableNames = rows
    .map(t => <string>t.table_name)
    .filter(t => !EXCLUDED_TABLES.includes(t))
    .sort();
  return tableNames;
}

async function getDefinedEnums() {
  const rows = await knex
    .select(
      "t.typname as name",
      "e.enumlabel as value",
      "e.enumsortorder as order"
    )
    .from("pg_catalog.pg_type as t")
    .join("pg_catalog.pg_enum as e", "t.oid", "=", "e.enumtypid")
    .join("pg_catalog.pg_namespace as n", "n.oid", "=", "t.typnamespace")
    .where("n.nspname", "public")
    .orderBy(["name", "order"]);
  const result = new Map<string, DbEnum>();
  for (const { name, value } of rows) {
    if (!result.has(name)) {
      result.set(name, {
        name: camelCase(name, { pascalCase: true }),
        values: []
      });
    }
    result.get(name)!.values.push(value);
  }
  return result;
}

async function getDefinedTables(tables: string[], enums: Map<string, DbEnum>) {
  const rows = await knex
    .select(
      "table_name",
      "column_name ",
      "udt_name",
      "is_nullable",
      "column_default",
      "ordinal_position"
    )
    .from("information_schema.columns")
    .whereIn("table_name", tables);
  const result = new Map<string, DbTable>();
  for (const row of rows) {
    if (!result.has(row.table_name)) {
      result.set(row.table_name, {
        name: camelCase(row.table_name, { pascalCase: true }),
        columns: []
      });
    }
    result.get(row.table_name)!.columns.push({
      name: row.column_name,
      type: getColumnType(row.udt_name, enums),
      nullable: row.is_nullable === "YES",
      hasDefault: !!row.column_default,
      position: row.ordinal_position
    });
  }
  return result;
}

function getColumnType(type: string, enums: Map<string, DbEnum>): string {
  if (type.startsWith("_")) {
    return `${getColumnType(type.slice(1), enums)}[]`;
  }
  switch (type) {
    case "bpchar":
    case "char":
    case "varchar":
    case "text":
    case "citext":
    case "uuid":
    case "bytea":
    case "inet":
    case "time":
    case "timetz":
    case "interval":
    case "name":
      return "string";
    case "int2":
    case "int4":
    case "int8":
    case "float4":
    case "float8":
    case "numeric":
    case "money":
    case "oid":
      return "number";
    case "bool":
      return "boolean";
    case "json":
    case "jsonb":
      return "Object";
    case "date":
    case "timestamp":
    case "timestamptz":
      return "Date";
    default:
      if (enums.has(type)) {
        return enums.get(type)!.name;
      } else {
        throw new Error(`Unrecognized type "${type}"`);
      }
  }
}

async function main() {
  try {
    await generateTypes(path.join(__dirname, "../src/db/__types.ts"));
  } catch (e) {
    console.log(e);
  } finally {
    await knex.destroy();
  }
}

main().then();
