diff --git a/node_modules/eslint-plugin-formatjs/rules/no-literal-string-in-jsx.js b/node_modules/eslint-plugin-formatjs/rules/no-literal-string-in-jsx.js
index c257693..2ce85cf 100644
--- a/node_modules/eslint-plugin-formatjs/rules/no-literal-string-in-jsx.js
+++ b/node_modules/eslint-plugin-formatjs/rules/no-literal-string-in-jsx.js
@@ -16,6 +16,7 @@ const defaultPropIncludePattern = [
     ['[a-z]*([a-z0-9])', '(placeholder|title)'],
     ['img', 'alt'],
 ];
+const IGNORE_REGEXES = [/^[^\p{L}]*$/u, /^parallel$/i, /^dow jones$/i];
 const defaultPropExcludePattern = [];
 function stringifyJsxTagName(tagName) {
     switch (tagName.type) {
@@ -106,11 +107,16 @@ exports.rule = {
         const checkJSXExpression = (node) => {
             // Check if this is either a string literal / template literal, or the concat of them.
             // It also ignores the empty string.
-            if ((node.type === 'Literal' &&
+            if (node.type === 'Literal' &&
                 typeof node.value === 'string' &&
-                node.value.length > 0) ||
-                (node.type === 'TemplateLiteral' &&
-                    (node.quasis.length > 1 || node.quasis[0].value.raw.length > 0))) {
+                !IGNORE_REGEXES.some(re => re.test(node.value))) {
+                context.report({
+                    node: node,
+                    messageId: 'noLiteralStringInJsx',
+                });
+            }
+            else if (node.type === 'TemplateLiteral' &&
+                     node.quasis.some(q => !IGNORE_REGEXES.some(re => re.test(q.value.raw)))) { 
                 context.report({
                     node: node,
                     messageId: 'noLiteralStringInJsx',
@@ -151,7 +157,7 @@ exports.rule = {
                 }
                 if (node.value.type === 'Literal' &&
                     typeof node.value.value === 'string' &&
-                    node.value.value.length > 0) {
+                    !IGNORE_REGEXES.some(re => re.test(node.value.value))) {
                     context.report({
                         node: node,
                         messageId: 'noLiteralStringInJsx',
@@ -164,7 +170,7 @@ exports.rule = {
             },
             JSXText: (node) => {
                 // Ignore purely spacing fragments
-                if (!node.value.replace(/\s*/gm, '')) {
+                if (!node.value.replace(/\s*/gm, '') || IGNORE_REGEXES.some(re => re.test(node.value))) {
                     return;
                 }
                 context.report({
