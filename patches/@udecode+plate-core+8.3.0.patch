diff --git a/node_modules/@udecode/plate-core/dist/index.es.js b/node_modules/@udecode/plate-core/dist/index.es.js
index d8b2ea8..5559403 100644
--- a/node_modules/@udecode/plate-core/dist/index.es.js
+++ b/node_modules/@udecode/plate-core/dist/index.es.js
@@ -1,30 +1,56 @@
-import React, { useCallback, useMemo, useRef, useEffect, memo } from 'react';
-import { Editor, Span, Range, Path, Node as Node$1, Element, Point, Text, Transforms, createEditor as createEditor$1 } from 'slate';
-import { ReactEditor, DefaultElement, withReact, Editable, useSlate, Slate, useSlateStatic } from 'slate-react';
-import create from 'zustand';
-import clsx from 'clsx';
-import { withHistory } from 'slate-history';
-import { renderToStaticMarkup } from 'react-dom/server';
+import React, { useCallback, useMemo, useRef, useEffect, memo } from "react";
+import {
+  Editor,
+  Span,
+  Range,
+  Path,
+  Node as Node$1,
+  Element,
+  Point,
+  Text,
+  Transforms,
+  createEditor as createEditor$1,
+} from "slate";
+import {
+  ReactEditor,
+  DefaultElement,
+  withReact,
+  Editable,
+  useSlate,
+  Slate,
+  useSlateStatic,
+} from "slate-react";
+import create from "zustand";
+import clsx from "clsx";
+import { withHistory } from "slate-history";
+import { renderToStaticMarkup } from "react-dom/server";
 
 function _extends() {
-  _extends = Object.assign || function (target) {
-    for (var i = 1; i < arguments.length; i++) {
-      var source = arguments[i];
-
-      for (var key in source) {
-        if (Object.prototype.hasOwnProperty.call(source, key)) {
-          target[key] = source[key];
+  _extends =
+    Object.assign ||
+    function (target) {
+      for (var i = 1; i < arguments.length; i++) {
+        var source = arguments[i];
+
+        for (var key in source) {
+          if (Object.prototype.hasOwnProperty.call(source, key)) {
+            target[key] = source[key];
+          }
         }
       }
-    }
 
-    return target;
-  };
+      return target;
+    };
 
   return _extends.apply(this, arguments);
 }
 
-const createNodeHOC = HOC => (Component, props) => childrenProps => /*#__PURE__*/React.createElement(HOC, _extends({}, childrenProps, props), /*#__PURE__*/React.createElement(Component, childrenProps));
+const createNodeHOC = (HOC) => (Component, props) => (childrenProps) =>
+  /*#__PURE__*/ React.createElement(
+    HOC,
+    _extends({}, childrenProps, props),
+    /*#__PURE__*/ React.createElement(Component, childrenProps)
+  );
 
 /**
  * Checks if `value` is classified as an `Array` object.
@@ -96,28 +122,25 @@ function castArray() {
 
 var castArray_1 = castArray;
 
-const createHOC = withHOC => {
+const createHOC = (withHOC) => {
   return (components, options) => {
-    const _components = { ...components
-    };
+    const _components = { ...components };
     const optionsByKey = {};
 
     const optionsList = castArray_1(options);
 
-    optionsList.forEach(({
-      key,
-      keys,
-      ...opt
-    }) => {
-      const _keys = key ? [key] : keys !== null && keys !== void 0 ? keys : Object.keys(_components);
+    optionsList.forEach(({ key, keys, ...opt }) => {
+      const _keys = key
+        ? [key]
+        : keys !== null && keys !== void 0
+        ? keys
+        : Object.keys(_components);
 
-      _keys.forEach(_key => {
-        optionsByKey[_key] = { ...optionsByKey[_key],
-          ...opt
-        };
+      _keys.forEach((_key) => {
+        optionsByKey[_key] = { ...optionsByKey[_key], ...opt };
       });
     });
-    Object.keys(optionsByKey).forEach(key => {
+    Object.keys(optionsByKey).forEach((key) => {
       if (!_components[key]) return;
       _components[key] = withHOC(_components[key], optionsByKey[key]);
     });
@@ -128,15 +151,14 @@ const createHOC = withHOC => {
  * Create components HOC by plugin key.
  */
 
-
-const createNodesHOC = HOC => {
+const createNodesHOC = (HOC) => {
   return createHOC(createNodeHOC(HOC));
 };
 /**
  * Create components HOC by plugin key with a custom HOC.
  */
 
-const createNodesWithHOC = withHOC => {
+const createNodesWithHOC = (withHOC) => {
   return createHOC(withHOC);
 };
 
@@ -144,7 +166,8 @@ const createNodesWithHOC = withHOC => {
  * HOC adding props.
  */
 
-const withProps = (Component, props) => _props => /*#__PURE__*/React.createElement(Component, _extends({}, _props, props));
+const withProps = (Component, props) => (_props) =>
+  /*#__PURE__*/ React.createElement(Component, _extends({}, _props, props));
 
 /**
  * Wrap a component into multiple providers.
@@ -152,16 +175,20 @@ const withProps = (Component, props) => _props => /*#__PURE__*/React.createEleme
  * you can simply pass an array.
  */
 
-const withProviders = (...providers) => WrappedComponent => props => providers.reduceRight((acc, prov) => {
-  let Provider = prov;
+const withProviders =
+  (...providers) =>
+  (WrappedComponent) =>
+  (props) =>
+    providers.reduceRight((acc, prov) => {
+      let Provider = prov;
 
-  if (Array.isArray(prov)) {
-    [Provider] = prov;
-    return /*#__PURE__*/React.createElement(Provider, prov[1], acc);
-  }
+      if (Array.isArray(prov)) {
+        [Provider] = prov;
+        return /*#__PURE__*/ React.createElement(Provider, prov[1], acc);
+      }
 
-  return /*#__PURE__*/React.createElement(Provider, null, acc);
-}, /*#__PURE__*/React.createElement(WrappedComponent, props));
+      return /*#__PURE__*/ React.createElement(Provider, null, acc);
+    }, /*#__PURE__*/ React.createElement(WrappedComponent, props));
 
 /**
  * Match the object with a predicate object or function.
@@ -172,7 +199,7 @@ const withProviders = (...providers) => WrappedComponent => props => providers.r
 const match = (obj, predicate) => {
   if (!predicate) return true;
 
-  if (typeof predicate === 'object') {
+  if (typeof predicate === "object") {
     return Object.entries(predicate).every(([key, value]) => {
       const values = castArray_1(value);
 
@@ -182,7 +209,7 @@ const match = (obj, predicate) => {
 
   return predicate(obj);
 };
-const matchPredicate = predicate => obj => match(obj, predicate);
+const matchPredicate = (predicate) => (obj) => match(obj, predicate);
 /**
  * Extended query options for slate queries:
  * - `match` can be an object predicate where one of the values should include the node value.
@@ -190,8 +217,11 @@ const matchPredicate = predicate => obj => match(obj, predicate);
  */
 
 const getQueryOptions = (editor, options) => {
-  return { ...options,
-    match: n => match(n, options.match) && (!(options !== null && options !== void 0 && options.block) || Editor.isBlock(editor, n))
+  return {
+    ...options,
+    match: (n) =>
+      match(n, options.match) &&
+      (!(options !== null && options !== void 0 && options.block) || Editor.isBlock(editor, n)),
   };
 };
 
@@ -206,12 +236,7 @@ const getQueryOptions = (editor, options) => {
 const findDescendant = (editor, options) => {
   // Slate throws when things aren't found so we wrap in a try catch and return undefined on throw.
   try {
-    const {
-      match: _match,
-      at = editor.selection,
-      reverse = false,
-      voids = false
-    } = options;
+    const { match: _match, at = editor.selection, reverse = false, voids = false } = options;
     if (!at) return;
     let from;
     let to;
@@ -220,10 +245,10 @@ const findDescendant = (editor, options) => {
       [from, to] = at;
     } else if (Range.isRange(at)) {
       const first = Editor.path(editor, at, {
-        edge: 'start'
+        edge: "start",
       });
       const last = Editor.path(editor, at, {
-        edge: 'end'
+        edge: "end",
       });
       from = reverse ? last : first;
       to = reverse ? first : last;
@@ -239,7 +264,7 @@ const findDescendant = (editor, options) => {
       reverse,
       from,
       to,
-      pass: ([n]) => voids ? false : Editor.isVoid(editor, n)
+      pass: ([n]) => (voids ? false : Editor.isVoid(editor, n)),
     });
 
     for (const [node, path] of nodeEntries) {
@@ -256,15 +281,11 @@ const findDescendant = (editor, options) => {
  * Return {@link Editor.unhangRange} if `unhang` is true and if `at` (default: selection) is a range.
  */
 const unhangRange = (editor, options = {}) => {
-  const {
-    at = editor.selection,
-    voids,
-    unhang = true
-  } = options;
+  const { at = editor.selection, voids, unhang = true } = options;
 
   if (Range.isRange(at) && unhang) {
     options.at = Editor.unhangRange(editor, at, {
-      voids
+      voids,
     });
   }
 };
@@ -282,7 +303,7 @@ const findNode = (editor, options = {}) => {
   try {
     const nodeEntries = getNodes(editor, {
       at: editor.selection || [],
-      ...getQueryOptions(editor, options)
+      ...getQueryOptions(editor, options),
     });
 
     for (const [node, path] of nodeEntries) {
@@ -314,15 +335,13 @@ const getAbove = (editor, options = {}) => {
  * Get the block above a location (default: selection).
  */
 
-const getBlockAbove = (editor, options = {}) => getAbove(editor, { ...options,
-  block: true
-});
+const getBlockAbove = (editor, options = {}) => getAbove(editor, { ...options, block: true });
 
 /**
  * Get children node entries of a node entry.
  * TODO: try Node.children
  */
-const getChildren = nodeEntry => {
+const getChildren = (nodeEntry) => {
   const [node, path] = nodeEntry;
   const children = node.children || [];
   return children.map((child, index) => {
@@ -334,7 +353,7 @@ const getChildren = nodeEntry => {
 /**
  * Get the last child of a node or null if no children.
  */
-const getLastChild$1 = nodeEntry => {
+const getLastChild$1 = (nodeEntry) => {
   const [node, path] = nodeEntry;
   if (!node.children.length) return null;
   return [node.children[node.children.length - 1], path.concat([node.children.length - 1])];
@@ -343,7 +362,7 @@ const getLastChild$1 = nodeEntry => {
  * Get last child path. If there is no child, last index is 0.
  */
 
-const getLastChildPath = nodeEntry => {
+const getLastChildPath = (nodeEntry) => {
   const lastChild = getLastChild$1(nodeEntry);
   if (!lastChild) return nodeEntry[1].concat([-1]);
   return lastChild[1];
@@ -359,13 +378,11 @@ const isLastChild = (parentEntry, childPath) => {
 
 const isElement = Element.isElement;
 
-const isAncestor = node => Editor.isEditor(node) || isElement(node);
+const isAncestor = (node) => Editor.isEditor(node) || isElement(node);
 
 const getLastChild = (node, level) => {
   if (!(level + 1) || !isAncestor(node)) return node;
-  const {
-    children
-  } = node;
+  const { children } = node;
   const lastNode = children[children.length - 1];
   return getLastChild(lastNode, level - 1);
 };
@@ -373,11 +390,8 @@ const getLastChild = (node, level) => {
  * Get the last node at a given level.
  */
 
-
 const getLastNode = (editor, level) => {
-  const {
-    children
-  } = editor;
+  const { children } = editor;
   const lastNode = children[children.length - 1];
   if (!lastNode) return;
   const [, lastPath] = Editor.last(editor, []);
@@ -391,7 +405,9 @@ const getMark = (editor, type) => {
   var _Editor$marks;
 
   if (!editor) return;
-  return (_Editor$marks = Editor.marks(editor)) === null || _Editor$marks === void 0 ? void 0 : _Editor$marks[type];
+  return (_Editor$marks = Editor.marks(editor)) === null || _Editor$marks === void 0
+    ? void 0
+    : _Editor$marks[type];
 };
 
 /**
@@ -447,8 +463,8 @@ const getParent = (editor, at, options) => {
  */
 function arrayMap(array, iteratee) {
   var index = -1,
-      length = array == null ? 0 : array.length,
-      result = Array(length);
+    length = array == null ? 0 : array.length,
+    result = Array(length);
 
   while (++index < length) {
     result[index] = iteratee(array[index], index, array);
@@ -547,7 +563,7 @@ var splice = arrayProto.splice;
  */
 function listCacheDelete(key) {
   var data = this.__data__,
-      index = _assocIndexOf(data, key);
+    index = _assocIndexOf(data, key);
 
   if (index < 0) {
     return false;
@@ -575,7 +591,7 @@ var _listCacheDelete = listCacheDelete;
  */
 function listCacheGet(key) {
   var data = this.__data__,
-      index = _assocIndexOf(data, key);
+    index = _assocIndexOf(data, key);
 
   return index < 0 ? undefined : data[index][1];
 }
@@ -609,7 +625,7 @@ var _listCacheHas = listCacheHas;
  */
 function listCacheSet(key, value) {
   var data = this.__data__,
-      index = _assocIndexOf(data, key);
+    index = _assocIndexOf(data, key);
 
   if (index < 0) {
     ++this.size;
@@ -631,7 +647,7 @@ var _listCacheSet = listCacheSet;
  */
 function ListCache(entries) {
   var index = -1,
-      length = entries == null ? 0 : entries.length;
+    length = entries == null ? 0 : entries.length;
 
   this.clear();
   while (++index < length) {
@@ -642,7 +658,7 @@ function ListCache(entries) {
 
 // Add methods to `ListCache`.
 ListCache.prototype.clear = _listCacheClear;
-ListCache.prototype['delete'] = _listCacheDelete;
+ListCache.prototype["delete"] = _listCacheDelete;
 ListCache.prototype.get = _listCacheGet;
 ListCache.prototype.has = _listCacheHas;
 ListCache.prototype.set = _listCacheSet;
@@ -657,7 +673,7 @@ var _ListCache = ListCache;
  * @memberOf Stack
  */
 function stackClear() {
-  this.__data__ = new _ListCache;
+  this.__data__ = new _ListCache();
   this.size = 0;
 }
 
@@ -674,7 +690,7 @@ var _stackClear = stackClear;
  */
 function stackDelete(key) {
   var data = this.__data__,
-      result = data['delete'](key);
+    result = data["delete"](key);
 
   this.size = data.size;
   return result;
@@ -712,26 +728,39 @@ function stackHas(key) {
 
 var _stackHas = stackHas;
 
-var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
+var commonjsGlobal =
+  typeof globalThis !== "undefined"
+    ? globalThis
+    : typeof window !== "undefined"
+    ? window
+    : typeof global !== "undefined"
+    ? global
+    : typeof self !== "undefined"
+    ? self
+    : {};
 
-function unwrapExports (x) {
-	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
+function unwrapExports(x) {
+  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
 }
 
 function createCommonjsModule(fn, module) {
-	return module = { exports: {} }, fn(module, module.exports), module.exports;
+  return (module = { exports: {} }), fn(module, module.exports), module.exports;
 }
 
 /** Detect free variable `global` from Node.js. */
-var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
+var freeGlobal =
+  typeof commonjsGlobal == "object" &&
+  commonjsGlobal &&
+  commonjsGlobal.Object === Object &&
+  commonjsGlobal;
 
 var _freeGlobal = freeGlobal;
 
 /** Detect free variable `self`. */
-var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
+var freeSelf = typeof self == "object" && self && self.Object === Object && self;
 
 /** Used as a reference to the global object. */
-var root = _freeGlobal || freeSelf || Function('return this')();
+var root = _freeGlobal || freeSelf || Function("return this")();
 
 var _root = root;
 
@@ -765,7 +794,7 @@ var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;
  */
 function getRawTag(value) {
   var isOwn = hasOwnProperty$d.call(value, symToStringTag$1),
-      tag = value[symToStringTag$1];
+    tag = value[symToStringTag$1];
 
   try {
     value[symToStringTag$1] = undefined;
@@ -809,8 +838,8 @@ function objectToString(value) {
 var _objectToString = objectToString;
 
 /** `Object#toString` result references. */
-var nullTag = '[object Null]',
-    undefinedTag = '[object Undefined]';
+var nullTag = "[object Null]",
+  undefinedTag = "[object Undefined]";
 
 /** Built-in value references. */
 var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
@@ -826,7 +855,7 @@ function baseGetTag(value) {
   if (value == null) {
     return value === undefined ? undefinedTag : nullTag;
   }
-  return (symToStringTag && symToStringTag in Object(value))
+  return symToStringTag && symToStringTag in Object(value)
     ? _getRawTag(value)
     : _objectToString(value);
 }
@@ -860,16 +889,16 @@ var _baseGetTag = baseGetTag;
  */
 function isObject$1(value) {
   var type = typeof value;
-  return value != null && (type == 'object' || type == 'function');
+  return value != null && (type == "object" || type == "function");
 }
 
 var isObject_1 = isObject$1;
 
 /** `Object#toString` result references. */
-var asyncTag = '[object AsyncFunction]',
-    funcTag$2 = '[object Function]',
-    genTag$1 = '[object GeneratorFunction]',
-    proxyTag = '[object Proxy]';
+var asyncTag = "[object AsyncFunction]",
+  funcTag$2 = "[object Function]",
+  genTag$1 = "[object GeneratorFunction]",
+  proxyTag = "[object Proxy]";
 
 /**
  * Checks if `value` is classified as a `Function` object.
@@ -901,15 +930,15 @@ function isFunction(value) {
 var isFunction_1 = isFunction;
 
 /** Used to detect overreaching core-js shims. */
-var coreJsData = _root['__core-js_shared__'];
+var coreJsData = _root["__core-js_shared__"];
 
 var _coreJsData = coreJsData;
 
 /** Used to detect methods masquerading as native. */
-var maskSrcKey = (function() {
-  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
-  return uid ? ('Symbol(src)_1.' + uid) : '';
-}());
+var maskSrcKey = (function () {
+  var uid = /[^.]+$/.exec((_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO) || "");
+  return uid ? "Symbol(src)_1." + uid : "";
+})();
 
 /**
  * Checks if `func` has its source masked.
@@ -919,7 +948,7 @@ var maskSrcKey = (function() {
  * @returns {boolean} Returns `true` if `func` is masked, else `false`.
  */
 function isMasked(func) {
-  return !!maskSrcKey && (maskSrcKey in func);
+  return !!maskSrcKey && maskSrcKey in func;
 }
 
 var _isMasked = isMasked;
@@ -943,10 +972,10 @@ function toSource(func) {
       return funcToString$2.call(func);
     } catch (e) {}
     try {
-      return (func + '');
+      return func + "";
     } catch (e) {}
   }
-  return '';
+  return "";
 }
 
 var _toSource = toSource;
@@ -962,7 +991,7 @@ var reIsHostCtor = /^\[object .+?Constructor\]$/;
 
 /** Used for built-in method references. */
 var funcProto$1 = Function.prototype,
-    objectProto$e = Object.prototype;
+  objectProto$e = Object.prototype;
 
 /** Used to resolve the decompiled source of functions. */
 var funcToString$1 = funcProto$1.toString;
@@ -971,9 +1000,13 @@ var funcToString$1 = funcProto$1.toString;
 var hasOwnProperty$c = objectProto$e.hasOwnProperty;
 
 /** Used to detect if a method is native. */
-var reIsNative = RegExp('^' +
-  funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, '\\$&')
-  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
+var reIsNative = RegExp(
+  "^" +
+    funcToString$1
+      .call(hasOwnProperty$c)
+      .replace(reRegExpChar, "\\$&")
+      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
+    "$"
 );
 
 /**
@@ -1024,12 +1057,12 @@ function getNative(object, key) {
 var _getNative = getNative;
 
 /* Built-in method references that are verified to be native. */
-var Map = _getNative(_root, 'Map');
+var Map = _getNative(_root, "Map");
 
 var _Map = Map;
 
 /* Built-in method references that are verified to be native. */
-var nativeCreate = _getNative(Object, 'create');
+var nativeCreate = _getNative(Object, "create");
 
 var _nativeCreate = nativeCreate;
 
@@ -1066,7 +1099,7 @@ function hashDelete(key) {
 var _hashDelete = hashDelete;
 
 /** Used to stand-in for `undefined` hash values. */
-var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
+var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
 
 /** Used for built-in method references. */
 var objectProto$d = Object.prototype;
@@ -1111,13 +1144,13 @@ var hasOwnProperty$a = objectProto$c.hasOwnProperty;
  */
 function hashHas(key) {
   var data = this.__data__;
-  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$a.call(data, key);
+  return _nativeCreate ? data[key] !== undefined : hasOwnProperty$a.call(data, key);
 }
 
 var _hashHas = hashHas;
 
 /** Used to stand-in for `undefined` hash values. */
-var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
+var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
 
 /**
  * Sets the hash `key` to `value`.
@@ -1132,7 +1165,7 @@ var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
 function hashSet(key, value) {
   var data = this.__data__;
   this.size += this.has(key) ? 0 : 1;
-  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
+  data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
   return this;
 }
 
@@ -1147,7 +1180,7 @@ var _hashSet = hashSet;
  */
 function Hash(entries) {
   var index = -1,
-      length = entries == null ? 0 : entries.length;
+    length = entries == null ? 0 : entries.length;
 
   this.clear();
   while (++index < length) {
@@ -1158,7 +1191,7 @@ function Hash(entries) {
 
 // Add methods to `Hash`.
 Hash.prototype.clear = _hashClear;
-Hash.prototype['delete'] = _hashDelete;
+Hash.prototype["delete"] = _hashDelete;
 Hash.prototype.get = _hashGet;
 Hash.prototype.has = _hashHas;
 Hash.prototype.set = _hashSet;
@@ -1175,9 +1208,9 @@ var _Hash = Hash;
 function mapCacheClear() {
   this.size = 0;
   this.__data__ = {
-    'hash': new _Hash,
-    'map': new (_Map || _ListCache),
-    'string': new _Hash
+    hash: new _Hash(),
+    map: new (_Map || _ListCache)(),
+    string: new _Hash(),
   };
 }
 
@@ -1192,9 +1225,9 @@ var _mapCacheClear = mapCacheClear;
  */
 function isKeyable(value) {
   var type = typeof value;
-  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
-    ? (value !== '__proto__')
-    : (value === null);
+  return type == "string" || type == "number" || type == "symbol" || type == "boolean"
+    ? value !== "__proto__"
+    : value === null;
 }
 
 var _isKeyable = isKeyable;
@@ -1209,9 +1242,7 @@ var _isKeyable = isKeyable;
  */
 function getMapData(map, key) {
   var data = map.__data__;
-  return _isKeyable(key)
-    ? data[typeof key == 'string' ? 'string' : 'hash']
-    : data.map;
+  return _isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
 }
 
 var _getMapData = getMapData;
@@ -1226,7 +1257,7 @@ var _getMapData = getMapData;
  * @returns {boolean} Returns `true` if the entry was removed, else `false`.
  */
 function mapCacheDelete(key) {
-  var result = _getMapData(this, key)['delete'](key);
+  var result = _getMapData(this, key)["delete"](key);
   this.size -= result ? 1 : 0;
   return result;
 }
@@ -1275,7 +1306,7 @@ var _mapCacheHas = mapCacheHas;
  */
 function mapCacheSet(key, value) {
   var data = _getMapData(this, key),
-      size = data.size;
+    size = data.size;
 
   data.set(key, value);
   this.size += data.size == size ? 0 : 1;
@@ -1293,7 +1324,7 @@ var _mapCacheSet = mapCacheSet;
  */
 function MapCache(entries) {
   var index = -1,
-      length = entries == null ? 0 : entries.length;
+    length = entries == null ? 0 : entries.length;
 
   this.clear();
   while (++index < length) {
@@ -1304,7 +1335,7 @@ function MapCache(entries) {
 
 // Add methods to `MapCache`.
 MapCache.prototype.clear = _mapCacheClear;
-MapCache.prototype['delete'] = _mapCacheDelete;
+MapCache.prototype["delete"] = _mapCacheDelete;
 MapCache.prototype.get = _mapCacheGet;
 MapCache.prototype.has = _mapCacheHas;
 MapCache.prototype.set = _mapCacheSet;
@@ -1328,7 +1359,7 @@ function stackSet(key, value) {
   var data = this.__data__;
   if (data instanceof _ListCache) {
     var pairs = data.__data__;
-    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
+    if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
       pairs.push([key, value]);
       this.size = ++data.size;
       return this;
@@ -1350,13 +1381,13 @@ var _stackSet = stackSet;
  * @param {Array} [entries] The key-value pairs to cache.
  */
 function Stack(entries) {
-  var data = this.__data__ = new _ListCache(entries);
+  var data = (this.__data__ = new _ListCache(entries));
   this.size = data.size;
 }
 
 // Add methods to `Stack`.
 Stack.prototype.clear = _stackClear;
-Stack.prototype['delete'] = _stackDelete;
+Stack.prototype["delete"] = _stackDelete;
 Stack.prototype.get = _stackGet;
 Stack.prototype.has = _stackHas;
 Stack.prototype.set = _stackSet;
@@ -1364,7 +1395,7 @@ Stack.prototype.set = _stackSet;
 var _Stack = Stack;
 
 /** Used to stand-in for `undefined` hash values. */
-var HASH_UNDEFINED = '__lodash_hash_undefined__';
+var HASH_UNDEFINED = "__lodash_hash_undefined__";
 
 /**
  * Adds `value` to the array cache.
@@ -1408,9 +1439,9 @@ var _setCacheHas = setCacheHas;
  */
 function SetCache(values) {
   var index = -1,
-      length = values == null ? 0 : values.length;
+    length = values == null ? 0 : values.length;
 
-  this.__data__ = new _MapCache;
+  this.__data__ = new _MapCache();
   while (++index < length) {
     this.add(values[index]);
   }
@@ -1434,7 +1465,7 @@ var _SetCache = SetCache;
  */
 function arraySome(array, predicate) {
   var index = -1,
-      length = array == null ? 0 : array.length;
+    length = array == null ? 0 : array.length;
 
   while (++index < length) {
     if (predicate(array[index], index, array)) {
@@ -1462,7 +1493,7 @@ var _cacheHas = cacheHas;
 
 /** Used to compose bitmasks for value comparisons. */
 var COMPARE_PARTIAL_FLAG$5 = 1,
-    COMPARE_UNORDERED_FLAG$3 = 2;
+  COMPARE_UNORDERED_FLAG$3 = 2;
 
 /**
  * A specialized version of `baseIsEqualDeep` for arrays with support for
@@ -1479,8 +1510,8 @@ var COMPARE_PARTIAL_FLAG$5 = 1,
  */
 function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
   var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
-      arrLength = array.length,
-      othLength = other.length;
+    arrLength = array.length,
+    othLength = other.length;
 
   if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
     return false;
@@ -1492,8 +1523,8 @@ function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
     return arrStacked == other && othStacked == array;
   }
   var index = -1,
-      result = true,
-      seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new _SetCache : undefined;
+    result = true,
+    seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new _SetCache() : undefined;
 
   stack.set(array, other);
   stack.set(other, array);
@@ -1501,7 +1532,7 @@ function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
   // Ignore non-index properties.
   while (++index < arrLength) {
     var arrValue = array[index],
-        othValue = other[index];
+      othValue = other[index];
 
     if (customizer) {
       var compared = isPartial
@@ -1517,25 +1548,28 @@ function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
     }
     // Recursively compare arrays (susceptible to call stack limits).
     if (seen) {
-      if (!_arraySome(other, function(othValue, othIndex) {
-            if (!_cacheHas(seen, othIndex) &&
-                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
-              return seen.push(othIndex);
-            }
-          })) {
+      if (
+        !_arraySome(other, function (othValue, othIndex) {
+          if (
+            !_cacheHas(seen, othIndex) &&
+            (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))
+          ) {
+            return seen.push(othIndex);
+          }
+        })
+      ) {
         result = false;
         break;
       }
-    } else if (!(
-          arrValue === othValue ||
-            equalFunc(arrValue, othValue, bitmask, customizer, stack)
-        )) {
+    } else if (
+      !(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))
+    ) {
       result = false;
       break;
     }
   }
-  stack['delete'](array);
-  stack['delete'](other);
+  stack["delete"](array);
+  stack["delete"](other);
   return result;
 }
 
@@ -1555,9 +1589,9 @@ var _Uint8Array = Uint8Array;
  */
 function mapToArray(map) {
   var index = -1,
-      result = Array(map.size);
+    result = Array(map.size);
 
-  map.forEach(function(value, key) {
+  map.forEach(function (value, key) {
     result[++index] = [key, value];
   });
   return result;
@@ -1574,9 +1608,9 @@ var _mapToArray = mapToArray;
  */
 function setToArray(set) {
   var index = -1,
-      result = Array(set.size);
+    result = Array(set.size);
 
-  set.forEach(function(value) {
+  set.forEach(function (value) {
     result[++index] = value;
   });
   return result;
@@ -1586,25 +1620,25 @@ var _setToArray = setToArray;
 
 /** Used to compose bitmasks for value comparisons. */
 var COMPARE_PARTIAL_FLAG$4 = 1,
-    COMPARE_UNORDERED_FLAG$2 = 2;
+  COMPARE_UNORDERED_FLAG$2 = 2;
 
 /** `Object#toString` result references. */
-var boolTag$3 = '[object Boolean]',
-    dateTag$3 = '[object Date]',
-    errorTag$2 = '[object Error]',
-    mapTag$5 = '[object Map]',
-    numberTag$3 = '[object Number]',
-    regexpTag$3 = '[object RegExp]',
-    setTag$5 = '[object Set]',
-    stringTag$3 = '[object String]',
-    symbolTag$3 = '[object Symbol]';
-
-var arrayBufferTag$3 = '[object ArrayBuffer]',
-    dataViewTag$4 = '[object DataView]';
+var boolTag$3 = "[object Boolean]",
+  dateTag$3 = "[object Date]",
+  errorTag$2 = "[object Error]",
+  mapTag$5 = "[object Map]",
+  numberTag$3 = "[object Number]",
+  regexpTag$3 = "[object RegExp]",
+  setTag$5 = "[object Set]",
+  stringTag$3 = "[object String]",
+  symbolTag$3 = "[object Symbol]";
+
+var arrayBufferTag$3 = "[object ArrayBuffer]",
+  dataViewTag$4 = "[object DataView]";
 
 /** Used to convert symbols to primitives and strings. */
 var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
-    symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;
+  symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;
 
 /**
  * A specialized version of `baseIsEqualDeep` for comparing objects of
@@ -1626,16 +1660,17 @@ var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
 function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
   switch (tag) {
     case dataViewTag$4:
-      if ((object.byteLength != other.byteLength) ||
-          (object.byteOffset != other.byteOffset)) {
+      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
         return false;
       }
       object = object.buffer;
       other = other.buffer;
 
     case arrayBufferTag$3:
-      if ((object.byteLength != other.byteLength) ||
-          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
+      if (
+        object.byteLength != other.byteLength ||
+        !equalFunc(new _Uint8Array(object), new _Uint8Array(other))
+      ) {
         return false;
       }
       return true;
@@ -1655,7 +1690,7 @@ function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
       // Coerce regexes to strings and treat strings, primitives and objects,
       // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
       // for more details.
-      return object == (other + '');
+      return object == other + "";
 
     case mapTag$5:
       var convert = _mapToArray;
@@ -1676,8 +1711,15 @@ function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
 
       // Recursively compare objects (susceptible to call stack limits).
       stack.set(object, other);
-      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
-      stack['delete'](object);
+      var result = _equalArrays(
+        convert(object),
+        convert(other),
+        bitmask,
+        customizer,
+        equalFunc,
+        stack
+      );
+      stack["delete"](object);
       return result;
 
     case symbolTag$3:
@@ -1700,8 +1742,8 @@ var _equalByTag = equalByTag;
  */
 function arrayPush(array, values) {
   var index = -1,
-      length = values.length,
-      offset = array.length;
+    length = values.length,
+    offset = array.length;
 
   while (++index < length) {
     array[offset + index] = values[index];
@@ -1740,9 +1782,9 @@ var _baseGetAllKeys = baseGetAllKeys;
  */
 function arrayFilter(array, predicate) {
   var index = -1,
-      length = array == null ? 0 : array.length,
-      resIndex = 0,
-      result = [];
+    length = array == null ? 0 : array.length,
+    resIndex = 0,
+    result = [];
 
   while (++index < length) {
     var value = array[index];
@@ -1795,15 +1837,17 @@ var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  * @param {Object} object The object to query.
  * @returns {Array} Returns the array of symbols.
  */
-var getSymbols = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
-  if (object == null) {
-    return [];
-  }
-  object = Object(object);
-  return _arrayFilter(nativeGetSymbols$1(object), function(symbol) {
-    return propertyIsEnumerable$1.call(object, symbol);
-  });
-};
+var getSymbols = !nativeGetSymbols$1
+  ? stubArray_1
+  : function (object) {
+      if (object == null) {
+        return [];
+      }
+      object = Object(object);
+      return _arrayFilter(nativeGetSymbols$1(object), function (symbol) {
+        return propertyIsEnumerable$1.call(object, symbol);
+      });
+    };
 
 var _getSymbols = getSymbols;
 
@@ -1818,7 +1862,7 @@ var _getSymbols = getSymbols;
  */
 function baseTimes(n, iteratee) {
   var index = -1,
-      result = Array(n);
+    result = Array(n);
 
   while (++index < n) {
     result[index] = iteratee(index);
@@ -1853,13 +1897,13 @@ var _baseTimes = baseTimes;
  * // => false
  */
 function isObjectLike(value) {
-  return value != null && typeof value == 'object';
+  return value != null && typeof value == "object";
 }
 
 var isObjectLike_1 = isObjectLike;
 
 /** `Object#toString` result references. */
-var argsTag$3 = '[object Arguments]';
+var argsTag$3 = "[object Arguments]";
 
 /**
  * The base implementation of `_.isArguments`.
@@ -1901,10 +1945,19 @@ var propertyIsEnumerable = objectProto$a.propertyIsEnumerable;
  * _.isArguments([1, 2, 3]);
  * // => false
  */
-var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
-  return isObjectLike_1(value) && hasOwnProperty$9.call(value, 'callee') &&
-    !propertyIsEnumerable.call(value, 'callee');
-};
+var isArguments = _baseIsArguments(
+  (function () {
+    return arguments;
+  })()
+)
+  ? _baseIsArguments
+  : function (value) {
+      return (
+        isObjectLike_1(value) &&
+        hasOwnProperty$9.call(value, "callee") &&
+        !propertyIsEnumerable.call(value, "callee")
+      );
+    };
 
 var isArguments_1 = isArguments;
 
@@ -1928,41 +1981,41 @@ function stubFalse() {
 var stubFalse_1 = stubFalse;
 
 var isBuffer_1 = createCommonjsModule(function (module, exports) {
-/** Detect free variable `exports`. */
-var freeExports = exports && !exports.nodeType && exports;
-
-/** Detect free variable `module`. */
-var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
-
-/** Detect the popular CommonJS extension `module.exports`. */
-var moduleExports = freeModule && freeModule.exports === freeExports;
-
-/** Built-in value references. */
-var Buffer = moduleExports ? _root.Buffer : undefined;
-
-/* Built-in method references for those with the same name as other `lodash` methods. */
-var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
-
-/**
- * Checks if `value` is a buffer.
- *
- * @static
- * @memberOf _
- * @since 4.3.0
- * @category Lang
- * @param {*} value The value to check.
- * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
- * @example
- *
- * _.isBuffer(new Buffer(2));
- * // => true
- *
- * _.isBuffer(new Uint8Array(2));
- * // => false
- */
-var isBuffer = nativeIsBuffer || stubFalse_1;
-
-module.exports = isBuffer;
+  /** Detect free variable `exports`. */
+  var freeExports = exports && !exports.nodeType && exports;
+
+  /** Detect free variable `module`. */
+  var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
+
+  /** Detect the popular CommonJS extension `module.exports`. */
+  var moduleExports = freeModule && freeModule.exports === freeExports;
+
+  /** Built-in value references. */
+  var Buffer = moduleExports ? _root.Buffer : undefined;
+
+  /* Built-in method references for those with the same name as other `lodash` methods. */
+  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
+
+  /**
+   * Checks if `value` is a buffer.
+   *
+   * @static
+   * @memberOf _
+   * @since 4.3.0
+   * @category Lang
+   * @param {*} value The value to check.
+   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
+   * @example
+   *
+   * _.isBuffer(new Buffer(2));
+   * // => true
+   *
+   * _.isBuffer(new Uint8Array(2));
+   * // => false
+   */
+  var isBuffer = nativeIsBuffer || stubFalse_1;
+
+  module.exports = isBuffer;
 });
 
 /** Used as references for various `Number` constants. */
@@ -1983,10 +2036,13 @@ function isIndex(value, length) {
   var type = typeof value;
   length = length == null ? MAX_SAFE_INTEGER$1 : length;
 
-  return !!length &&
-    (type == 'number' ||
-      (type != 'symbol' && reIsUint.test(value))) &&
-        (value > -1 && value % 1 == 0 && value < length);
+  return (
+    !!length &&
+    (type == "number" || (type != "symbol" && reIsUint.test(value))) &&
+    value > -1 &&
+    value % 1 == 0 &&
+    value < length
+  );
 }
 
 var _isIndex = isIndex;
@@ -2021,54 +2077,66 @@ var MAX_SAFE_INTEGER = 9007199254740991;
  * // => false
  */
 function isLength(value) {
-  return typeof value == 'number' &&
-    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
+  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
 }
 
 var isLength_1 = isLength;
 
 /** `Object#toString` result references. */
-var argsTag$2 = '[object Arguments]',
-    arrayTag$2 = '[object Array]',
-    boolTag$2 = '[object Boolean]',
-    dateTag$2 = '[object Date]',
-    errorTag$1 = '[object Error]',
-    funcTag$1 = '[object Function]',
-    mapTag$4 = '[object Map]',
-    numberTag$2 = '[object Number]',
-    objectTag$4 = '[object Object]',
-    regexpTag$2 = '[object RegExp]',
-    setTag$4 = '[object Set]',
-    stringTag$2 = '[object String]',
-    weakMapTag$2 = '[object WeakMap]';
-
-var arrayBufferTag$2 = '[object ArrayBuffer]',
-    dataViewTag$3 = '[object DataView]',
-    float32Tag$2 = '[object Float32Array]',
-    float64Tag$2 = '[object Float64Array]',
-    int8Tag$2 = '[object Int8Array]',
-    int16Tag$2 = '[object Int16Array]',
-    int32Tag$2 = '[object Int32Array]',
-    uint8Tag$2 = '[object Uint8Array]',
-    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
-    uint16Tag$2 = '[object Uint16Array]',
-    uint32Tag$2 = '[object Uint32Array]';
+var argsTag$2 = "[object Arguments]",
+  arrayTag$2 = "[object Array]",
+  boolTag$2 = "[object Boolean]",
+  dateTag$2 = "[object Date]",
+  errorTag$1 = "[object Error]",
+  funcTag$1 = "[object Function]",
+  mapTag$4 = "[object Map]",
+  numberTag$2 = "[object Number]",
+  objectTag$4 = "[object Object]",
+  regexpTag$2 = "[object RegExp]",
+  setTag$4 = "[object Set]",
+  stringTag$2 = "[object String]",
+  weakMapTag$2 = "[object WeakMap]";
+
+var arrayBufferTag$2 = "[object ArrayBuffer]",
+  dataViewTag$3 = "[object DataView]",
+  float32Tag$2 = "[object Float32Array]",
+  float64Tag$2 = "[object Float64Array]",
+  int8Tag$2 = "[object Int8Array]",
+  int16Tag$2 = "[object Int16Array]",
+  int32Tag$2 = "[object Int32Array]",
+  uint8Tag$2 = "[object Uint8Array]",
+  uint8ClampedTag$2 = "[object Uint8ClampedArray]",
+  uint16Tag$2 = "[object Uint16Array]",
+  uint32Tag$2 = "[object Uint32Array]";
 
 /** Used to identify `toStringTag` values of typed arrays. */
 var typedArrayTags = {};
-typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
-typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
-typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
-typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
-typedArrayTags[uint32Tag$2] = true;
-typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
-typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
-typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =
-typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
-typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] =
-typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$2] =
-typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] =
-typedArrayTags[weakMapTag$2] = false;
+typedArrayTags[float32Tag$2] =
+  typedArrayTags[float64Tag$2] =
+  typedArrayTags[int8Tag$2] =
+  typedArrayTags[int16Tag$2] =
+  typedArrayTags[int32Tag$2] =
+  typedArrayTags[uint8Tag$2] =
+  typedArrayTags[uint8ClampedTag$2] =
+  typedArrayTags[uint16Tag$2] =
+  typedArrayTags[uint32Tag$2] =
+    true;
+typedArrayTags[argsTag$2] =
+  typedArrayTags[arrayTag$2] =
+  typedArrayTags[arrayBufferTag$2] =
+  typedArrayTags[boolTag$2] =
+  typedArrayTags[dataViewTag$3] =
+  typedArrayTags[dateTag$2] =
+  typedArrayTags[errorTag$1] =
+  typedArrayTags[funcTag$1] =
+  typedArrayTags[mapTag$4] =
+  typedArrayTags[numberTag$2] =
+  typedArrayTags[objectTag$4] =
+  typedArrayTags[regexpTag$2] =
+  typedArrayTags[setTag$4] =
+  typedArrayTags[stringTag$2] =
+  typedArrayTags[weakMapTag$2] =
+    false;
 
 /**
  * The base implementation of `_.isTypedArray` without Node.js optimizations.
@@ -2078,8 +2146,7 @@ typedArrayTags[weakMapTag$2] = false;
  * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
  */
 function baseIsTypedArray(value) {
-  return isObjectLike_1(value) &&
-    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
+  return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
 }
 
 var _baseIsTypedArray = baseIsTypedArray;
@@ -2092,7 +2159,7 @@ var _baseIsTypedArray = baseIsTypedArray;
  * @returns {Function} Returns the new capped function.
  */
 function baseUnary(func) {
-  return function(value) {
+  return function (value) {
     return func(value);
   };
 }
@@ -2100,34 +2167,34 @@ function baseUnary(func) {
 var _baseUnary = baseUnary;
 
 var _nodeUtil = createCommonjsModule(function (module, exports) {
-/** Detect free variable `exports`. */
-var freeExports = exports && !exports.nodeType && exports;
+  /** Detect free variable `exports`. */
+  var freeExports = exports && !exports.nodeType && exports;
 
-/** Detect free variable `module`. */
-var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
+  /** Detect free variable `module`. */
+  var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
 
-/** Detect the popular CommonJS extension `module.exports`. */
-var moduleExports = freeModule && freeModule.exports === freeExports;
+  /** Detect the popular CommonJS extension `module.exports`. */
+  var moduleExports = freeModule && freeModule.exports === freeExports;
 
-/** Detect free variable `process` from Node.js. */
-var freeProcess = moduleExports && _freeGlobal.process;
+  /** Detect free variable `process` from Node.js. */
+  var freeProcess = moduleExports && _freeGlobal.process;
 
-/** Used to access faster Node.js helpers. */
-var nodeUtil = (function() {
-  try {
-    // Use `util.types` for Node.js 10+.
-    var types = freeModule && freeModule.require && freeModule.require('util').types;
+  /** Used to access faster Node.js helpers. */
+  var nodeUtil = (function () {
+    try {
+      // Use `util.types` for Node.js 10+.
+      var types = freeModule && freeModule.require && freeModule.require("util").types;
 
-    if (types) {
-      return types;
-    }
+      if (types) {
+        return types;
+      }
 
-    // Legacy `process.binding('util')` for Node.js < 10.
-    return freeProcess && freeProcess.binding && freeProcess.binding('util');
-  } catch (e) {}
-}());
+      // Legacy `process.binding('util')` for Node.js < 10.
+      return freeProcess && freeProcess.binding && freeProcess.binding("util");
+    } catch (e) {}
+  })();
 
-module.exports = nodeUtil;
+  module.exports = nodeUtil;
 });
 
 /* Node.js helper references. */
@@ -2170,25 +2237,28 @@ var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
  */
 function arrayLikeKeys(value, inherited) {
   var isArr = isArray_1(value),
-      isArg = !isArr && isArguments_1(value),
-      isBuff = !isArr && !isArg && isBuffer_1(value),
-      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
-      skipIndexes = isArr || isArg || isBuff || isType,
-      result = skipIndexes ? _baseTimes(value.length, String) : [],
-      length = result.length;
+    isArg = !isArr && isArguments_1(value),
+    isBuff = !isArr && !isArg && isBuffer_1(value),
+    isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
+    skipIndexes = isArr || isArg || isBuff || isType,
+    result = skipIndexes ? _baseTimes(value.length, String) : [],
+    length = result.length;
 
   for (var key in value) {
-    if ((inherited || hasOwnProperty$8.call(value, key)) &&
-        !(skipIndexes && (
-           // Safari 9 has enumerable `arguments.length` in strict mode.
-           key == 'length' ||
-           // Node.js 0.10 has enumerable non-index properties on buffers.
-           (isBuff && (key == 'offset' || key == 'parent')) ||
-           // PhantomJS 2 has enumerable non-index properties on typed arrays.
-           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
-           // Skip index properties.
-           _isIndex(key, length)
-        ))) {
+    if (
+      (inherited || hasOwnProperty$8.call(value, key)) &&
+      !(
+        skipIndexes &&
+        // Safari 9 has enumerable `arguments.length` in strict mode.
+        (key == "length" ||
+          // Node.js 0.10 has enumerable non-index properties on buffers.
+          (isBuff && (key == "offset" || key == "parent")) ||
+          // PhantomJS 2 has enumerable non-index properties on typed arrays.
+          (isType && (key == "buffer" || key == "byteLength" || key == "byteOffset")) ||
+          // Skip index properties.
+          _isIndex(key, length))
+      )
+    ) {
       result.push(key);
     }
   }
@@ -2209,7 +2279,7 @@ var objectProto$8 = Object.prototype;
  */
 function isPrototype(value) {
   var Ctor = value && value.constructor,
-      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$8;
+    proto = (typeof Ctor == "function" && Ctor.prototype) || objectProto$8;
 
   return value === proto;
 }
@@ -2225,7 +2295,7 @@ var _isPrototype = isPrototype;
  * @returns {Function} Returns the new function.
  */
 function overArg(func, transform) {
-  return function(arg) {
+  return function (arg) {
     return func(transform(arg));
   };
 }
@@ -2256,7 +2326,7 @@ function baseKeys(object) {
   }
   var result = [];
   for (var key in Object(object)) {
-    if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
+    if (hasOwnProperty$7.call(object, key) && key != "constructor") {
       result.push(key);
     }
   }
@@ -2367,10 +2437,10 @@ var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
  */
 function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
   var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
-      objProps = _getAllKeys(object),
-      objLength = objProps.length,
-      othProps = _getAllKeys(other),
-      othLength = othProps.length;
+    objProps = _getAllKeys(object),
+    objLength = objProps.length,
+    othProps = _getAllKeys(other),
+    othLength = othProps.length;
 
   if (objLength != othLength && !isPartial) {
     return false;
@@ -2396,7 +2466,7 @@ function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
   while (++index < objLength) {
     key = objProps[index];
     var objValue = object[key],
-        othValue = other[key];
+      othValue = other[key];
 
     if (customizer) {
       var compared = isPartial
@@ -2404,69 +2474,77 @@ function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
         : customizer(objValue, othValue, key, object, other, stack);
     }
     // Recursively compare objects (susceptible to call stack limits).
-    if (!(compared === undefined
-          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
-          : compared
-        )) {
+    if (
+      !(compared === undefined
+        ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)
+        : compared)
+    ) {
       result = false;
       break;
     }
-    skipCtor || (skipCtor = key == 'constructor');
+    skipCtor || (skipCtor = key == "constructor");
   }
   if (result && !skipCtor) {
     var objCtor = object.constructor,
-        othCtor = other.constructor;
+      othCtor = other.constructor;
 
     // Non `Object` object instances with different constructors are not equal.
-    if (objCtor != othCtor &&
-        ('constructor' in object && 'constructor' in other) &&
-        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
-          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
+    if (
+      objCtor != othCtor &&
+      "constructor" in object &&
+      "constructor" in other &&
+      !(
+        typeof objCtor == "function" &&
+        objCtor instanceof objCtor &&
+        typeof othCtor == "function" &&
+        othCtor instanceof othCtor
+      )
+    ) {
       result = false;
     }
   }
-  stack['delete'](object);
-  stack['delete'](other);
+  stack["delete"](object);
+  stack["delete"](other);
   return result;
 }
 
 var _equalObjects = equalObjects;
 
 /* Built-in method references that are verified to be native. */
-var DataView = _getNative(_root, 'DataView');
+var DataView = _getNative(_root, "DataView");
 
 var _DataView = DataView;
 
 /* Built-in method references that are verified to be native. */
-var Promise$1 = _getNative(_root, 'Promise');
+var Promise$1 = _getNative(_root, "Promise");
 
 var _Promise = Promise$1;
 
 /* Built-in method references that are verified to be native. */
-var Set$1 = _getNative(_root, 'Set');
+var Set$1 = _getNative(_root, "Set");
 
 var _Set = Set$1;
 
 /* Built-in method references that are verified to be native. */
-var WeakMap$1 = _getNative(_root, 'WeakMap');
+var WeakMap$1 = _getNative(_root, "WeakMap");
 
 var _WeakMap = WeakMap$1;
 
 /** `Object#toString` result references. */
-var mapTag$3 = '[object Map]',
-    objectTag$3 = '[object Object]',
-    promiseTag = '[object Promise]',
-    setTag$3 = '[object Set]',
-    weakMapTag$1 = '[object WeakMap]';
+var mapTag$3 = "[object Map]",
+  objectTag$3 = "[object Object]",
+  promiseTag = "[object Promise]",
+  setTag$3 = "[object Set]",
+  weakMapTag$1 = "[object WeakMap]";
 
-var dataViewTag$2 = '[object DataView]';
+var dataViewTag$2 = "[object DataView]";
 
 /** Used to detect maps, sets, and weakmaps. */
 var dataViewCtorString = _toSource(_DataView),
-    mapCtorString = _toSource(_Map),
-    promiseCtorString = _toSource(_Promise),
-    setCtorString = _toSource(_Set),
-    weakMapCtorString = _toSource(_WeakMap);
+  mapCtorString = _toSource(_Map),
+  promiseCtorString = _toSource(_Promise),
+  setCtorString = _toSource(_Set),
+  weakMapCtorString = _toSource(_WeakMap);
 
 /**
  * Gets the `toStringTag` of `value`.
@@ -2478,23 +2556,30 @@ var dataViewCtorString = _toSource(_DataView),
 var getTag = _baseGetTag;
 
 // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
-if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
-    (_Map && getTag(new _Map) != mapTag$3) ||
-    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
-    (_Set && getTag(new _Set) != setTag$3) ||
-    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
-  getTag = function(value) {
+if (
+  (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
+  (_Map && getTag(new _Map()) != mapTag$3) ||
+  (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
+  (_Set && getTag(new _Set()) != setTag$3) ||
+  (_WeakMap && getTag(new _WeakMap()) != weakMapTag$1)
+) {
+  getTag = function (value) {
     var result = _baseGetTag(value),
-        Ctor = result == objectTag$3 ? value.constructor : undefined,
-        ctorString = Ctor ? _toSource(Ctor) : '';
+      Ctor = result == objectTag$3 ? value.constructor : undefined,
+      ctorString = Ctor ? _toSource(Ctor) : "";
 
     if (ctorString) {
       switch (ctorString) {
-        case dataViewCtorString: return dataViewTag$2;
-        case mapCtorString: return mapTag$3;
-        case promiseCtorString: return promiseTag;
-        case setCtorString: return setTag$3;
-        case weakMapCtorString: return weakMapTag$1;
+        case dataViewCtorString:
+          return dataViewTag$2;
+        case mapCtorString:
+          return mapTag$3;
+        case promiseCtorString:
+          return promiseTag;
+        case setCtorString:
+          return setTag$3;
+        case weakMapCtorString:
+          return weakMapTag$1;
       }
     }
     return result;
@@ -2507,9 +2592,9 @@ var _getTag = getTag;
 var COMPARE_PARTIAL_FLAG$2 = 1;
 
 /** `Object#toString` result references. */
-var argsTag$1 = '[object Arguments]',
-    arrayTag$1 = '[object Array]',
-    objectTag$2 = '[object Object]';
+var argsTag$1 = "[object Arguments]",
+  arrayTag$1 = "[object Array]",
+  objectTag$2 = "[object Object]";
 
 /** Used for built-in method references. */
 var objectProto$5 = Object.prototype;
@@ -2533,16 +2618,16 @@ var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
  */
 function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
   var objIsArr = isArray_1(object),
-      othIsArr = isArray_1(other),
-      objTag = objIsArr ? arrayTag$1 : _getTag(object),
-      othTag = othIsArr ? arrayTag$1 : _getTag(other);
+    othIsArr = isArray_1(other),
+    objTag = objIsArr ? arrayTag$1 : _getTag(object),
+    othTag = othIsArr ? arrayTag$1 : _getTag(other);
 
   objTag = objTag == argsTag$1 ? objectTag$2 : objTag;
   othTag = othTag == argsTag$1 ? objectTag$2 : othTag;
 
   var objIsObj = objTag == objectTag$2,
-      othIsObj = othTag == objectTag$2,
-      isSameTag = objTag == othTag;
+    othIsObj = othTag == objectTag$2,
+    isSameTag = objTag == othTag;
 
   if (isSameTag && isBuffer_1(object)) {
     if (!isBuffer_1(other)) {
@@ -2552,27 +2637,27 @@ function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
     objIsObj = false;
   }
   if (isSameTag && !objIsObj) {
-    stack || (stack = new _Stack);
-    return (objIsArr || isTypedArray_1(object))
+    stack || (stack = new _Stack());
+    return objIsArr || isTypedArray_1(object)
       ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
       : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
   }
   if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
-    var objIsWrapped = objIsObj && hasOwnProperty$5.call(object, '__wrapped__'),
-        othIsWrapped = othIsObj && hasOwnProperty$5.call(other, '__wrapped__');
+    var objIsWrapped = objIsObj && hasOwnProperty$5.call(object, "__wrapped__"),
+      othIsWrapped = othIsObj && hasOwnProperty$5.call(other, "__wrapped__");
 
     if (objIsWrapped || othIsWrapped) {
       var objUnwrapped = objIsWrapped ? object.value() : object,
-          othUnwrapped = othIsWrapped ? other.value() : other;
+        othUnwrapped = othIsWrapped ? other.value() : other;
 
-      stack || (stack = new _Stack);
+      stack || (stack = new _Stack());
       return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
     }
   }
   if (!isSameTag) {
     return false;
   }
-  stack || (stack = new _Stack);
+  stack || (stack = new _Stack());
   return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
 }
 
@@ -2606,7 +2691,7 @@ var _baseIsEqual = baseIsEqual;
 
 /** Used to compose bitmasks for value comparisons. */
 var COMPARE_PARTIAL_FLAG$1 = 1,
-    COMPARE_UNORDERED_FLAG$1 = 2;
+  COMPARE_UNORDERED_FLAG$1 = 2;
 
 /**
  * The base implementation of `_.isMatch` without support for iteratee shorthands.
@@ -2620,8 +2705,8 @@ var COMPARE_PARTIAL_FLAG$1 = 1,
  */
 function baseIsMatch(object, source, matchData, customizer) {
   var index = matchData.length,
-      length = index,
-      noCustomizer = !customizer;
+    length = index,
+    noCustomizer = !customizer;
 
   if (object == null) {
     return !length;
@@ -2629,32 +2714,36 @@ function baseIsMatch(object, source, matchData, customizer) {
   object = Object(object);
   while (index--) {
     var data = matchData[index];
-    if ((noCustomizer && data[2])
-          ? data[1] !== object[data[0]]
-          : !(data[0] in object)
-        ) {
+    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
       return false;
     }
   }
   while (++index < length) {
     data = matchData[index];
     var key = data[0],
-        objValue = object[key],
-        srcValue = data[1];
+      objValue = object[key],
+      srcValue = data[1];
 
     if (noCustomizer && data[2]) {
       if (objValue === undefined && !(key in object)) {
         return false;
       }
     } else {
-      var stack = new _Stack;
+      var stack = new _Stack();
       if (customizer) {
         var result = customizer(objValue, srcValue, key, object, source, stack);
       }
-      if (!(result === undefined
-            ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
-            : result
-          )) {
+      if (
+        !(result === undefined
+          ? _baseIsEqual(
+              srcValue,
+              objValue,
+              COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1,
+              customizer,
+              stack
+            )
+          : result)
+      ) {
         return false;
       }
     }
@@ -2687,11 +2776,11 @@ var _isStrictComparable = isStrictComparable;
  */
 function getMatchData(object) {
   var result = keys_1(object),
-      length = result.length;
+    length = result.length;
 
   while (length--) {
     var key = result[length],
-        value = object[key];
+      value = object[key];
 
     result[length] = [key, value, _isStrictComparable(value)];
   }
@@ -2710,12 +2799,11 @@ var _getMatchData = getMatchData;
  * @returns {Function} Returns the new spec function.
  */
 function matchesStrictComparable(key, srcValue) {
-  return function(object) {
+  return function (object) {
     if (object == null) {
       return false;
     }
-    return object[key] === srcValue &&
-      (srcValue !== undefined || (key in Object(object)));
+    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
   };
 }
 
@@ -2733,7 +2821,7 @@ function baseMatches(source) {
   if (matchData.length == 1 && matchData[0][2]) {
     return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
   }
-  return function(object) {
+  return function (object) {
     return object === source || _baseIsMatch(object, source, matchData);
   };
 }
@@ -2741,7 +2829,7 @@ function baseMatches(source) {
 var _baseMatches = baseMatches;
 
 /** `Object#toString` result references. */
-var symbolTag$2 = '[object Symbol]';
+var symbolTag$2 = "[object Symbol]";
 
 /**
  * Checks if `value` is classified as a `Symbol` primitive or object.
@@ -2761,15 +2849,14 @@ var symbolTag$2 = '[object Symbol]';
  * // => false
  */
 function isSymbol(value) {
-  return typeof value == 'symbol' ||
-    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$2);
+  return typeof value == "symbol" || (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$2);
 }
 
 var isSymbol_1 = isSymbol;
 
 /** Used to match property names within property paths. */
 var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
-    reIsPlainProp = /^\w*$/;
+  reIsPlainProp = /^\w*$/;
 
 /**
  * Checks if `value` is a property name and not a property path.
@@ -2784,18 +2871,26 @@ function isKey(value, object) {
     return false;
   }
   var type = typeof value;
-  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
-      value == null || isSymbol_1(value)) {
+  if (
+    type == "number" ||
+    type == "symbol" ||
+    type == "boolean" ||
+    value == null ||
+    isSymbol_1(value)
+  ) {
     return true;
   }
-  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
-    (object != null && value in Object(object));
+  return (
+    reIsPlainProp.test(value) ||
+    !reIsDeepProp.test(value) ||
+    (object != null && value in Object(object))
+  );
 }
 
 var _isKey = isKey;
 
 /** Error message constants. */
-var FUNC_ERROR_TEXT = 'Expected a function';
+var FUNC_ERROR_TEXT = "Expected a function";
 
 /**
  * Creates a function that memoizes the result of `func`. If `resolver` is
@@ -2842,13 +2937,13 @@ var FUNC_ERROR_TEXT = 'Expected a function';
  * _.memoize.Cache = WeakMap;
  */
 function memoize(func, resolver) {
-  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
+  if (typeof func != "function" || (resolver != null && typeof resolver != "function")) {
     throw new TypeError(FUNC_ERROR_TEXT);
   }
-  var memoized = function() {
+  var memoized = function () {
     var args = arguments,
-        key = resolver ? resolver.apply(this, args) : args[0],
-        cache = memoized.cache;
+      key = resolver ? resolver.apply(this, args) : args[0],
+      cache = memoized.cache;
 
     if (cache.has(key)) {
       return cache.get(key);
@@ -2857,7 +2952,7 @@ function memoize(func, resolver) {
     memoized.cache = cache.set(key, result) || cache;
     return result;
   };
-  memoized.cache = new (memoize.Cache || _MapCache);
+  memoized.cache = new (memoize.Cache || _MapCache)();
   return memoized;
 }
 
@@ -2878,7 +2973,7 @@ var MAX_MEMOIZE_SIZE = 500;
  * @returns {Function} Returns the new memoized function.
  */
 function memoizeCapped(func) {
-  var result = memoize_1(func, function(key) {
+  var result = memoize_1(func, function (key) {
     if (cache.size === MAX_MEMOIZE_SIZE) {
       cache.clear();
     }
@@ -2892,7 +2987,8 @@ function memoizeCapped(func) {
 var _memoizeCapped = memoizeCapped;
 
 /** Used to match property names within property paths. */
-var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
+var rePropName =
+  /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
 
 /** Used to match backslashes in property paths. */
 var reEscapeChar = /\\(\\)?/g;
@@ -2904,13 +3000,13 @@ var reEscapeChar = /\\(\\)?/g;
  * @param {string} string The string to convert.
  * @returns {Array} Returns the property path array.
  */
-var stringToPath = _memoizeCapped(function(string) {
+var stringToPath = _memoizeCapped(function (string) {
   var result = [];
   if (string.charCodeAt(0) === 46 /* . */) {
-    result.push('');
+    result.push("");
   }
-  string.replace(rePropName, function(match, number, quote, subString) {
-    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
+  string.replace(rePropName, function (match, number, quote, subString) {
+    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
   });
   return result;
 });
@@ -2922,7 +3018,7 @@ var INFINITY$1 = 1 / 0;
 
 /** Used to convert symbols to primitives and strings. */
 var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
-    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;
+  symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;
 
 /**
  * The base implementation of `_.toString` which doesn't convert nullish
@@ -2934,18 +3030,18 @@ var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
  */
 function baseToString(value) {
   // Exit early for strings to avoid a performance hit in some environments.
-  if (typeof value == 'string') {
+  if (typeof value == "string") {
     return value;
   }
   if (isArray_1(value)) {
     // Recursively convert values (susceptible to call stack limits).
-    return _arrayMap(value, baseToString) + '';
+    return _arrayMap(value, baseToString) + "";
   }
   if (isSymbol_1(value)) {
-    return symbolToString ? symbolToString.call(value) : '';
+    return symbolToString ? symbolToString.call(value) : "";
   }
-  var result = (value + '');
-  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
+  var result = value + "";
+  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
 }
 
 var _baseToString = baseToString;
@@ -2972,7 +3068,7 @@ var _baseToString = baseToString;
  * // => '1,2,3'
  */
 function toString(value) {
-  return value == null ? '' : _baseToString(value);
+  return value == null ? "" : _baseToString(value);
 }
 
 var toString_1 = toString;
@@ -3005,11 +3101,11 @@ var INFINITY = 1 / 0;
  * @returns {string|symbol} Returns the key.
  */
 function toKey(value) {
-  if (typeof value == 'string' || isSymbol_1(value)) {
+  if (typeof value == "string" || isSymbol_1(value)) {
     return value;
   }
-  var result = (value + '');
-  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
+  var result = value + "";
+  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
 }
 
 var _toKey = toKey;
@@ -3026,12 +3122,12 @@ function baseGet(object, path) {
   path = _castPath(path, object);
 
   var index = 0,
-      length = path.length;
+    length = path.length;
 
   while (object != null && index < length) {
     object = object[_toKey(path[index++])];
   }
-  return (index && index == length) ? object : undefined;
+  return index && index == length ? object : undefined;
 }
 
 var _baseGet = baseGet;
@@ -3095,8 +3191,8 @@ function hasPath(object, path, hasFunc) {
   path = _castPath(path, object);
 
   var index = -1,
-      length = path.length,
-      result = false;
+    length = path.length,
+    result = false;
 
   while (++index < length) {
     var key = _toKey(path[index]);
@@ -3109,8 +3205,12 @@ function hasPath(object, path, hasFunc) {
     return result;
   }
   length = object == null ? 0 : object.length;
-  return !!length && isLength_1(length) && _isIndex(key, length) &&
-    (isArray_1(object) || isArguments_1(object));
+  return (
+    !!length &&
+    isLength_1(length) &&
+    _isIndex(key, length) &&
+    (isArray_1(object) || isArguments_1(object))
+  );
 }
 
 var _hasPath = hasPath;
@@ -3149,7 +3249,7 @@ var hasIn_1 = hasIn;
 
 /** Used to compose bitmasks for value comparisons. */
 var COMPARE_PARTIAL_FLAG = 1,
-    COMPARE_UNORDERED_FLAG = 2;
+  COMPARE_UNORDERED_FLAG = 2;
 
 /**
  * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
@@ -3163,9 +3263,9 @@ function baseMatchesProperty(path, srcValue) {
   if (_isKey(path) && _isStrictComparable(srcValue)) {
     return _matchesStrictComparable(_toKey(path), srcValue);
   }
-  return function(object) {
+  return function (object) {
     var objValue = get_1(object, path);
-    return (objValue === undefined && objValue === srcValue)
+    return objValue === undefined && objValue === srcValue
       ? hasIn_1(object, path)
       : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
   };
@@ -3203,7 +3303,7 @@ var identity_1 = identity;
  * @returns {Function} Returns the new accessor function.
  */
 function baseProperty(key) {
-  return function(object) {
+  return function (object) {
     return object == null ? undefined : object[key];
   };
 }
@@ -3218,7 +3318,7 @@ var _baseProperty = baseProperty;
  * @returns {Function} Returns the new accessor function.
  */
 function basePropertyDeep(path) {
-  return function(object) {
+  return function (object) {
     return _baseGet(object, path);
   };
 }
@@ -3263,16 +3363,14 @@ var property_1 = property;
 function baseIteratee(value) {
   // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
   // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
-  if (typeof value == 'function') {
+  if (typeof value == "function") {
     return value;
   }
   if (value == null) {
     return identity_1;
   }
-  if (typeof value == 'object') {
-    return isArray_1(value)
-      ? _baseMatchesProperty(value[0], value[1])
-      : _baseMatches(value);
+  if (typeof value == "object") {
+    return isArray_1(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);
   }
   return property_1(value);
 }
@@ -3287,11 +3385,11 @@ var _baseIteratee = baseIteratee;
  * @returns {Function} Returns the new base function.
  */
 function createBaseFor(fromRight) {
-  return function(object, iteratee, keysFunc) {
+  return function (object, iteratee, keysFunc) {
     var index = -1,
-        iterable = Object(object),
-        props = keysFunc(object),
-        length = props.length;
+      iterable = Object(object),
+      props = keysFunc(object),
+      length = props.length;
 
     while (length--) {
       var key = props[fromRight ? length : ++index];
@@ -3343,7 +3441,7 @@ var _baseForOwn = baseForOwn;
  * @returns {Function} Returns the new base function.
  */
 function createBaseEach(eachFunc, fromRight) {
-  return function(collection, iteratee) {
+  return function (collection, iteratee) {
     if (collection == null) {
       return collection;
     }
@@ -3351,10 +3449,10 @@ function createBaseEach(eachFunc, fromRight) {
       return eachFunc(collection, iteratee);
     }
     var length = collection.length,
-        index = fromRight ? length : -1,
-        iterable = Object(collection);
+      index = fromRight ? length : -1,
+      iterable = Object(collection);
 
-    while ((fromRight ? index-- : ++index < length)) {
+    while (fromRight ? index-- : ++index < length) {
       if (iteratee(iterable[index], index, iterable) === false) {
         break;
       }
@@ -3387,9 +3485,9 @@ var _baseEach = baseEach;
  */
 function baseMap(collection, iteratee) {
   var index = -1,
-      result = isArrayLike_1(collection) ? Array(collection.length) : [];
+    result = isArrayLike_1(collection) ? Array(collection.length) : [];
 
-  _baseEach(collection, function(value, key, collection) {
+  _baseEach(collection, function (value, key, collection) {
     result[++index] = iteratee(value, key, collection);
   });
   return result;
@@ -3450,20 +3548,17 @@ var map_1 = map;
  * Is the range (default: selection) across blocks.
  */
 
-const isRangeAcrossBlocks = (editor, {
-  at,
-  ...options
-} = {}) => {
+const isRangeAcrossBlocks = (editor, { at, ...options } = {}) => {
   if (!at) at = editor.selection;
   if (!at) return false;
   const [start, end] = Range.edges(at);
   const startBlock = getBlockAbove(editor, {
     at: start,
-    ...options
+    ...options,
   });
   const endBlock = getBlockAbove(editor, {
     at: end,
-    ...options
+    ...options,
   });
   return startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
 };
@@ -3475,17 +3570,17 @@ const isRangeAcrossBlocks = (editor, {
  * TODO: support for sequence of any characters.
  */
 const getPointBefore = (editor, at, options) => {
-  if (!options || !options.match && !options.matchString) {
+  if (!options || (!options.match && !options.matchString)) {
     return Editor.before(editor, at, options);
   }
 
-  const unitOffset = !options.unit || options.unit === 'offset';
-  const matchStrings = options.matchString ? castArray_1(options.matchString) : [''];
+  const unitOffset = !options.unit || options.unit === "offset";
+  const matchStrings = options.matchString ? castArray_1(options.matchString) : [""];
   let point;
-  matchStrings.some(matchString => {
+  matchStrings.some((matchString) => {
     let beforeAt = at;
     let previousBeforePoint = Editor.point(editor, at, {
-      edge: 'end'
+      edge: "end",
     });
     const stackLength = matchString.length + 1;
     const stack = Array(stackLength);
@@ -3498,40 +3593,50 @@ const getPointBefore = (editor, at, options) => {
 
       if (!beforePoint) return; // stop looking outside of current block
 
-      if (isRangeAcrossBlocks(editor, {
-        at: {
-          anchor: beforePoint,
-          focus: previousBeforePoint
-        }
-      })) {
+      if (
+        isRangeAcrossBlocks(editor, {
+          at: {
+            anchor: beforePoint,
+            focus: previousBeforePoint,
+          },
+        })
+      ) {
         return;
       }
 
       const beforeString = Editor.string(editor, {
         anchor: beforePoint,
-        focus: previousBeforePoint
+        focus: previousBeforePoint,
       });
       let beforeStringToMatch = beforeString;
 
       if (unitOffset && stackLength) {
         stack.unshift({
           point: beforePoint,
-          text: beforeString
+          text: beforeString,
         });
         stack.pop();
-        beforeStringToMatch = map_1(stack.slice(0, -1), 'text').join('');
+        beforeStringToMatch = map_1(stack.slice(0, -1), "text").join("");
       }
 
-      if (matchString === beforeStringToMatch || (_options$match = options.match) !== null && _options$match !== void 0 && _options$match.call(options, {
-        beforeString: beforeStringToMatch,
-        beforePoint,
-        at
-      })) {
+      if (
+        matchString === beforeStringToMatch ||
+        ((_options$match = options.match) !== null &&
+          _options$match !== void 0 &&
+          _options$match.call(options, {
+            beforeString: beforeStringToMatch,
+            beforePoint,
+            at,
+          }))
+      ) {
         if (options.afterMatch) {
           if (stackLength && unitOffset) {
             var _stack;
 
-            point = (_stack = stack[stack.length - 1]) === null || _stack === void 0 ? void 0 : _stack.point;
+            point =
+              (_stack = stack[stack.length - 1]) === null || _stack === void 0
+                ? void 0
+                : _stack.point;
             return !!point;
           }
 
@@ -3561,17 +3666,15 @@ const getPointBefore = (editor, at, options) => {
  * If the location is a path, get the point at this path with offset 0.
  * If `focus` is true, get the focus point.
  */
-const getPointFromLocation = (editor, {
-  at = editor.selection,
-  focus
-} = {}) => {
+const getPointFromLocation = (editor, { at = editor.selection, focus } = {}) => {
   let point;
   if (Range.isRange(at)) point = !focus ? at.anchor : at.focus;
   if (Point.isPoint(at)) point = at;
-  if (Path.isPath(at)) point = {
-    path: at,
-    offset: 0
-  };
+  if (Path.isPath(at))
+    point = {
+      path: at,
+      offset: 0,
+    };
   return point;
 };
 
@@ -3579,18 +3682,15 @@ const getPointFromLocation = (editor, {
  * If the start point is inside an inline void, get the point before or after it.
  */
 
-const getPointNextToVoid = (editor, {
-  at,
-  after
-}) => {
+const getPointNextToVoid = (editor, { at, after }) => {
   const startVoid = Editor.void(editor, {
     at,
-    mode: 'highest'
+    mode: "highest",
   });
 
   if (startVoid) {
     const blockAbove = getBlockAbove(editor, {
-      at
+      at,
     });
 
     if (blockAbove) {
@@ -3614,11 +3714,7 @@ const getPointNextToVoid = (editor, {
 /**
  * Query the node entry.
  */
-const queryNode = (entry, {
-  filter,
-  allow,
-  exclude
-} = {}) => {
+const queryNode = (entry, { filter, allow, exclude } = {}) => {
   if (!entry) return false;
 
   if (filter && !filter(entry)) {
@@ -3652,13 +3748,13 @@ const queryNode = (entry, {
 const getPreviousBlockById = (editor, id, query) => {
   const entry = findNode(editor, {
     match: {
-      id
-    }
+      id,
+    },
   });
 
   if (entry) {
     const prevEntry = Editor.previous(editor, {
-      at: entry[1]
+      at: entry[1],
     });
 
     if (prevEntry && prevEntry[0].id && Editor.isBlock(editor, prevEntry[0])) {
@@ -3667,37 +3763,41 @@ const getPreviousBlockById = (editor, id, query) => {
   }
 
   let found = false;
-  const nodeEntries = [...Editor.nodes(editor, {
-    mode: 'highest',
-    reverse: true,
-    match: _n => {
-      const n = _n; // filter nodes that are not blocks and without id.
+  const nodeEntries = [
+    ...Editor.nodes(editor, {
+      mode: "highest",
+      reverse: true,
+      match: (_n) => {
+        const n = _n; // filter nodes that are not blocks and without id.
 
-      if (!Editor.isBlock(editor, n) || !n.id) return false; // find the block then take the previous one.
+        if (!Editor.isBlock(editor, n) || !n.id) return false; // find the block then take the previous one.
 
-      if (n.id === id) {
-        found = true;
-        return false;
-      }
+        if (n.id === id) {
+          found = true;
+          return false;
+        }
 
-      return found && n.id !== id && queryNode([n, []], query);
-    },
-    at: []
-  })];
+        return found && n.id !== id && queryNode([n, []], query);
+      },
+      at: [],
+    }),
+  ];
 
   if (nodeEntries.length) {
     return nodeEntries[0];
   }
 
   if (!found) return;
-  const firstNodeEntry = [...Editor.nodes(editor, {
-    mode: 'highest',
-    match: _n => {
-      const n = _n;
-      return Editor.isBlock(editor, n) && !!n.id && queryNode([n, []], query);
-    },
-    at: []
-  })];
+  const firstNodeEntry = [
+    ...Editor.nodes(editor, {
+      mode: "highest",
+      match: (_n) => {
+        const n = _n;
+        return Editor.isBlock(editor, n) && !!n.id && queryNode([n, []], query);
+      },
+      at: [],
+    }),
+  ];
 
   if (firstNodeEntry.length) {
     const [, path] = firstNodeEntry[0];
@@ -3706,7 +3806,7 @@ const getPreviousBlockById = (editor, id, query) => {
   }
 };
 
-const getPreviousPath = path => {
+const getPreviousPath = (path) => {
   if (path.length === 0) return;
   const last = path[path.length - 1];
   if (last <= 0) return;
@@ -3720,11 +3820,11 @@ const getRangeBefore = (editor, at, options) => {
   const anchor = getPointBefore(editor, at, options);
   if (!anchor) return;
   const focus = Editor.point(editor, at, {
-    edge: 'end'
+    edge: "end",
   });
   return {
     anchor,
-    focus
+    focus,
   };
 };
 
@@ -3735,14 +3835,17 @@ const getRangeBefore = (editor, at, options) => {
 const getRangeFromBlockStart = (editor, options = {}) => {
   var _getBlockAbove;
 
-  const path = (_getBlockAbove = getBlockAbove(editor, options)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];
+  const path =
+    (_getBlockAbove = getBlockAbove(editor, options)) === null || _getBlockAbove === void 0
+      ? void 0
+      : _getBlockAbove[1];
   if (!path) return;
   const start = Editor.start(editor, path);
   const focus = getPointFromLocation(editor, options);
   if (!focus) return;
   return {
     anchor: start,
-    focus
+    focus,
   };
 };
 
@@ -3753,7 +3856,7 @@ const getRangeFromBlockStart = (editor, options = {}) => {
 const getText = (editor, at) => {
   var _ref;
 
-  return (_ref = at && Editor.string(editor, at)) !== null && _ref !== void 0 ? _ref : '';
+  return (_ref = at && Editor.string(editor, at)) !== null && _ref !== void 0 ? _ref : "";
 };
 
 /**
@@ -3761,9 +3864,9 @@ const getText = (editor, at) => {
  * Return empty string if no selection.
  */
 
-const getSelectionText = editor => getText(editor, editor.selection);
+const getSelectionText = (editor) => getText(editor, editor.selection);
 
-const hasSingleChild = node => {
+const hasSingleChild = (node) => {
   if (Text.isText(node)) {
     return true;
   }
@@ -3774,16 +3877,20 @@ const hasSingleChild = node => {
 /**
  * Is an ancestor empty (empty text and no inline children).
  */
-const isAncestorEmpty = (editor, node) => !Node$1.string(node) && !node.children.some(n => Editor.isInline(editor, n));
+const isAncestorEmpty = (editor, node) =>
+  !Node$1.string(node) && !node.children.some((n) => Editor.isInline(editor, n));
 
 /**
  * Is the block above the selection empty.
  */
 
-const isBlockAboveEmpty = editor => {
+const isBlockAboveEmpty = (editor) => {
   var _getBlockAbove;
 
-  const block = (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[0];
+  const block =
+    (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0
+      ? void 0
+      : _getBlockAbove[0];
   if (!block) return false;
   return isAncestorEmpty(editor, block);
 };
@@ -3796,7 +3903,7 @@ const isText = Text.isText;
  * Else, check if the next leaves are empty.
  */
 
-const isBlockTextEmptyAfterSelection = editor => {
+const isBlockTextEmptyAfterSelection = (editor) => {
   if (!editor.selection) return false;
   const blockAbove = getBlockAbove(editor);
   if (!blockAbove) return false;
@@ -3825,7 +3932,7 @@ const isBlockTextEmptyAfterSelection = editor => {
  * Return false if `range` is not defined.
  */
 
-const isCollapsed = range => !!range && Range.isCollapsed(range);
+const isCollapsed = (range) => !!range && Range.isCollapsed(range);
 
 /**
  * {@link Editor.isEnd}. If point is null, return false.
@@ -3837,18 +3944,18 @@ const isEnd = (editor, point, at) => !!point && Editor.isEnd(editor, point, at);
  * Return false if `range` is not defined.
  */
 
-const isExpanded = range => !!range && Range.isExpanded(range);
+const isExpanded = (range) => !!range && Range.isExpanded(range);
 
 /**
  * Is it the first child of the parent
  */
-const isFirstChild = path => path[path.length - 1] === 0;
+const isFirstChild = (path) => path[path.length - 1] === 0;
 
 /**
  * @returns whether the provided parameter is undefined.
  */
 function isUndefined(obj) {
-  return typeof obj === 'undefined';
+  return typeof obj === "undefined";
 }
 function isNull(obj) {
   return obj === null;
@@ -3881,9 +3988,7 @@ const AFTER_MATCH_REGEX = /^(\s|$)/;
  * Is a point at the end of a word
  */
 
-const isPointAtWordEnd = (editor, {
-  at
-}) => {
+const isPointAtWordEnd = (editor, { at }) => {
   // Point after at
   const after = Editor.after(editor, at); // From at to after
 
@@ -3897,7 +4002,7 @@ const isPointAtWordEnd = (editor, {
  * Is the range in the same single text path.
  */
 
-const isRangeInSingleText = at => {
+const isRangeInSingleText = (at) => {
   const [start, end] = Range.edges(at);
   return Path.equals(start.path, end.path);
 };
@@ -3906,11 +4011,23 @@ const isRangeInSingleText = at => {
  * Is the selection focus at the end of its parent block.
  */
 
-const isSelectionAtBlockEnd = editor => {
+const isSelectionAtBlockEnd = (editor) => {
   var _getBlockAbove, _editor$selection;
 
-  const path = (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];
-  return !!path && isEnd(editor, (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus, path);
+  const path =
+    (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0
+      ? void 0
+      : _getBlockAbove[1];
+  return (
+    !!path &&
+    isEnd(
+      editor,
+      (_editor$selection = editor.selection) === null || _editor$selection === void 0
+        ? void 0
+        : _editor$selection.focus,
+      path
+    )
+  );
 };
 
 /**
@@ -3927,15 +4044,27 @@ const isStart = (editor, point, at) => !!point && Editor.isStart(editor, point,
 const isSelectionAtBlockStart = (editor, options) => {
   var _getBlockAbove, _editor$selection;
 
-  const path = (_getBlockAbove = getBlockAbove(editor, options)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];
-  return !!path && isStart(editor, (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus, path);
+  const path =
+    (_getBlockAbove = getBlockAbove(editor, options)) === null || _getBlockAbove === void 0
+      ? void 0
+      : _getBlockAbove[1];
+  return (
+    !!path &&
+    isStart(
+      editor,
+      (_editor$selection = editor.selection) === null || _editor$selection === void 0
+        ? void 0
+        : _editor$selection.focus,
+      path
+    )
+  );
 };
 
 /**
  * Is the selection expanded.
  */
 
-const isSelectionExpanded = editor => isExpanded(editor.selection);
+const isSelectionExpanded = (editor) => isExpanded(editor.selection);
 
 const isTextByPath = (editor, path) => {
   const node = Node$1.get(editor, path);
@@ -3945,7 +4074,7 @@ const isTextByPath = (editor, path) => {
 /**
  * Get `editor.pluginsByKey`
  */
-const getPluginsByKey = editor => {
+const getPluginsByKey = (editor) => {
   const plugins = {};
 
   if (editor !== null && editor !== void 0 && editor.pluginsByKey) {
@@ -3962,9 +4091,12 @@ const getPluginsByKey = editor => {
 const getPlugin = (editor, key) => {
   var _getPluginsByKey$key;
 
-  return (_getPluginsByKey$key = getPluginsByKey(editor)[key]) !== null && _getPluginsByKey$key !== void 0 ? _getPluginsByKey$key : {
-    key
-  };
+  return (_getPluginsByKey$key = getPluginsByKey(editor)[key]) !== null &&
+    _getPluginsByKey$key !== void 0
+    ? _getPluginsByKey$key
+    : {
+        key,
+      };
 };
 
 /**
@@ -3974,7 +4106,12 @@ const getPlugin = (editor, key) => {
 const getPluginType = (editor, key) => {
   var _ref, _getPlugin$type;
 
-  return (_ref = (_getPlugin$type = getPlugin(editor, key).type) !== null && _getPlugin$type !== void 0 ? _getPlugin$type : key) !== null && _ref !== void 0 ? _ref : '';
+  return (_ref =
+    (_getPlugin$type = getPlugin(editor, key).type) !== null && _getPlugin$type !== void 0
+      ? _getPlugin$type
+      : key) !== null && _ref !== void 0
+    ? _ref
+    : "";
 };
 
 /**
@@ -3983,14 +4120,15 @@ const getPluginType = (editor, key) => {
 
 const isType = (editor, node, key) => {
   const keys = castArray_1(key);
-  keys.forEach(_key => {
-    if ((node === null || node === void 0 ? void 0 : node.type) === getPluginType(editor, _key)) return true;
+  keys.forEach((_key) => {
+    if ((node === null || node === void 0 ? void 0 : node.type) === getPluginType(editor, _key))
+      return true;
   });
   return false;
 };
 
-const escapeRegExp = text => {
-  return text.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&');
+const escapeRegExp = (text) => {
+  return text.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&");
 };
 
 /**
@@ -3998,13 +4136,10 @@ const escapeRegExp = text => {
  * https://github.com/ianstormtaylor/slate/blob/main/packages/slate/src/utils/string.ts#L6
  */
 
-const isWordAfterTrigger = (editor, {
-  at,
-  trigger
-}) => {
+const isWordAfterTrigger = (editor, { at, trigger }) => {
   // Point at the start of previous word (excluding punctuation)
   const wordBefore = Editor.before(editor, at, {
-    unit: 'word'
+    unit: "word",
   }); // Point before wordBefore
 
   const before = wordBefore && Editor.before(editor, wordBefore); // Range from before to start
@@ -4019,7 +4154,7 @@ const isWordAfterTrigger = (editor, {
   const match = !!beforeText && beforeText.match(beforeRegex);
   return {
     range: beforeRange,
-    match
+    match,
   };
 };
 
@@ -4036,37 +4171,50 @@ const someNode = (editor, options) => {
  * Query the editor state.
  */
 
-const queryEditor = (editor, {
-  filter,
-  selectionAtBlockStart,
-  selectionAtBlockEnd,
-  allow,
-  exclude,
-  at = editor.selection || []
-} = {}) => {
-  if (filter && !filter(editor) || selectionAtBlockStart && !isSelectionAtBlockStart(editor) || selectionAtBlockEnd && !isSelectionAtBlockEnd(editor)) {
+const queryEditor = (
+  editor,
+  {
+    filter,
+    selectionAtBlockStart,
+    selectionAtBlockEnd,
+    allow,
+    exclude,
+    at = editor.selection || [],
+  } = {}
+) => {
+  if (
+    (filter && !filter(editor)) ||
+    (selectionAtBlockStart && !isSelectionAtBlockStart(editor)) ||
+    (selectionAtBlockEnd && !isSelectionAtBlockEnd(editor))
+  ) {
     return false;
   }
 
   const allows = castArray_1(allow);
 
-  if (allows.length && !someNode(editor, {
-    at,
-    match: {
-      type: allows
-    }
-  })) {
+  if (
+    allows.length &&
+    !someNode(editor, {
+      at,
+      match: {
+        type: allows,
+      },
+    })
+  ) {
     return false;
   }
 
   const excludes = castArray_1(exclude);
 
-  if (excludes.length && someNode(editor, {
-    at,
-    match: {
-      type: excludes
-    }
-  })) {
+  if (
+    excludes.length &&
+    someNode(editor, {
+      at,
+      match: {
+        type: excludes,
+      },
+    })
+  ) {
     return false;
   }
 
@@ -4089,10 +4237,14 @@ const unsetNodes = (editor, props, options = {}) => {
  */
 function apply(func, thisArg, args) {
   switch (args.length) {
-    case 0: return func.call(thisArg);
-    case 1: return func.call(thisArg, args[0]);
-    case 2: return func.call(thisArg, args[0], args[1]);
-    case 3: return func.call(thisArg, args[0], args[1], args[2]);
+    case 0:
+      return func.call(thisArg);
+    case 1:
+      return func.call(thisArg, args[0]);
+    case 2:
+      return func.call(thisArg, args[0], args[1]);
+    case 3:
+      return func.call(thisArg, args[0], args[1], args[2]);
   }
   return func.apply(thisArg, args);
 }
@@ -4112,12 +4264,12 @@ var nativeMax = Math.max;
  * @returns {Function} Returns the new function.
  */
 function overRest(func, start, transform) {
-  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
-  return function() {
+  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
+  return function () {
     var args = arguments,
-        index = -1,
-        length = nativeMax(args.length - start, 0),
-        array = Array(length);
+      index = -1,
+      length = nativeMax(args.length - start, 0),
+      array = Array(length);
 
     while (++index < length) {
       array[index] = args[start + index];
@@ -4154,20 +4306,20 @@ var _overRest = overRest;
  * // => true
  */
 function constant(value) {
-  return function() {
+  return function () {
     return value;
   };
 }
 
 var constant_1 = constant;
 
-var defineProperty = (function() {
+var defineProperty = (function () {
   try {
-    var func = _getNative(Object, 'defineProperty');
-    func({}, '', {});
+    var func = _getNative(Object, "defineProperty");
+    func({}, "", {});
     return func;
   } catch (e) {}
-}());
+})();
 
 var _defineProperty$1 = defineProperty;
 
@@ -4179,20 +4331,22 @@ var _defineProperty$1 = defineProperty;
  * @param {Function} string The `toString` result.
  * @returns {Function} Returns `func`.
  */
-var baseSetToString = !_defineProperty$1 ? identity_1 : function(func, string) {
-  return _defineProperty$1(func, 'toString', {
-    'configurable': true,
-    'enumerable': false,
-    'value': constant_1(string),
-    'writable': true
-  });
-};
+var baseSetToString = !_defineProperty$1
+  ? identity_1
+  : function (func, string) {
+      return _defineProperty$1(func, "toString", {
+        configurable: true,
+        enumerable: false,
+        value: constant_1(string),
+        writable: true,
+      });
+    };
 
 var _baseSetToString = baseSetToString;
 
 /** Used to detect hot functions by number of calls within a span of milliseconds. */
 var HOT_COUNT = 800,
-    HOT_SPAN = 16;
+  HOT_SPAN = 16;
 
 /* Built-in method references for those with the same name as other `lodash` methods. */
 var nativeNow = Date.now;
@@ -4208,11 +4362,11 @@ var nativeNow = Date.now;
  */
 function shortOut(func) {
   var count = 0,
-      lastCalled = 0;
+    lastCalled = 0;
 
-  return function() {
+  return function () {
     var stamp = nativeNow(),
-        remaining = HOT_SPAN - (stamp - lastCalled);
+      remaining = HOT_SPAN - (stamp - lastCalled);
 
     lastCalled = stamp;
     if (remaining > 0) {
@@ -4249,7 +4403,7 @@ var _setToString = setToString;
  * @returns {Function} Returns the new function.
  */
 function baseRest(func, start) {
-  return _setToString(_overRest(func, start, identity_1), func + '');
+  return _setToString(_overRest(func, start, identity_1), func + "");
 }
 
 var _baseRest = baseRest;
@@ -4269,10 +4423,11 @@ function isIterateeCall(value, index, object) {
     return false;
   }
   var type = typeof index;
-  if (type == 'number'
-        ? (isArrayLike_1(object) && _isIndex(index, object.length))
-        : (type == 'string' && index in object)
-      ) {
+  if (
+    type == "number"
+      ? isArrayLike_1(object) && _isIndex(index, object.length)
+      : type == "string" && index in object
+  ) {
     return eq_1(object[index], value);
   }
   return false;
@@ -4319,10 +4474,10 @@ function baseKeysIn(object) {
     return _nativeKeysIn(object);
   }
   var isProto = _isPrototype(object),
-      result = [];
+    result = [];
 
   for (var key in object) {
-    if (!(key == 'constructor' && (isProto || !hasOwnProperty$4.call(object, key)))) {
+    if (!(key == "constructor" && (isProto || !hasOwnProperty$4.call(object, key)))) {
       result.push(key);
     }
   }
@@ -4387,7 +4542,7 @@ var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
  * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
  * // => { 'a': 1, 'b': 2 }
  */
-var defaults = _baseRest(function(object, sources) {
+var defaults = _baseRest(function (object, sources) {
   object = Object(object);
 
   var index = -1;
@@ -4408,8 +4563,10 @@ var defaults = _baseRest(function(object, sources) {
       var key = props[propsIndex];
       var value = object[key];
 
-      if (value === undefined ||
-          (eq_1(value, objectProto$3[key]) && !hasOwnProperty$3.call(object, key))) {
+      if (
+        value === undefined ||
+        (eq_1(value, objectProto$3[key]) && !hasOwnProperty$3.call(object, key))
+      ) {
         object[key] = source[key];
       }
     }
@@ -4423,12 +4580,7 @@ var defaults_1 = defaults;
 /**
  * Recursively apply an operation to children nodes with a query.
  */
-const applyDeepToNodes = ({
-  node,
-  source,
-  apply,
-  query
-}) => {
+const applyDeepToNodes = ({ node, source, apply, query }) => {
   const entry = [node, []];
 
   if (queryNode(entry, query)) {
@@ -4440,12 +4592,12 @@ const applyDeepToNodes = ({
   }
 
   if (!isAncestor(node)) return;
-  node.children.forEach(child => {
+  node.children.forEach((child) => {
     applyDeepToNodes({
       node: child,
       source,
       apply,
-      query
+      query,
     });
   });
 };
@@ -4454,10 +4606,8 @@ const applyDeepToNodes = ({
  * Recursively merge a source object to children nodes with a query.
  */
 
-const defaultsDeepToNodes = options => {
-  applyDeepToNodes({ ...options,
-    apply: defaults_1
-  });
+const defaultsDeepToNodes = (options) => {
+  applyDeepToNodes({ ...options, apply: defaults_1 });
 };
 
 /**
@@ -4467,16 +4617,13 @@ const defaultsDeepToNodes = options => {
 
 const mergeNodes = (editor, options = {}) => {
   Editor.withoutNormalizing(editor, () => {
-    let {
-      match,
-      at = editor.selection
-    } = options;
+    let { match, at = editor.selection } = options;
     const {
       mergeNode,
       removeEmptyAncestor,
       hanging = false,
       voids = false,
-      mode = 'lowest'
+      mode = "lowest",
     } = options;
 
     if (!at) {
@@ -4487,9 +4634,9 @@ const mergeNodes = (editor, options = {}) => {
       if (Path.isPath(at)) {
         const [parent] = Editor.parent(editor, at);
 
-        match = n => parent.children.includes(n);
+        match = (n) => parent.children.includes(n);
       } else {
-        match = n => Editor.isBlock(editor, n);
+        match = (n) => Editor.isBlock(editor, n);
       }
     }
 
@@ -4504,7 +4651,7 @@ const mergeNodes = (editor, options = {}) => {
         const [, end] = Range.edges(at);
         const pointRef = Editor.pointRef(editor, end);
         Transforms.delete(editor, {
-          at
+          at,
         });
         at = pointRef.unref();
 
@@ -4518,13 +4665,13 @@ const mergeNodes = (editor, options = {}) => {
       at,
       match,
       voids,
-      mode
+      mode,
     });
     const prev = Editor.previous(editor, {
       at,
       match,
       voids,
-      mode
+      mode,
     });
 
     if (!current || !prev) {
@@ -4541,15 +4688,20 @@ const mergeNodes = (editor, options = {}) => {
     const newPath = Path.next(prevPath);
     const commonPath = Path.common(path, prevPath);
     const isPreviousSibling = Path.isSibling(path, prevPath);
-    const levels = Array.from(Editor.levels(editor, {
-      at: path
-    }), ([n]) => n).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a
+    const levels = Array.from(
+      Editor.levels(editor, {
+        at: path,
+      }),
+      ([n]) => n
+    )
+      .slice(commonPath.length)
+      .slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a
     // result, in which case we'll want to remove it after merging.
 
     const emptyAncestor = Editor.above(editor, {
       at: path,
-      mode: 'highest',
-      match: n => levels.includes(n) && Element.isElement(n) && hasSingleChild(n)
+      mode: "highest",
+      match: (n) => levels.includes(n) && Element.isElement(n) && hasSingleChild(n),
     });
     const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
     let properties;
@@ -4557,75 +4709,73 @@ const mergeNodes = (editor, options = {}) => {
     // and extra properties of the merge will be.
 
     if (Text.isText(node) && Text.isText(prevNode)) {
-      const {
-        text,
-        ...rest
-      } = node;
+      const { text, ...rest } = node;
       position = prevNode.text.length;
       properties = rest;
     } else if (Element.isElement(node) && Element.isElement(prevNode)) {
-      const {
-        children,
-        ...rest
-      } = node;
+      const { children, ...rest } = node;
       position = prevNode.children.length;
       properties = rest;
     } else {
-      throw new Error(`Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(node)} ${JSON.stringify(prevNode)}`);
+      throw new Error(
+        `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(
+          node
+        )} ${JSON.stringify(prevNode)}`
+      );
     } // If the node isn't already the next sibling of the previous node, move
     // it so that it is before merging.
 
-
     if (!isPreviousSibling) {
       // DIFF
       if (!mergeNode) {
         Transforms.moveNodes(editor, {
           at: path,
           to: newPath,
-          voids
+          voids,
         });
       }
     } // If there was going to be an empty ancestor of the node that was merged,
     // we remove it from the tree.
 
-
     if (emptyRef) {
       // DIFF: start
       if (!removeEmptyAncestor) {
         Transforms.removeNodes(editor, {
           at: emptyRef.current,
-          voids
+          voids,
         });
       } else {
         const emptyPath = emptyRef.current;
-        emptyPath && removeEmptyAncestor(editor, {
-          at: emptyPath
-        });
+        emptyPath &&
+          removeEmptyAncestor(editor, {
+            at: emptyPath,
+          });
       } // DIFF: end
-
     } // If the target node that we're merging with is empty, remove it instead
     // of merging the two. This is a common rich text editor behavior to
     // prevent losing formatting when deleting entire nodes when you have a
     // hanging selection.
     // DIFF: start
 
-
     if (mergeNode) {
       mergeNode(editor, {
         at: path,
-        to: newPath
+        to: newPath,
       }); // DIFF: end
-    } else if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '') {
+    } else if (
+      (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||
+      (Text.isText(prevNode) && prevNode.text === "")
+    ) {
       Transforms.removeNodes(editor, {
         at: prevPath,
-        voids
+        voids,
       });
     } else {
       editor.apply({
-        type: 'merge_node',
+        type: "merge_node",
         path: newPath,
         position,
-        properties
+        properties,
       });
     }
 
@@ -4637,16 +4787,8 @@ const mergeNodes = (editor, options = {}) => {
 
 const deleteFragment = (editor, options = {}) => {
   Editor.withoutNormalizing(editor, () => {
-    const {
-      reverse = false,
-      unit = 'character',
-      distance = 1,
-      voids = false
-    } = options;
-    let {
-      at = editor.selection,
-      hanging = false
-    } = options;
+    const { reverse = false, unit = "character", distance = 1, voids = false } = options;
+    let { at = editor.selection, hanging = false } = options;
 
     if (!at) {
       return;
@@ -4659,7 +4801,7 @@ const deleteFragment = (editor, options = {}) => {
     if (Point.isPoint(at)) {
       const furthestVoid = Editor.void(editor, {
         at,
-        mode: 'highest'
+        mode: "highest",
       });
 
       if (!voids && furthestVoid) {
@@ -4668,12 +4810,14 @@ const deleteFragment = (editor, options = {}) => {
       } else {
         const opts = {
           unit,
-          distance
+          distance,
         };
-        const target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);
+        const target = reverse
+          ? Editor.before(editor, at, opts) || Editor.start(editor, [])
+          : Editor.after(editor, at, opts) || Editor.end(editor, []);
         at = {
           anchor: at,
-          focus: target
+          focus: target,
         };
         hanging = true;
       }
@@ -4682,7 +4826,7 @@ const deleteFragment = (editor, options = {}) => {
     if (Path.isPath(at)) {
       Transforms.removeNodes(editor, {
         at,
-        voids
+        voids,
       });
       return;
     }
@@ -4693,31 +4837,35 @@ const deleteFragment = (editor, options = {}) => {
 
     if (!hanging) {
       at = Editor.unhangRange(editor, at, {
-        voids
+        voids,
       });
     }
 
     let [start, end] = Range.edges(at);
     const startBlock = Editor.above(editor, {
-      match: n => Editor.isBlock(editor, n),
+      match: (n) => Editor.isBlock(editor, n),
       at: start,
-      voids
+      voids,
     });
     const endBlock = Editor.above(editor, {
-      match: n => Editor.isBlock(editor, n),
+      match: (n) => Editor.isBlock(editor, n),
       at: end,
-      voids
+      voids,
     });
     const isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
     const isSingleText = Path.equals(start.path, end.path);
-    const startVoid = voids ? null : Editor.void(editor, {
-      at: start,
-      mode: 'highest'
-    });
-    const endVoid = voids ? null : Editor.void(editor, {
-      at: end,
-      mode: 'highest'
-    }); // If the start or end points are inside an inline void, nudge them out.
+    const startVoid = voids
+      ? null
+      : Editor.void(editor, {
+          at: start,
+          mode: "highest",
+        });
+    const endVoid = voids
+      ? null
+      : Editor.void(editor, {
+          at: end,
+          mode: "highest",
+        }); // If the start or end points are inside an inline void, nudge them out.
 
     if (startVoid) {
       const before = Editor.before(editor, start);
@@ -4736,13 +4884,12 @@ const deleteFragment = (editor, options = {}) => {
     } // Get the highest nodes that are completely inside the range, as well as
     // the start and end nodes.
 
-
     const matches = [];
     let lastPath;
 
     for (const entry of Editor.nodes(editor, {
       at,
-      voids
+      voids,
     })) {
       const [node, path] = entry;
 
@@ -4750,7 +4897,10 @@ const deleteFragment = (editor, options = {}) => {
         continue;
       }
 
-      if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {
+      if (
+        (!voids && Editor.isVoid(editor, node)) ||
+        (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))
+      ) {
         matches.push(entry);
         lastPath = path;
       }
@@ -4763,18 +4913,14 @@ const deleteFragment = (editor, options = {}) => {
     if (!isSingleText && !startVoid) {
       const point = startRef.current;
       const [node] = Editor.leaf(editor, point);
-      const {
-        path
-      } = point;
-      const {
-        offset
-      } = start;
+      const { path } = point;
+      const { offset } = start;
       const text = node.text.slice(offset);
       editor.apply({
-        type: 'remove_text',
+        type: "remove_text",
         path,
         offset,
-        text
+        text,
       });
     }
 
@@ -4782,23 +4928,21 @@ const deleteFragment = (editor, options = {}) => {
       const path = pathRef.unref();
       Transforms.removeNodes(editor, {
         at: path,
-        voids
+        voids,
       });
     }
 
     if (!endVoid) {
       const point = endRef.current;
       const [node] = Editor.leaf(editor, point);
-      const {
-        path
-      } = point;
+      const { path } = point;
       const offset = isSingleText ? start.offset : 0;
       const text = node.text.slice(offset, end.offset);
       editor.apply({
-        type: 'remove_text',
+        type: "remove_text",
         path,
         offset,
-        text
+        text,
       });
     }
 
@@ -4807,7 +4951,7 @@ const deleteFragment = (editor, options = {}) => {
       mergeNodes(editor, {
         at: endRef.current,
         hanging: true,
-        voids
+        voids,
       });
     }
 
@@ -4822,24 +4966,25 @@ const deleteFragment = (editor, options = {}) => {
 const insertNodes = (editor, props, options) => Transforms.insertNodes(editor, props, options);
 
 const insertEmptyElement = (editor, type, options) => {
-  insertNodes(editor, {
-    type,
-    children: [{
-      text: ''
-    }]
-  }, getQueryOptions(editor, options));
+  insertNodes(
+    editor,
+    {
+      type,
+      children: [
+        {
+          text: "",
+        },
+      ],
+    },
+    getQueryOptions(editor, options)
+  );
 };
 
 /**
  * Move the children of a node to a path.
  * Returns the number of children moved.
  */
-const moveChildren = (editor, {
-  at,
-  to,
-  match,
-  fromStartIndex = 0
-}) => {
+const moveChildren = (editor, { at, to, match, fromStartIndex = 0 }) => {
   let moved = 0;
   const parentPath = Path.isPath(at) ? at : at[1];
   const parentNode = Path.isPath(at) ? Node$1.get(editor, parentPath) : at[0];
@@ -4849,10 +4994,10 @@ const moveChildren = (editor, {
     const childPath = [...parentPath, i];
     const childNode = getNode(editor, childPath);
 
-    if (!match || childNode && match([childNode, childPath])) {
+    if (!match || (childNode && match([childNode, childPath]))) {
       Transforms.moveNodes(editor, {
         at: childPath,
-        to
+        to,
       });
       moved++;
     }
@@ -4864,12 +5009,7 @@ const moveChildren = (editor, {
 /**
  * Remove mark and trigger `onChange` if collapsed selection.
  */
-const removeMark = (editor, {
-  key,
-  at,
-  shouldChange = true,
-  ...rest
-}) => {
+const removeMark = (editor, { key, at, shouldChange = true, ...rest }) => {
   const selection = at !== null && at !== void 0 ? at : editor.selection;
   key = castArray_1(key);
 
@@ -4879,12 +5019,11 @@ const removeMark = (editor, {
         at: selection,
         match: Text.isText,
         split: true,
-        ...rest
+        ...rest,
       });
     } else if (editor.selection) {
-      const marks = { ...(Editor.marks(editor) || {})
-      };
-      key.forEach(k => {
+      const marks = { ...(Editor.marks(editor) || {}) };
+      key.forEach((k) => {
         delete marks[k];
       });
       editor.marks = marks;
@@ -4896,22 +5035,18 @@ const removeMark = (editor, {
 /**
  * Select an editor at a target or an edge (start, end).
  */
-const selectEditor = (editor, {
-  at,
-  edge,
-  focus
-}) => {
+const selectEditor = (editor, { at, edge, focus }) => {
   if (focus) {
     ReactEditor.focus(editor);
   }
 
   let location = at;
 
-  if (edge === 'start') {
+  if (edge === "start") {
     location = Editor.start(editor, []);
   }
 
-  if (edge === 'end') {
+  if (edge === "end") {
     location = Editor.end(editor, []);
   }
 
@@ -4924,10 +5059,13 @@ const selectEditor = (editor, {
  * Select the end point of the block above the selection.
  */
 
-const selectEndOfBlockAboveSelection = editor => {
+const selectEndOfBlockAboveSelection = (editor) => {
   var _getBlockAbove;
 
-  const path = (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];
+  const path =
+    (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0
+      ? void 0
+      : _getBlockAbove[1];
   path && Transforms.select(editor, Editor.end(editor, path));
 };
 
@@ -4940,12 +5078,12 @@ const setMarks = (editor, marks, clear = []) => {
   Editor.withoutNormalizing(editor, () => {
     const clears = castArray_1(clear);
     removeMark(editor, {
-      key: clears
+      key: clears,
     });
     removeMark(editor, {
-      key: Object.keys(marks)
+      key: Object.keys(marks),
     });
-    Object.keys(marks).forEach(key => {
+    Object.keys(marks).forEach((key) => {
       editor.addMark(key, marks[key]);
     });
   });
@@ -4959,49 +5097,44 @@ const setNodes = (editor, props, options) => Transforms.setNodes(editor, props,
  * @param key mark to toggle
  * @param clear marks to clear when adding mark
  */
-const toggleMark = (editor, {
-  key,
-  clear
-}) => {
+const toggleMark = (editor, { key, clear }) => {
   if (!editor.selection) return;
   Editor.withoutNormalizing(editor, () => {
     const isActive = isMarkActive(editor, key);
 
     if (isActive) {
       removeMark(editor, {
-        key
+        key,
       });
       return;
     }
 
     const clears = castArray_1(clear);
     removeMark(editor, {
-      key: clears
+      key: clears,
     });
     editor.addMark(key, true);
   });
 };
 
-const ELEMENT_DEFAULT = 'p';
+const ELEMENT_DEFAULT = "p";
 
 /**
  * Toggle the type of the selected node.
  * Don't do anything if activeType === inactiveType.
  */
 const toggleNodeType = (editor, options, editorNodesOptions) => {
-  const {
-    activeType,
-    inactiveType = getPluginType(editor, ELEMENT_DEFAULT)
-  } = options;
+  const { activeType, inactiveType = getPluginType(editor, ELEMENT_DEFAULT) } = options;
   if (!activeType || !editor.selection) return;
-  const isActive = someNode(editor, { ...editorNodesOptions,
+  const isActive = someNode(editor, {
+    ...editorNodesOptions,
     match: {
-      type: activeType
-    }
+      type: activeType,
+    },
   });
   if (isActive && activeType === inactiveType) return;
   setNodes(editor, {
-    type: isActive ? inactiveType : activeType
+    type: isActive ? inactiveType : activeType,
   });
 };
 
@@ -5028,38 +5161,49 @@ const wrapNodes = (editor, element, options = {}) => {
  */
 
 const toggleWrapNodes = (editor, type) => {
-  if (someNode(editor, {
-    match: {
-      type
-    }
-  })) {
+  if (
+    someNode(editor, {
+      match: {
+        type,
+      },
+    })
+  ) {
     unwrapNodes(editor, {
       match: {
-        type
-      }
+        type,
+      },
     });
   } else {
     wrapNodes(editor, {
       type,
-      children: []
+      children: [],
     });
   }
 };
 
-const createDocumentNode = (type = 'p', text = '', remaining = []) => [{
-  children: [{
-    type,
-    children: [{
-      text
-    }]
-  }, ...remaining]
-}];
+const createDocumentNode = (type = "p", text = "", remaining = []) => [
+  {
+    children: [
+      {
+        type,
+        children: [
+          {
+            text,
+          },
+        ],
+      },
+      ...remaining,
+    ],
+  },
+];
 
-const createNode = (type = 'p', text = '') => ({
+const createNode = (type = "p", text = "") => ({
   type,
-  children: [{
-    text
-  }]
+  children: [
+    {
+      text,
+    },
+  ],
 });
 
 const findHtmlParentElement = (el, nodeName) => {
@@ -5073,17 +5217,21 @@ const findHtmlParentElement = (el, nodeName) => {
 /**
  * Call a handler if defined
  */
-const getHandler = (cb, ...args) => () => {
-  cb === null || cb === void 0 ? void 0 : cb(...args);
-};
+const getHandler =
+  (cb, ...args) =>
+  () => {
+    cb === null || cb === void 0 ? void 0 : cb(...args);
+  };
 
 /**
  * Prevent default and call a handler if defined
  */
-const getPreventDefaultHandler = (cb, ...args) => event => {
-  event.preventDefault();
-  cb === null || cb === void 0 ? void 0 : cb(...args);
-};
+const getPreventDefaultHandler =
+  (cb, ...args) =>
+  (event) => {
+    event.preventDefault();
+    cb === null || cb === void 0 ? void 0 : cb(...args);
+  };
 
 /**
  * RegExps.
@@ -5097,8 +5245,8 @@ const nonLocalhostDomainRE = /^[^\s.]+\.\S{2,}$/;
  * Loosely validate a URL `string`.
  */
 
-const isUrl = string => {
-  if (typeof string !== 'string') {
+const isUrl = (string) => {
+  if (typeof string !== "string") {
     return false;
   }
 
@@ -5120,14 +5268,17 @@ const isUrl = string => {
     return false;
   }
 
-  return localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol);
+  return (
+    localhostDomainRE.test(everythingAfterProtocol) ||
+    nonLocalhostDomainRE.test(everythingAfterProtocol)
+  );
 };
 
-const isInlineNode = editor => node => Text.isText(node) || editor.isInline(node);
+const isInlineNode = (editor) => (node) => Text.isText(node) || editor.isInline(node);
 
-const makeBlockLazy = type => () => ({
+const makeBlockLazy = (type) => () => ({
   type,
-  children: []
+  children: [],
 });
 
 const hasDifferentChildNodes = (descendants, isInline) => {
@@ -5145,44 +5296,45 @@ const hasDifferentChildNodes = (descendants, isInline) => {
  * Handles 3rd constraint: "Block nodes can only contain other blocks, or inline and text nodes."
  */
 
-
 const normalizeDifferentNodeTypes = (descendants, isInline, makeDefaultBlock) => {
   const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline);
-  const {
-    fragment
-  } = descendants.reduce((memo, node) => {
-    if (hasDifferentNodes && isInline(node)) {
-      let block = memo.precedingBlock;
-
-      if (!block) {
-        block = makeDefaultBlock();
-        memo.precedingBlock = block;
-        memo.fragment.push(block);
+  const { fragment } = descendants.reduce(
+    (memo, node) => {
+      if (hasDifferentNodes && isInline(node)) {
+        let block = memo.precedingBlock;
+
+        if (!block) {
+          block = makeDefaultBlock();
+          memo.precedingBlock = block;
+          memo.fragment.push(block);
+        }
+
+        block.children.push(node);
+      } else {
+        memo.fragment.push(node);
+        memo.precedingBlock = null;
       }
 
-      block.children.push(node);
-    } else {
-      memo.fragment.push(node);
-      memo.precedingBlock = null;
+      return memo;
+    },
+    {
+      fragment: [],
+      precedingBlock: null,
     }
-
-    return memo;
-  }, {
-    fragment: [],
-    precedingBlock: null
-  });
+  );
   return fragment;
 };
 /**
  * Handles 1st constraint: "All Element nodes must contain at least one Text descendant."
  */
 
-
-const normalizeEmptyChildren = descendants => {
+const normalizeEmptyChildren = (descendants) => {
   if (!descendants.length) {
-    return [{
-      text: ''
-    }];
+    return [
+      {
+        text: "",
+      },
+    ];
   }
 
   return descendants;
@@ -5191,11 +5343,9 @@ const normalizeEmptyChildren = descendants => {
 const normalize = (descendants, isInline, makeDefaultBlock) => {
   descendants = normalizeEmptyChildren(descendants);
   descendants = normalizeDifferentNodeTypes(descendants, isInline, makeDefaultBlock);
-  descendants = descendants.map(node => {
+  descendants = descendants.map((node) => {
     if (isElement(node)) {
-      return { ...node,
-        children: normalize(node.children, isInline, makeDefaultBlock)
-      };
+      return { ...node, children: normalize(node.children, isInline, makeDefaultBlock) };
     }
 
     return node;
@@ -5206,10 +5356,7 @@ const normalize = (descendants, isInline, makeDefaultBlock) => {
  * Normalize the descendants to a valid document fragment.
  */
 
-
-const normalizeDescendantsToDocumentFragment = (editor, {
-  descendants
-}) => {
+const normalizeDescendantsToDocumentFragment = (editor, { descendants }) => {
   const isInline = isInlineNode(editor);
   const defaultType = getPluginType(editor, ELEMENT_DEFAULT);
   const makeDefaultBlock = makeBlockLazy(defaultType);
@@ -5217,250 +5364,254 @@ const normalizeDescendantsToDocumentFragment = (editor, {
 };
 
 var lib = createCommonjsModule(function (module, exports) {
+  Object.defineProperty(exports, "__esModule", {
+    value: true,
+  });
 
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
+  /**
+   * Constants.
+   */
 
-/**
- * Constants.
- */
-
-var IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
-
-var MODIFIERS = {
-  alt: 'altKey',
-  control: 'ctrlKey',
-  meta: 'metaKey',
-  shift: 'shiftKey'
-};
-
-var ALIASES = {
-  add: '+',
-  break: 'pause',
-  cmd: 'meta',
-  command: 'meta',
-  ctl: 'control',
-  ctrl: 'control',
-  del: 'delete',
-  down: 'arrowdown',
-  esc: 'escape',
-  ins: 'insert',
-  left: 'arrowleft',
-  mod: IS_MAC ? 'meta' : 'control',
-  opt: 'alt',
-  option: 'alt',
-  return: 'enter',
-  right: 'arrowright',
-  space: ' ',
-  spacebar: ' ',
-  up: 'arrowup',
-  win: 'meta',
-  windows: 'meta'
-};
-
-var CODES = {
-  backspace: 8,
-  tab: 9,
-  enter: 13,
-  shift: 16,
-  control: 17,
-  alt: 18,
-  pause: 19,
-  capslock: 20,
-  escape: 27,
-  ' ': 32,
-  pageup: 33,
-  pagedown: 34,
-  end: 35,
-  home: 36,
-  arrowleft: 37,
-  arrowup: 38,
-  arrowright: 39,
-  arrowdown: 40,
-  insert: 45,
-  delete: 46,
-  meta: 91,
-  numlock: 144,
-  scrolllock: 145,
-  ';': 186,
-  '=': 187,
-  ',': 188,
-  '-': 189,
-  '.': 190,
-  '/': 191,
-  '`': 192,
-  '[': 219,
-  '\\': 220,
-  ']': 221,
-  '\'': 222
-};
-
-for (var f = 1; f < 20; f++) {
-  CODES['f' + f] = 111 + f;
-}
-
-/**
- * Is hotkey?
- */
-
-function isHotkey(hotkey, options, event) {
-  if (options && !('byKey' in options)) {
-    event = options;
-    options = null;
-  }
-
-  if (!Array.isArray(hotkey)) {
-    hotkey = [hotkey];
-  }
-
-  var array = hotkey.map(function (string) {
-    return parseHotkey(string, options);
-  });
-  var check = function check(e) {
-    return array.some(function (object) {
-      return compareHotkey(object, e);
-    });
+  var IS_MAC =
+    typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
+
+  var MODIFIERS = {
+    alt: "altKey",
+    control: "ctrlKey",
+    meta: "metaKey",
+    shift: "shiftKey",
   };
-  var ret = event == null ? check : check(event);
-  return ret;
-}
 
-function isCodeHotkey(hotkey, event) {
-  return isHotkey(hotkey, event);
-}
+  var ALIASES = {
+    add: "+",
+    break: "pause",
+    cmd: "meta",
+    command: "meta",
+    ctl: "control",
+    ctrl: "control",
+    del: "delete",
+    down: "arrowdown",
+    esc: "escape",
+    ins: "insert",
+    left: "arrowleft",
+    mod: IS_MAC ? "meta" : "control",
+    opt: "alt",
+    option: "alt",
+    return: "enter",
+    right: "arrowright",
+    space: " ",
+    spacebar: " ",
+    up: "arrowup",
+    win: "meta",
+    windows: "meta",
+  };
 
-function isKeyHotkey(hotkey, event) {
-  return isHotkey(hotkey, { byKey: true }, event);
-}
+  var CODES = {
+    backspace: 8,
+    tab: 9,
+    enter: 13,
+    shift: 16,
+    control: 17,
+    alt: 18,
+    pause: 19,
+    capslock: 20,
+    escape: 27,
+    " ": 32,
+    pageup: 33,
+    pagedown: 34,
+    end: 35,
+    home: 36,
+    arrowleft: 37,
+    arrowup: 38,
+    arrowright: 39,
+    arrowdown: 40,
+    insert: 45,
+    delete: 46,
+    meta: 91,
+    numlock: 144,
+    scrolllock: 145,
+    ";": 186,
+    "=": 187,
+    ",": 188,
+    "-": 189,
+    ".": 190,
+    "/": 191,
+    "`": 192,
+    "[": 219,
+    "\\": 220,
+    "]": 221,
+    "'": 222,
+  };
 
-/**
- * Parse.
- */
+  for (var f = 1; f < 20; f++) {
+    CODES["f" + f] = 111 + f;
+  }
 
-function parseHotkey(hotkey, options) {
-  var byKey = options && options.byKey;
-  var ret = {};
+  /**
+   * Is hotkey?
+   */
 
-  // Special case to handle the `+` key since we use it as a separator.
-  hotkey = hotkey.replace('++', '+add');
-  var values = hotkey.split('+');
-  var length = values.length;
+  function isHotkey(hotkey, options, event) {
+    if (options && !("byKey" in options)) {
+      event = options;
+      options = null;
+    }
 
-  // Ensure that all the modifiers are set to false unless the hotkey has them.
+    if (!Array.isArray(hotkey)) {
+      hotkey = [hotkey];
+    }
 
-  for (var k in MODIFIERS) {
-    ret[MODIFIERS[k]] = false;
+    var array = hotkey.map(function (string) {
+      return parseHotkey(string, options);
+    });
+    var check = function check(e) {
+      return array.some(function (object) {
+        return compareHotkey(object, e);
+      });
+    };
+    var ret = event == null ? check : check(event);
+    return ret;
   }
 
-  var _iteratorNormalCompletion = true;
-  var _didIteratorError = false;
-  var _iteratorError = undefined;
+  function isCodeHotkey(hotkey, event) {
+    return isHotkey(hotkey, event);
+  }
 
-  try {
-    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
-      var value = _step.value;
+  function isKeyHotkey(hotkey, event) {
+    return isHotkey(hotkey, { byKey: true }, event);
+  }
 
-      var optional = value.endsWith('?') && value.length > 1;
+  /**
+   * Parse.
+   */
 
-      if (optional) {
-        value = value.slice(0, -1);
-      }
+  function parseHotkey(hotkey, options) {
+    var byKey = options && options.byKey;
+    var ret = {};
 
-      var name = toKeyName(value);
-      var modifier = MODIFIERS[name];
+    // Special case to handle the `+` key since we use it as a separator.
+    hotkey = hotkey.replace("++", "+add");
+    var values = hotkey.split("+");
+    var length = values.length;
 
-      if (length === 1 || !modifier) {
-        if (byKey) {
-          ret.key = name;
-        } else {
-          ret.which = toKeyCode(value);
-        }
-      }
+    // Ensure that all the modifiers are set to false unless the hotkey has them.
 
-      if (modifier) {
-        ret[modifier] = optional ? null : true;
-      }
+    for (var k in MODIFIERS) {
+      ret[MODIFIERS[k]] = false;
     }
-  } catch (err) {
-    _didIteratorError = true;
-    _iteratorError = err;
-  } finally {
+
+    var _iteratorNormalCompletion = true;
+    var _didIteratorError = false;
+    var _iteratorError = undefined;
+
     try {
-      if (!_iteratorNormalCompletion && _iterator.return) {
-        _iterator.return();
+      for (
+        var _iterator = values[Symbol.iterator](), _step;
+        !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
+        _iteratorNormalCompletion = true
+      ) {
+        var value = _step.value;
+
+        var optional = value.endsWith("?") && value.length > 1;
+
+        if (optional) {
+          value = value.slice(0, -1);
+        }
+
+        var name = toKeyName(value);
+        var modifier = MODIFIERS[name];
+
+        if (length === 1 || !modifier) {
+          if (byKey) {
+            ret.key = name;
+          } else {
+            ret.which = toKeyCode(value);
+          }
+        }
+
+        if (modifier) {
+          ret[modifier] = optional ? null : true;
+        }
       }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
     } finally {
-      if (_didIteratorError) {
-        throw _iteratorError;
+      try {
+        if (!_iteratorNormalCompletion && _iterator.return) {
+          _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
       }
     }
+
+    return ret;
   }
 
-  return ret;
-}
+  /**
+   * Compare.
+   */
 
-/**
- * Compare.
- */
+  function compareHotkey(object, event) {
+    for (var key in object) {
+      var expected = object[key];
+      var actual = void 0;
 
-function compareHotkey(object, event) {
-  for (var key in object) {
-    var expected = object[key];
-    var actual = void 0;
+      if (expected == null) {
+        continue;
+      }
 
-    if (expected == null) {
-      continue;
-    }
+      if (key === "key" && event.key != null) {
+        actual = event.key.toLowerCase();
+      } else if (key === "which") {
+        actual = expected === 91 && event.which === 93 ? 91 : event.which;
+      } else {
+        actual = event[key];
+      }
 
-    if (key === 'key' && event.key != null) {
-      actual = event.key.toLowerCase();
-    } else if (key === 'which') {
-      actual = expected === 91 && event.which === 93 ? 91 : event.which;
-    } else {
-      actual = event[key];
-    }
+      if (actual == null && expected === false) {
+        continue;
+      }
 
-    if (actual == null && expected === false) {
-      continue;
+      if (actual !== expected) {
+        return false;
+      }
     }
 
-    if (actual !== expected) {
-      return false;
-    }
+    return true;
   }
 
-  return true;
-}
+  /**
+   * Utils.
+   */
 
-/**
- * Utils.
- */
+  function toKeyCode(name) {
+    name = toKeyName(name);
+    var code = CODES[name] || name.toUpperCase().charCodeAt(0);
+    return code;
+  }
 
-function toKeyCode(name) {
-  name = toKeyName(name);
-  var code = CODES[name] || name.toUpperCase().charCodeAt(0);
-  return code;
-}
+  function toKeyName(name) {
+    name = name.toLowerCase();
+    name = ALIASES[name] || name;
+    return name;
+  }
 
-function toKeyName(name) {
-  name = name.toLowerCase();
-  name = ALIASES[name] || name;
-  return name;
-}
+  /**
+   * Export.
+   */
 
-/**
- * Export.
- */
-
-exports.default = isHotkey;
-exports.isHotkey = isHotkey;
-exports.isCodeHotkey = isCodeHotkey;
-exports.isKeyHotkey = isKeyHotkey;
-exports.parseHotkey = parseHotkey;
-exports.compareHotkey = compareHotkey;
-exports.toKeyCode = toKeyCode;
-exports.toKeyName = toKeyName;
+  exports.default = isHotkey;
+  exports.isHotkey = isHotkey;
+  exports.isCodeHotkey = isCodeHotkey;
+  exports.isKeyHotkey = isKeyHotkey;
+  exports.parseHotkey = parseHotkey;
+  exports.compareHotkey = compareHotkey;
+  exports.toKeyCode = toKeyCode;
+  exports.toKeyName = toKeyName;
 });
 
 var isHotkey = unwrapExports(lib);
@@ -5472,56 +5623,42 @@ lib.compareHotkey;
 lib.toKeyCode;
 lib.toKeyName;
 
-const onKeyDownToggleElement = (editor, {
-  type,
-  options: {
-    hotkey
-  }
-}) => e => {
-  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);
-  if (!hotkey) return;
+const onKeyDownToggleElement =
+  (editor, { type, options: { hotkey } }) =>
+  (e) => {
+    const defaultType = getPluginType(editor, ELEMENT_DEFAULT);
+    if (!hotkey) return;
 
-  const hotkeys = castArray_1(hotkey);
+    const hotkeys = castArray_1(hotkey);
 
-  for (const _hotkey of hotkeys) {
-    if (isHotkey(_hotkey, e)) {
+    for (const _hotkey of hotkeys) {
+      if (isHotkey(_hotkey, e)) {
+        e.preventDefault();
+        toggleNodeType(editor, {
+          activeType: type,
+          inactiveType: defaultType,
+        });
+        return;
+      }
+    }
+  };
+
+const onKeyDownToggleMark =
+  (editor, { type, options: { hotkey, clear } }) =>
+  (e) => {
+    if (!hotkey) return;
+
+    if (isHotkey(hotkey, e)) {
       e.preventDefault();
-      toggleNodeType(editor, {
-        activeType: type,
-        inactiveType: defaultType
+      toggleMark(editor, {
+        key: type,
+        clear,
       });
-      return;
     }
-  }
-};
-
-const onKeyDownToggleMark = (editor, {
-  type,
-  options: {
-    hotkey,
-    clear
-  }
-}) => e => {
-  if (!hotkey) return;
-
-  if (isHotkey(hotkey, e)) {
-    e.preventDefault();
-    toggleMark(editor, {
-      key: type,
-      clear
-    });
-  }
-};
+  };
 
-const DefaultLeaf = ({
-  attributes,
-  children,
-  text,
-  leaf,
-  editor,
-  nodeProps,
-  ...props
-}) => /*#__PURE__*/React.createElement("span", _extends({}, attributes, props), children);
+const DefaultLeaf = ({ attributes, children, text, leaf, editor, nodeProps, ...props }) =>
+  /*#__PURE__*/ React.createElement("span", _extends({}, attributes, props), children);
 
 /**
  * A specialized version of `_.forEach` for arrays without support for
@@ -5534,7 +5671,7 @@ const DefaultLeaf = ({
  */
 function arrayEach(array, iteratee) {
   var index = -1,
-      length = array == null ? 0 : array.length;
+    length = array == null ? 0 : array.length;
 
   while (++index < length) {
     if (iteratee(array[index], index, array) === false) {
@@ -5556,12 +5693,12 @@ var _arrayEach = arrayEach;
  * @param {*} value The value to assign.
  */
 function baseAssignValue(object, key, value) {
-  if (key == '__proto__' && _defineProperty$1) {
+  if (key == "__proto__" && _defineProperty$1) {
     _defineProperty$1(object, key, {
-      'configurable': true,
-      'enumerable': true,
-      'value': value,
-      'writable': true
+      configurable: true,
+      enumerable: true,
+      value: value,
+      writable: true,
     });
   } else {
     object[key] = value;
@@ -5588,8 +5725,10 @@ var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
  */
 function assignValue(object, key, value) {
   var objValue = object[key];
-  if (!(hasOwnProperty$2.call(object, key) && eq_1(objValue, value)) ||
-      (value === undefined && !(key in object))) {
+  if (
+    !(hasOwnProperty$2.call(object, key) && eq_1(objValue, value)) ||
+    (value === undefined && !(key in object))
+  ) {
     _baseAssignValue(object, key, value);
   }
 }
@@ -5611,7 +5750,7 @@ function copyObject(source, props, object, customizer) {
   object || (object = {});
 
   var index = -1,
-      length = props.length;
+    length = props.length;
 
   while (++index < length) {
     var key = props[index];
@@ -5665,39 +5804,39 @@ function baseAssignIn(object, source) {
 var _baseAssignIn = baseAssignIn;
 
 var _cloneBuffer = createCommonjsModule(function (module, exports) {
-/** Detect free variable `exports`. */
-var freeExports = exports && !exports.nodeType && exports;
+  /** Detect free variable `exports`. */
+  var freeExports = exports && !exports.nodeType && exports;
 
-/** Detect free variable `module`. */
-var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
+  /** Detect free variable `module`. */
+  var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
 
-/** Detect the popular CommonJS extension `module.exports`. */
-var moduleExports = freeModule && freeModule.exports === freeExports;
+  /** Detect the popular CommonJS extension `module.exports`. */
+  var moduleExports = freeModule && freeModule.exports === freeExports;
 
-/** Built-in value references. */
-var Buffer = moduleExports ? _root.Buffer : undefined,
+  /** Built-in value references. */
+  var Buffer = moduleExports ? _root.Buffer : undefined,
     allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
 
-/**
- * Creates a clone of  `buffer`.
- *
- * @private
- * @param {Buffer} buffer The buffer to clone.
- * @param {boolean} [isDeep] Specify a deep clone.
- * @returns {Buffer} Returns the cloned buffer.
- */
-function cloneBuffer(buffer, isDeep) {
-  if (isDeep) {
-    return buffer.slice();
-  }
-  var length = buffer.length,
+  /**
+   * Creates a clone of  `buffer`.
+   *
+   * @private
+   * @param {Buffer} buffer The buffer to clone.
+   * @param {boolean} [isDeep] Specify a deep clone.
+   * @returns {Buffer} Returns the cloned buffer.
+   */
+  function cloneBuffer(buffer, isDeep) {
+    if (isDeep) {
+      return buffer.slice();
+    }
+    var length = buffer.length,
       result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
 
-  buffer.copy(result);
-  return result;
-}
+    buffer.copy(result);
+    return result;
+  }
 
-module.exports = cloneBuffer;
+  module.exports = cloneBuffer;
 });
 
 /**
@@ -5710,7 +5849,7 @@ module.exports = cloneBuffer;
  */
 function copyArray(source, array) {
   var index = -1,
-      length = source.length;
+    length = source.length;
 
   array || (array = Array(length));
   while (++index < length) {
@@ -5750,14 +5889,16 @@ var nativeGetSymbols = Object.getOwnPropertySymbols;
  * @param {Object} object The object to query.
  * @returns {Array} Returns the array of symbols.
  */
-var getSymbolsIn = !nativeGetSymbols ? stubArray_1 : function(object) {
-  var result = [];
-  while (object) {
-    _arrayPush(result, _getSymbols(object));
-    object = _getPrototype(object);
-  }
-  return result;
-};
+var getSymbolsIn = !nativeGetSymbols
+  ? stubArray_1
+  : function (object) {
+      var result = [];
+      while (object) {
+        _arrayPush(result, _getSymbols(object));
+        object = _getPrototype(object);
+      }
+      return result;
+    };
 
 var _getSymbolsIn = getSymbolsIn;
 
@@ -5804,10 +5945,10 @@ var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
  */
 function initCloneArray(array) {
   var length = array.length,
-      result = new array.constructor(length);
+    result = new array.constructor(length);
 
   // Add properties assigned by `RegExp#exec`.
-  if (length && typeof array[0] == 'string' && hasOwnProperty$1.call(array, 'index')) {
+  if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
     result.index = array.index;
     result.input = array.input;
   }
@@ -5866,7 +6007,7 @@ var _cloneRegExp = cloneRegExp;
 
 /** Used to convert symbols to primitives and strings. */
 var symbolProto = _Symbol ? _Symbol.prototype : undefined,
-    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
+  symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
 
 /**
  * Creates a clone of the `symbol` object.
@@ -5897,26 +6038,26 @@ function cloneTypedArray(typedArray, isDeep) {
 var _cloneTypedArray = cloneTypedArray;
 
 /** `Object#toString` result references. */
-var boolTag$1 = '[object Boolean]',
-    dateTag$1 = '[object Date]',
-    mapTag$2 = '[object Map]',
-    numberTag$1 = '[object Number]',
-    regexpTag$1 = '[object RegExp]',
-    setTag$2 = '[object Set]',
-    stringTag$1 = '[object String]',
-    symbolTag$1 = '[object Symbol]';
-
-var arrayBufferTag$1 = '[object ArrayBuffer]',
-    dataViewTag$1 = '[object DataView]',
-    float32Tag$1 = '[object Float32Array]',
-    float64Tag$1 = '[object Float64Array]',
-    int8Tag$1 = '[object Int8Array]',
-    int16Tag$1 = '[object Int16Array]',
-    int32Tag$1 = '[object Int32Array]',
-    uint8Tag$1 = '[object Uint8Array]',
-    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
-    uint16Tag$1 = '[object Uint16Array]',
-    uint32Tag$1 = '[object Uint32Array]';
+var boolTag$1 = "[object Boolean]",
+  dateTag$1 = "[object Date]",
+  mapTag$2 = "[object Map]",
+  numberTag$1 = "[object Number]",
+  regexpTag$1 = "[object RegExp]",
+  setTag$2 = "[object Set]",
+  stringTag$1 = "[object String]",
+  symbolTag$1 = "[object Symbol]";
+
+var arrayBufferTag$1 = "[object ArrayBuffer]",
+  dataViewTag$1 = "[object DataView]",
+  float32Tag$1 = "[object Float32Array]",
+  float64Tag$1 = "[object Float64Array]",
+  int8Tag$1 = "[object Int8Array]",
+  int16Tag$1 = "[object Int16Array]",
+  int32Tag$1 = "[object Int32Array]",
+  uint8Tag$1 = "[object Uint8Array]",
+  uint8ClampedTag$1 = "[object Uint8ClampedArray]",
+  uint16Tag$1 = "[object Uint16Array]",
+  uint32Tag$1 = "[object Uint32Array]";
 
 /**
  * Initializes an object clone based on its `toStringTag`.
@@ -5943,13 +6084,19 @@ function initCloneByTag(object, tag, isDeep) {
     case dataViewTag$1:
       return _cloneDataView(object, isDeep);
 
-    case float32Tag$1: case float64Tag$1:
-    case int8Tag$1: case int16Tag$1: case int32Tag$1:
-    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
+    case float32Tag$1:
+    case float64Tag$1:
+    case int8Tag$1:
+    case int16Tag$1:
+    case int32Tag$1:
+    case uint8Tag$1:
+    case uint8ClampedTag$1:
+    case uint16Tag$1:
+    case uint32Tag$1:
       return _cloneTypedArray(object, isDeep);
 
     case mapTag$2:
-      return new Ctor;
+      return new Ctor();
 
     case numberTag$1:
     case stringTag$1:
@@ -5959,7 +6106,7 @@ function initCloneByTag(object, tag, isDeep) {
       return _cloneRegExp(object);
 
     case setTag$2:
-      return new Ctor;
+      return new Ctor();
 
     case symbolTag$1:
       return _cloneSymbol(object);
@@ -5979,9 +6126,9 @@ var objectCreate = Object.create;
  * @param {Object} proto The object to inherit from.
  * @returns {Object} Returns the new object.
  */
-var baseCreate = (function() {
+var baseCreate = (function () {
   function object() {}
-  return function(proto) {
+  return function (proto) {
     if (!isObject_1(proto)) {
       return {};
     }
@@ -5989,11 +6136,11 @@ var baseCreate = (function() {
       return objectCreate(proto);
     }
     object.prototype = proto;
-    var result = new object;
+    var result = new object();
     object.prototype = undefined;
     return result;
   };
-}());
+})();
 
 var _baseCreate = baseCreate;
 
@@ -6005,7 +6152,7 @@ var _baseCreate = baseCreate;
  * @returns {Object} Returns the initialized clone.
  */
 function initCloneObject(object) {
-  return (typeof object.constructor == 'function' && !_isPrototype(object))
+  return typeof object.constructor == "function" && !_isPrototype(object)
     ? _baseCreate(_getPrototype(object))
     : {};
 }
@@ -6013,7 +6160,7 @@ function initCloneObject(object) {
 var _initCloneObject = initCloneObject;
 
 /** `Object#toString` result references. */
-var mapTag$1 = '[object Map]';
+var mapTag$1 = "[object Map]";
 
 /**
  * The base implementation of `_.isMap` without Node.js optimizations.
@@ -6053,7 +6200,7 @@ var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;
 var isMap_1 = isMap;
 
 /** `Object#toString` result references. */
-var setTag$1 = '[object Set]';
+var setTag$1 = "[object Set]";
 
 /**
  * The base implementation of `_.isSet` without Node.js optimizations.
@@ -6094,53 +6241,64 @@ var isSet_1 = isSet;
 
 /** Used to compose bitmasks for cloning. */
 var CLONE_DEEP_FLAG$2 = 1,
-    CLONE_FLAT_FLAG$1 = 2,
-    CLONE_SYMBOLS_FLAG$2 = 4;
+  CLONE_FLAT_FLAG$1 = 2,
+  CLONE_SYMBOLS_FLAG$2 = 4;
 
 /** `Object#toString` result references. */
-var argsTag = '[object Arguments]',
-    arrayTag = '[object Array]',
-    boolTag = '[object Boolean]',
-    dateTag = '[object Date]',
-    errorTag = '[object Error]',
-    funcTag = '[object Function]',
-    genTag = '[object GeneratorFunction]',
-    mapTag = '[object Map]',
-    numberTag = '[object Number]',
-    objectTag$1 = '[object Object]',
-    regexpTag = '[object RegExp]',
-    setTag = '[object Set]',
-    stringTag = '[object String]',
-    symbolTag = '[object Symbol]',
-    weakMapTag = '[object WeakMap]';
-
-var arrayBufferTag = '[object ArrayBuffer]',
-    dataViewTag = '[object DataView]',
-    float32Tag = '[object Float32Array]',
-    float64Tag = '[object Float64Array]',
-    int8Tag = '[object Int8Array]',
-    int16Tag = '[object Int16Array]',
-    int32Tag = '[object Int32Array]',
-    uint8Tag = '[object Uint8Array]',
-    uint8ClampedTag = '[object Uint8ClampedArray]',
-    uint16Tag = '[object Uint16Array]',
-    uint32Tag = '[object Uint32Array]';
+var argsTag = "[object Arguments]",
+  arrayTag = "[object Array]",
+  boolTag = "[object Boolean]",
+  dateTag = "[object Date]",
+  errorTag = "[object Error]",
+  funcTag = "[object Function]",
+  genTag = "[object GeneratorFunction]",
+  mapTag = "[object Map]",
+  numberTag = "[object Number]",
+  objectTag$1 = "[object Object]",
+  regexpTag = "[object RegExp]",
+  setTag = "[object Set]",
+  stringTag = "[object String]",
+  symbolTag = "[object Symbol]",
+  weakMapTag = "[object WeakMap]";
+
+var arrayBufferTag = "[object ArrayBuffer]",
+  dataViewTag = "[object DataView]",
+  float32Tag = "[object Float32Array]",
+  float64Tag = "[object Float64Array]",
+  int8Tag = "[object Int8Array]",
+  int16Tag = "[object Int16Array]",
+  int32Tag = "[object Int32Array]",
+  uint8Tag = "[object Uint8Array]",
+  uint8ClampedTag = "[object Uint8ClampedArray]",
+  uint16Tag = "[object Uint16Array]",
+  uint32Tag = "[object Uint32Array]";
 
 /** Used to identify `toStringTag` values supported by `_.clone`. */
 var cloneableTags = {};
-cloneableTags[argsTag] = cloneableTags[arrayTag] =
-cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
-cloneableTags[boolTag] = cloneableTags[dateTag] =
-cloneableTags[float32Tag] = cloneableTags[float64Tag] =
-cloneableTags[int8Tag] = cloneableTags[int16Tag] =
-cloneableTags[int32Tag] = cloneableTags[mapTag] =
-cloneableTags[numberTag] = cloneableTags[objectTag$1] =
-cloneableTags[regexpTag] = cloneableTags[setTag] =
-cloneableTags[stringTag] = cloneableTags[symbolTag] =
-cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
-cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
-cloneableTags[errorTag] = cloneableTags[funcTag] =
-cloneableTags[weakMapTag] = false;
+cloneableTags[argsTag] =
+  cloneableTags[arrayTag] =
+  cloneableTags[arrayBufferTag] =
+  cloneableTags[dataViewTag] =
+  cloneableTags[boolTag] =
+  cloneableTags[dateTag] =
+  cloneableTags[float32Tag] =
+  cloneableTags[float64Tag] =
+  cloneableTags[int8Tag] =
+  cloneableTags[int16Tag] =
+  cloneableTags[int32Tag] =
+  cloneableTags[mapTag] =
+  cloneableTags[numberTag] =
+  cloneableTags[objectTag$1] =
+  cloneableTags[regexpTag] =
+  cloneableTags[setTag] =
+  cloneableTags[stringTag] =
+  cloneableTags[symbolTag] =
+  cloneableTags[uint8Tag] =
+  cloneableTags[uint8ClampedTag] =
+  cloneableTags[uint16Tag] =
+  cloneableTags[uint32Tag] =
+    true;
+cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
 
 /**
  * The base implementation of `_.clone` and `_.cloneDeep` which tracks
@@ -6160,9 +6318,9 @@ cloneableTags[weakMapTag] = false;
  */
 function baseClone(value, bitmask, customizer, key, object, stack) {
   var result,
-      isDeep = bitmask & CLONE_DEEP_FLAG$2,
-      isFlat = bitmask & CLONE_FLAT_FLAG$1,
-      isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
+    isDeep = bitmask & CLONE_DEEP_FLAG$2,
+    isFlat = bitmask & CLONE_FLAT_FLAG$1,
+    isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
 
   if (customizer) {
     result = object ? customizer(value, key, object, stack) : customizer(value);
@@ -6181,13 +6339,13 @@ function baseClone(value, bitmask, customizer, key, object, stack) {
     }
   } else {
     var tag = _getTag(value),
-        isFunc = tag == funcTag || tag == genTag;
+      isFunc = tag == funcTag || tag == genTag;
 
     if (isBuffer_1(value)) {
       return _cloneBuffer(value, isDeep);
     }
     if (tag == objectTag$1 || tag == argsTag || (isFunc && !object)) {
-      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
+      result = isFlat || isFunc ? {} : _initCloneObject(value);
       if (!isDeep) {
         return isFlat
           ? _copySymbolsIn(value, _baseAssignIn(result, value))
@@ -6201,7 +6359,7 @@ function baseClone(value, bitmask, customizer, key, object, stack) {
     }
   }
   // Check for circular references and return its corresponding clone.
-  stack || (stack = new _Stack);
+  stack || (stack = new _Stack());
   var stacked = stack.get(value);
   if (stacked) {
     return stacked;
@@ -6209,21 +6367,19 @@ function baseClone(value, bitmask, customizer, key, object, stack) {
   stack.set(value, result);
 
   if (isSet_1(value)) {
-    value.forEach(function(subValue) {
+    value.forEach(function (subValue) {
       result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
     });
   } else if (isMap_1(value)) {
-    value.forEach(function(subValue, key) {
+    value.forEach(function (subValue, key) {
       result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
     });
   }
 
-  var keysFunc = isFull
-    ? (isFlat ? _getAllKeysIn : _getAllKeys)
-    : (isFlat ? keysIn_1 : keys_1);
+  var keysFunc = isFull ? (isFlat ? _getAllKeysIn : _getAllKeys) : isFlat ? keysIn_1 : keys_1;
 
   var props = isArr ? undefined : keysFunc(value);
-  _arrayEach(props || value, function(subValue, key) {
+  _arrayEach(props || value, function (subValue, key) {
     if (props) {
       key = subValue;
       subValue = value[key];
@@ -6268,16 +6424,16 @@ var last_1 = last;
  */
 function baseSlice(array, start, end) {
   var index = -1,
-      length = array.length;
+    length = array.length;
 
   if (start < 0) {
-    start = -start > length ? 0 : (length + start);
+    start = -start > length ? 0 : length + start;
   }
   end = end > length ? length : end;
   if (end < 0) {
     end += length;
   }
-  length = start > end ? 0 : ((end - start) >>> 0);
+  length = start > end ? 0 : (end - start) >>> 0;
   start >>>= 0;
 
   var result = Array(length);
@@ -6320,11 +6476,11 @@ function baseUnset(object, path) {
 var _baseUnset = baseUnset;
 
 /** `Object#toString` result references. */
-var objectTag = '[object Object]';
+var objectTag = "[object Object]";
 
 /** Used for built-in method references. */
 var funcProto = Function.prototype,
-    objectProto = Object.prototype;
+  objectProto = Object.prototype;
 
 /** Used to resolve the decompiled source of functions. */
 var funcToString = funcProto.toString;
@@ -6371,9 +6527,10 @@ function isPlainObject$1(value) {
   if (proto === null) {
     return true;
   }
-  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
-  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
-    funcToString.call(Ctor) == objectCtorString;
+  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
+  return (
+    typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString
+  );
 }
 
 var isPlainObject_1 = isPlainObject$1;
@@ -6404,8 +6561,11 @@ var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
  * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
  */
 function isFlattenable(value) {
-  return isArray_1(value) || isArguments_1(value) ||
-    !!(spreadableSymbol && value && value[spreadableSymbol]);
+  return (
+    isArray_1(value) ||
+    isArguments_1(value) ||
+    !!(spreadableSymbol && value && value[spreadableSymbol])
+  );
 }
 
 var _isFlattenable = isFlattenable;
@@ -6423,7 +6583,7 @@ var _isFlattenable = isFlattenable;
  */
 function baseFlatten(array, depth, predicate, isStrict, result) {
   var index = -1,
-      length = array.length;
+    length = array.length;
 
   predicate || (predicate = _isFlattenable);
   result || (result = []);
@@ -6475,15 +6635,15 @@ var flatten_1 = flatten;
  * @returns {Function} Returns the new function.
  */
 function flatRest(func) {
-  return _setToString(_overRest(func, undefined, flatten_1), func + '');
+  return _setToString(_overRest(func, undefined, flatten_1), func + "");
 }
 
 var _flatRest = flatRest;
 
 /** Used to compose bitmasks for cloning. */
 var CLONE_DEEP_FLAG$1 = 1,
-    CLONE_FLAT_FLAG = 2,
-    CLONE_SYMBOLS_FLAG$1 = 4;
+  CLONE_FLAT_FLAG = 2,
+  CLONE_SYMBOLS_FLAG$1 = 4;
 
 /**
  * The opposite of `_.pick`; this method creates an object composed of the
@@ -6505,20 +6665,24 @@ var CLONE_DEEP_FLAG$1 = 1,
  * _.omit(object, ['a', 'c']);
  * // => { 'b': '2' }
  */
-var omit = _flatRest(function(object, paths) {
+var omit = _flatRest(function (object, paths) {
   var result = {};
   if (object == null) {
     return result;
   }
   var isDeep = false;
-  paths = _arrayMap(paths, function(path) {
+  paths = _arrayMap(paths, function (path) {
     path = _castPath(path, object);
     isDeep || (isDeep = path.length > 1);
     return path;
   });
   _copyObject(object, _getAllKeysIn(object), result);
   if (isDeep) {
-    result = _baseClone(result, CLONE_DEEP_FLAG$1 | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG$1, _customOmitClone);
+    result = _baseClone(
+      result,
+      CLONE_DEEP_FLAG$1 | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG$1,
+      _customOmitClone
+    );
   }
   var length = paths.length;
   while (length--) {
@@ -6530,81 +6694,80 @@ var omit = _flatRest(function(object, paths) {
 var omit_1 = omit;
 
 var vanilla = createCommonjsModule(function (module, exports) {
+  Object.defineProperty(exports, "__esModule", { value: true });
 
-Object.defineProperty(exports, '__esModule', { value: true });
-
-function create(createState) {
-  var state;
-  var listeners = new Set();
+  function create(createState) {
+    var state;
+    var listeners = new Set();
 
-  var setState = function setState(partial, replace) {
-    var nextState = typeof partial === 'function' ? partial(state) : partial;
+    var setState = function setState(partial, replace) {
+      var nextState = typeof partial === "function" ? partial(state) : partial;
 
-    if (nextState !== state) {
-      var _previousState = state;
-      state = replace ? nextState : Object.assign({}, state, nextState);
-      listeners.forEach(function (listener) {
-        return listener(state, _previousState);
-      });
-    }
-  };
+      if (nextState !== state) {
+        var _previousState = state;
+        state = replace ? nextState : Object.assign({}, state, nextState);
+        listeners.forEach(function (listener) {
+          return listener(state, _previousState);
+        });
+      }
+    };
 
-  var getState = function getState() {
-    return state;
-  };
+    var getState = function getState() {
+      return state;
+    };
 
-  var subscribeWithSelector = function subscribeWithSelector(listener, selector, equalityFn) {
-    if (selector === void 0) {
-      selector = getState;
-    }
+    var subscribeWithSelector = function subscribeWithSelector(listener, selector, equalityFn) {
+      if (selector === void 0) {
+        selector = getState;
+      }
 
-    if (equalityFn === void 0) {
-      equalityFn = Object.is;
-    }
+      if (equalityFn === void 0) {
+        equalityFn = Object.is;
+      }
 
-    var currentSlice = selector(state);
+      var currentSlice = selector(state);
 
-    function listenerToAdd() {
-      var nextSlice = selector(state);
+      function listenerToAdd() {
+        var nextSlice = selector(state);
 
-      if (!equalityFn(currentSlice, nextSlice)) {
-        var _previousSlice = currentSlice;
-        listener(currentSlice = nextSlice, _previousSlice);
+        if (!equalityFn(currentSlice, nextSlice)) {
+          var _previousSlice = currentSlice;
+          listener((currentSlice = nextSlice), _previousSlice);
+        }
       }
-    }
 
-    listeners.add(listenerToAdd);
-    return function () {
-      return listeners.delete(listenerToAdd);
+      listeners.add(listenerToAdd);
+      return function () {
+        return listeners.delete(listenerToAdd);
+      };
     };
-  };
 
-  var subscribe = function subscribe(listener, selector, equalityFn) {
-    if (selector || equalityFn) {
-      return subscribeWithSelector(listener, selector, equalityFn);
-    }
+    var subscribe = function subscribe(listener, selector, equalityFn) {
+      if (selector || equalityFn) {
+        return subscribeWithSelector(listener, selector, equalityFn);
+      }
 
-    listeners.add(listener);
-    return function () {
-      return listeners.delete(listener);
+      listeners.add(listener);
+      return function () {
+        return listeners.delete(listener);
+      };
     };
-  };
 
-  var destroy = function destroy() {
-    return listeners.clear();
-  };
+    var destroy = function destroy() {
+      return listeners.clear();
+    };
 
-  var api = {
-    setState: setState,
-    getState: getState,
-    subscribe: subscribe,
-    destroy: destroy
-  };
-  state = createState(setState, getState, api);
-  return api;
-}
+    var api = {
+      setState: setState,
+      getState: getState,
+      subscribe: subscribe,
+      destroy: destroy,
+    };
+    state = createState(setState, getState, api);
+    return api;
+  }
 
-exports.default = create;
+  exports.default = create;
 });
 
 var createVanillaStore = unwrapExports(vanilla);
@@ -6642,10 +6805,7 @@ const getEventEditorState = () => eventEditorStore.getState();
  */
 
 const getPlateId = () => {
-  const {
-    blur,
-    focus
-  } = getEventEditorState();
+  const { blur, focus } = getEventEditorState();
   if (focus) return focus;
   if (blur) return blur;
   const state = plateStore.getState();
@@ -6659,7 +6819,7 @@ const getPlateId = () => {
  * Else, get the first state.
  */
 
-const getPlateState = id => {
+const getPlateState = (id) => {
   const state = plateStore.getState();
   if (id) return state[id];
   const firstId = getPlateId();
@@ -6667,59 +6827,216 @@ const getPlateState = id => {
   return null;
 };
 
-const getPlateEditorRef = id => {
+const getPlateEditorRef = (id) => {
   var _getPlateState;
 
-  return (_getPlateState = getPlateState(id)) === null || _getPlateState === void 0 ? void 0 : _getPlateState.editor;
+  return (_getPlateState = getPlateState(id)) === null || _getPlateState === void 0
+    ? void 0
+    : _getPlateState.editor;
 };
 /**
  * Get editor ref which is never updated.
  */
 
-const usePlateEditorRef = id => usePlateStore(() => getPlateEditorRef(id));
-
-const usePlateKey = (key, id) => usePlateStore(useCallback(() => {
-  var _getPlateState;
-
-  return (_getPlateState = getPlateState(id)) === null || _getPlateState === void 0 ? void 0 : _getPlateState[key];
-}, [id, key]));
-
-const DOM_HANDLERS = [// Clipboard Events
-'onCopy', 'onCopyCapture', 'onCut', 'onCutCapture', 'onPaste', 'onPasteCapture', // Composition Events
-'onCompositionEnd', 'onCompositionEndCapture', 'onCompositionStart', 'onCompositionStartCapture', 'onCompositionUpdate', 'onCompositionUpdateCapture', // Focus Events
-'onFocus', 'onFocusCapture', 'onBlur', 'onBlurCapture', // Form Events
-'onDOMBeforeInput', 'onBeforeInput', 'onBeforeInputCapture', 'onInput', 'onInputCapture', 'onReset', 'onResetCapture', 'onSubmit', 'onSubmitCapture', 'onInvalid', 'onInvalidCapture', // Image Events
-'onLoad', 'onLoadCapture', // Keyboard Events
-'onKeyDown', 'onKeyDownCapture', 'onKeyPress', 'onKeyPressCapture', 'onKeyUp', 'onKeyUpCapture', // Media Events
-'onAbort', 'onAbortCapture', 'onCanPlay', 'onCanPlayCapture', 'onCanPlayThrough', 'onCanPlayThroughCapture', 'onDurationChange', 'onDurationChangeCapture', 'onEmptied', 'onEmptiedCapture', 'onEncrypted', 'onEncryptedCapture', 'onEnded', 'onEndedCapture', 'onLoadedData', 'onLoadedDataCapture', 'onLoadedMetadata', 'onLoadedMetadataCapture', 'onLoadStart', 'onLoadStartCapture', 'onPause', 'onPauseCapture', 'onPlay', 'onPlayCapture', 'onPlaying', 'onPlayingCapture', 'onProgress', 'onProgressCapture', 'onRateChange', 'onRateChangeCapture', 'onSeeked', 'onSeekedCapture', 'onSeeking', 'onSeekingCapture', 'onStalled', 'onStalledCapture', 'onSuspend', 'onSuspendCapture', 'onTimeUpdate', 'onTimeUpdateCapture', 'onVolumeChange', 'onVolumeChangeCapture', 'onWaiting', 'onWaitingCapture', // MouseEvents
-'onAuxClick', 'onAuxClickCapture', 'onClick', 'onClickCapture', 'onContextMenu', 'onContextMenuCapture', 'onDoubleClick', 'onDoubleClickCapture', 'onDrag', 'onDragCapture', 'onDragEnd', 'onDragEndCapture', 'onDragEnter', 'onDragEnterCapture', 'onDragExit', 'onDragExitCapture', 'onDragLeave', 'onDragLeaveCapture', 'onDragOver', 'onDragOverCapture', 'onDragStart', 'onDragStartCapture', 'onDrop', 'onDropCapture', 'onMouseDown', 'onMouseDownCapture', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseMoveCapture', 'onMouseOut', 'onMouseOutCapture', 'onMouseOver', 'onMouseOverCapture', 'onMouseUp', 'onMouseUpCapture', // Selection Events
-'onSelect', 'onSelectCapture', // Touch Events
-'onTouchCancel', 'onTouchCancelCapture', 'onTouchEnd', 'onTouchEndCapture', 'onTouchMove', 'onTouchMoveCapture', 'onTouchStart', 'onTouchStartCapture', // Pointer Events
-'onPointerDown', 'onPointerDownCapture', 'onPointerMove', 'onPointerMoveCapture', 'onPointerUp', 'onPointerUpCapture', 'onPointerCancel', 'onPointerCancelCapture', 'onPointerEnter', 'onPointerEnterCapture', 'onPointerLeave', 'onPointerLeaveCapture', 'onPointerOver', 'onPointerOverCapture', 'onPointerOut', 'onPointerOutCapture', 'onGotPointerCapture', 'onGotPointerCaptureCapture', 'onLostPointerCapture', 'onLostPointerCaptureCapture', // UI Events
-'onScroll', 'onScrollCapture', // Wheel Events
-'onWheel', 'onWheelCapture', // Animation Events
-'onAnimationStart', 'onAnimationStartCapture', 'onAnimationEnd', 'onAnimationEndCapture', 'onAnimationIteration', 'onAnimationIterationCapture', // Transition Events
-'onTransitionEnd', 'onTransitionEndCapture'];
+const usePlateEditorRef = (id) => usePlateStore(() => getPlateEditorRef(id));
+
+const usePlateKey = (key, id) =>
+  usePlateStore(
+    useCallback(() => {
+      var _getPlateState;
+
+      return (_getPlateState = getPlateState(id)) === null || _getPlateState === void 0
+        ? void 0
+        : _getPlateState[key];
+    }, [id, key])
+  );
+
+const DOM_HANDLERS = [
+  // Clipboard Events
+  "onCopy",
+  "onCopyCapture",
+  "onCut",
+  "onCutCapture",
+  "onPaste",
+  "onPasteCapture", // Composition Events
+  "onCompositionEnd",
+  "onCompositionEndCapture",
+  "onCompositionStart",
+  "onCompositionStartCapture",
+  "onCompositionUpdate",
+  "onCompositionUpdateCapture", // Focus Events
+  "onFocus",
+  "onFocusCapture",
+  "onBlur",
+  "onBlurCapture", // Form Events
+  "onDOMBeforeInput",
+  "onBeforeInput",
+  "onBeforeInputCapture",
+  "onInput",
+  "onInputCapture",
+  "onReset",
+  "onResetCapture",
+  "onSubmit",
+  "onSubmitCapture",
+  "onInvalid",
+  "onInvalidCapture", // Image Events
+  "onLoad",
+  "onLoadCapture", // Keyboard Events
+  "onKeyDown",
+  "onKeyDownCapture",
+  "onKeyPress",
+  "onKeyPressCapture",
+  "onKeyUp",
+  "onKeyUpCapture", // Media Events
+  "onAbort",
+  "onAbortCapture",
+  "onCanPlay",
+  "onCanPlayCapture",
+  "onCanPlayThrough",
+  "onCanPlayThroughCapture",
+  "onDurationChange",
+  "onDurationChangeCapture",
+  "onEmptied",
+  "onEmptiedCapture",
+  "onEncrypted",
+  "onEncryptedCapture",
+  "onEnded",
+  "onEndedCapture",
+  "onLoadedData",
+  "onLoadedDataCapture",
+  "onLoadedMetadata",
+  "onLoadedMetadataCapture",
+  "onLoadStart",
+  "onLoadStartCapture",
+  "onPause",
+  "onPauseCapture",
+  "onPlay",
+  "onPlayCapture",
+  "onPlaying",
+  "onPlayingCapture",
+  "onProgress",
+  "onProgressCapture",
+  "onRateChange",
+  "onRateChangeCapture",
+  "onSeeked",
+  "onSeekedCapture",
+  "onSeeking",
+  "onSeekingCapture",
+  "onStalled",
+  "onStalledCapture",
+  "onSuspend",
+  "onSuspendCapture",
+  "onTimeUpdate",
+  "onTimeUpdateCapture",
+  "onVolumeChange",
+  "onVolumeChangeCapture",
+  "onWaiting",
+  "onWaitingCapture", // MouseEvents
+  "onAuxClick",
+  "onAuxClickCapture",
+  "onClick",
+  "onClickCapture",
+  "onContextMenu",
+  "onContextMenuCapture",
+  "onDoubleClick",
+  "onDoubleClickCapture",
+  "onDrag",
+  "onDragCapture",
+  "onDragEnd",
+  "onDragEndCapture",
+  "onDragEnter",
+  "onDragEnterCapture",
+  "onDragExit",
+  "onDragExitCapture",
+  "onDragLeave",
+  "onDragLeaveCapture",
+  "onDragOver",
+  "onDragOverCapture",
+  "onDragStart",
+  "onDragStartCapture",
+  "onDrop",
+  "onDropCapture",
+  "onMouseDown",
+  "onMouseDownCapture",
+  "onMouseEnter",
+  "onMouseLeave",
+  "onMouseMove",
+  "onMouseMoveCapture",
+  "onMouseOut",
+  "onMouseOutCapture",
+  "onMouseOver",
+  "onMouseOverCapture",
+  "onMouseUp",
+  "onMouseUpCapture", // Selection Events
+  "onSelect",
+  "onSelectCapture", // Touch Events
+  "onTouchCancel",
+  "onTouchCancelCapture",
+  "onTouchEnd",
+  "onTouchEndCapture",
+  "onTouchMove",
+  "onTouchMoveCapture",
+  "onTouchStart",
+  "onTouchStartCapture", // Pointer Events
+  "onPointerDown",
+  "onPointerDownCapture",
+  "onPointerMove",
+  "onPointerMoveCapture",
+  "onPointerUp",
+  "onPointerUpCapture",
+  "onPointerCancel",
+  "onPointerCancelCapture",
+  "onPointerEnter",
+  "onPointerEnterCapture",
+  "onPointerLeave",
+  "onPointerLeaveCapture",
+  "onPointerOver",
+  "onPointerOverCapture",
+  "onPointerOut",
+  "onPointerOutCapture",
+  "onGotPointerCapture",
+  "onGotPointerCaptureCapture",
+  "onLostPointerCapture",
+  "onLostPointerCaptureCapture", // UI Events
+  "onScroll",
+  "onScrollCapture", // Wheel Events
+  "onWheel",
+  "onWheelCapture", // Animation Events
+  "onAnimationStart",
+  "onAnimationStartCapture",
+  "onAnimationEnd",
+  "onAnimationEndCapture",
+  "onAnimationIteration",
+  "onAnimationIterationCapture", // Transition Events
+  "onTransitionEnd",
+  "onTransitionEndCapture",
+];
 
 /**
  * @see {@link Decorate}.
  * Optimization: return undefined if empty list so Editable uses a memo.
  */
-const pipeDecorate = editor => {
-  const decorates = editor.plugins.flatMap(plugin => {
+const pipeDecorate = (editor) => {
+  const decorates = editor.plugins.flatMap((plugin) => {
     var _plugin$decorate, _plugin$decorate2;
 
-    return (_plugin$decorate = (_plugin$decorate2 = plugin.decorate) === null || _plugin$decorate2 === void 0 ? void 0 : _plugin$decorate2.call(plugin, editor, plugin)) !== null && _plugin$decorate !== void 0 ? _plugin$decorate : [];
+    return (_plugin$decorate =
+      (_plugin$decorate2 = plugin.decorate) === null || _plugin$decorate2 === void 0
+        ? void 0
+        : _plugin$decorate2.call(plugin, editor, plugin)) !== null && _plugin$decorate !== void 0
+      ? _plugin$decorate
+      : [];
   });
   if (!decorates.length) return;
-  return entry => {
+  return (entry) => {
     let ranges = [];
 
-    const addRanges = newRanges => {
-      if (newRanges !== null && newRanges !== void 0 && newRanges.length) ranges = [...ranges, ...newRanges];
+    const addRanges = (newRanges) => {
+      if (newRanges !== null && newRanges !== void 0 && newRanges.length)
+        ranges = [...ranges, ...newRanges];
     };
 
-    decorates.forEach(decorate => {
+    decorates.forEach((decorate) => {
       addRanges(decorate(entry));
     });
     return ranges;
@@ -6735,7 +7052,6 @@ const isEventHandled = (event, handler) => {
   } // The custom event handler may return a boolean to specify whether the event
   // shall be treated as being handled or not.
 
-
   const shouldTreatEventAsHandled = handler(event);
 
   if (shouldTreatEventAsHandled != null) {
@@ -6752,20 +7068,27 @@ const isEventHandled = (event, handler) => {
  * - Any handler returning true will stop the next handlers to be called, including slate internal handler.
  */
 
-const pipeHandler = (editor, {
-  editableProps,
-  handlerKey
-}) => {
+const pipeHandler = (editor, { editableProps, handlerKey }) => {
   let pluginsHandlers = [];
-  pluginsHandlers = editor.plugins.flatMap(plugin => {
+  pluginsHandlers = editor.plugins.flatMap((plugin) => {
     var _plugin$handlers$hand, _plugin$handlers, _plugin$handlers$hand2;
 
-    return (_plugin$handlers$hand = (_plugin$handlers = plugin.handlers) === null || _plugin$handlers === void 0 ? void 0 : (_plugin$handlers$hand2 = _plugin$handlers[handlerKey]) === null || _plugin$handlers$hand2 === void 0 ? void 0 : _plugin$handlers$hand2.call(_plugin$handlers, editor, plugin)) !== null && _plugin$handlers$hand !== void 0 ? _plugin$handlers$hand : [];
+    return (_plugin$handlers$hand =
+      (_plugin$handlers = plugin.handlers) === null || _plugin$handlers === void 0
+        ? void 0
+        : (_plugin$handlers$hand2 = _plugin$handlers[handlerKey]) === null ||
+          _plugin$handlers$hand2 === void 0
+        ? void 0
+        : _plugin$handlers$hand2.call(_plugin$handlers, editor, plugin)) !== null &&
+      _plugin$handlers$hand !== void 0
+      ? _plugin$handlers$hand
+      : [];
   });
-  const propsHandler = editableProps === null || editableProps === void 0 ? void 0 : editableProps[handlerKey];
+  const propsHandler =
+    editableProps === null || editableProps === void 0 ? void 0 : editableProps[handlerKey];
   if (!pluginsHandlers.length && !propsHandler) return;
-  return event => {
-    const eventIsHandled = pluginsHandlers.some(handler => isEventHandled(event, handler));
+  return (event) => {
+    const eventIsHandled = pluginsHandlers.some((handler) => isEventHandled(event, handler));
     if (eventIsHandled) return true;
     return isEventHandled(event, propsHandler);
   };
@@ -6778,20 +7101,10 @@ const pipeHandler = (editor, {
  * If `classNames[value]` is defined, override `className` with it.
  * If `styleKey` is defined, override `style` with `[styleKey]: value`.
  */
-const pluginInjectProps = (editor, {
-  key,
-  inject: {
-    props
-  }
-}, nodeProps) => {
+const pluginInjectProps = (editor, { key, inject: { props } }, nodeProps) => {
   var _transformNodeValue;
 
-  const {
-    element,
-    text,
-    className,
-    style
-  } = nodeProps;
+  const { element, text, className, style } = nodeProps;
   const node = element !== null && element !== void 0 ? element : text;
   if (!node) return;
   if (!props) return;
@@ -6804,7 +7117,7 @@ const pluginInjectProps = (editor, {
     transformNodeValue,
     transformStyle,
     validNodeValues,
-    defaultNodeValue
+    defaultNodeValue,
   } = props;
 
   if (validTypes && node.type && !validTypes.includes(node.type)) {
@@ -6813,32 +7126,56 @@ const pluginInjectProps = (editor, {
 
   const nodeValue = node[nodeKey]; // early return if there is now reason to add styles
 
-  if (!nodeValue || validNodeValues && !validNodeValues.includes(nodeValue) || nodeValue === defaultNodeValue) {
+  if (
+    !nodeValue ||
+    (validNodeValues && !validNodeValues.includes(nodeValue)) ||
+    nodeValue === defaultNodeValue
+  ) {
     return;
   }
 
   const res = {};
-  const transformOptions = { ...nodeProps,
-    nodeValue
-  };
-  const value = (_transformNodeValue = transformNodeValue === null || transformNodeValue === void 0 ? void 0 : transformNodeValue(transformOptions)) !== null && _transformNodeValue !== void 0 ? _transformNodeValue : nodeValue;
+  const transformOptions = { ...nodeProps, nodeValue };
+  const value =
+    (_transformNodeValue =
+      transformNodeValue === null || transformNodeValue === void 0
+        ? void 0
+        : transformNodeValue(transformOptions)) !== null && _transformNodeValue !== void 0
+      ? _transformNodeValue
+      : nodeValue;
 
   if (element) {
     res.className = clsx(className, `slate-${nodeKey}-${nodeValue}`);
   }
 
-  if (classNames !== null && classNames !== void 0 && classNames[nodeValue] || transformClassName) {
+  if (
+    (classNames !== null && classNames !== void 0 && classNames[nodeValue]) ||
+    transformClassName
+  ) {
     var _transformClassName;
 
-    res.className = (_transformClassName = transformClassName === null || transformClassName === void 0 ? void 0 : transformClassName(transformOptions)) !== null && _transformClassName !== void 0 ? _transformClassName : clsx(className, classNames === null || classNames === void 0 ? void 0 : classNames[value]);
+    res.className =
+      (_transformClassName =
+        transformClassName === null || transformClassName === void 0
+          ? void 0
+          : transformClassName(transformOptions)) !== null && _transformClassName !== void 0
+        ? _transformClassName
+        : clsx(
+            className,
+            classNames === null || classNames === void 0 ? void 0 : classNames[value]
+          );
   }
 
   if (styleKey) {
     var _transformStyle;
 
-    res.style = (_transformStyle = transformStyle === null || transformStyle === void 0 ? void 0 : transformStyle(transformOptions)) !== null && _transformStyle !== void 0 ? _transformStyle : { ...style,
-      [styleKey]: value
-    };
+    res.style =
+      (_transformStyle =
+        transformStyle === null || transformStyle === void 0
+          ? void 0
+          : transformStyle(transformOptions)) !== null && _transformStyle !== void 0
+        ? _transformStyle
+        : { ...style, [styleKey]: value };
   }
 
   return res;
@@ -6849,26 +7186,22 @@ const pluginInjectProps = (editor, {
  */
 
 const pipeInjectProps = (editor, nodeProps) => {
-  editor.plugins.forEach(plugin => {
+  editor.plugins.forEach((plugin) => {
     if (plugin.inject.props) {
       const props = pluginInjectProps(editor, plugin, nodeProps);
 
       if (props) {
-        nodeProps = { ...nodeProps,
-          ...props
-        };
+        nodeProps = { ...nodeProps, ...props };
       }
     }
   });
-  return { ...nodeProps,
-    editor
-  };
+  return { ...nodeProps, editor };
 };
 
 /**
  * Get slate class name: slate-<type>
  */
-const getSlateClass = type => `slate-${type}`;
+const getSlateClass = (type) => `slate-${type}`;
 
 /**
  * Override node props with plugin props.
@@ -6876,33 +7209,25 @@ const getSlateClass = type => `slate-${type}`;
  * Extend the class name with the node type.
  */
 
-const getRenderNodeProps = ({
-  attributes,
-  nodeProps,
-  props,
-  type
-}) => {
+const getRenderNodeProps = ({ attributes, nodeProps, props, type }) => {
   let newProps = {};
 
   if (props) {
     var _ref;
 
-    newProps = (_ref = typeof props === 'function' ? props(nodeProps) : props) !== null && _ref !== void 0 ? _ref : {};
+    newProps =
+      (_ref = typeof props === "function" ? props(nodeProps) : props) !== null && _ref !== void 0
+        ? _ref
+        : {};
   }
 
   if (!newProps.nodeProps && attributes) {
     newProps.nodeProps = attributes;
   }
 
-  nodeProps = { ...nodeProps,
-    ...newProps
-  };
-  const {
-    className
-  } = nodeProps;
-  return { ...nodeProps,
-    className: clsx(getSlateClass(type), className)
-  };
+  nodeProps = { ...nodeProps, ...newProps };
+  const { className } = nodeProps;
+  return { ...nodeProps, className: clsx(getSlateClass(type), className) };
 };
 
 /**
@@ -6911,62 +7236,58 @@ const getRenderNodeProps = ({
  * Else, return `undefined` so the pipeline can check the next plugin.
  */
 
-const pluginRenderElement = (editor, {
-  key,
-  type,
-  component: _component,
-  props
-}) => nodeProps => {
-  const {
-    element,
-    children: _children
-  } = nodeProps;
-
-  if (element.type === type) {
-    const Element = _component !== null && _component !== void 0 ? _component : DefaultElement;
-    const injectAboveComponents = editor.plugins.flatMap(o => {
-      var _o$inject$aboveCompon, _o$inject;
+const pluginRenderElement =
+  (editor, { key, type, component: _component, props }) =>
+  (nodeProps) => {
+    const { element, children: _children } = nodeProps;
 
-      return (_o$inject$aboveCompon = (_o$inject = o.inject) === null || _o$inject === void 0 ? void 0 : _o$inject.aboveComponent) !== null && _o$inject$aboveCompon !== void 0 ? _o$inject$aboveCompon : [];
-    });
-    const injectBelowComponents = editor.plugins.flatMap(o => {
-      var _o$inject$belowCompon, _o$inject2;
+    if (element.type === type) {
+      const Element = _component !== null && _component !== void 0 ? _component : DefaultElement;
+      const injectAboveComponents = editor.plugins.flatMap((o) => {
+        var _o$inject$aboveCompon, _o$inject;
 
-      return (_o$inject$belowCompon = (_o$inject2 = o.inject) === null || _o$inject2 === void 0 ? void 0 : _o$inject2.belowComponent) !== null && _o$inject$belowCompon !== void 0 ? _o$inject$belowCompon : [];
-    });
-    nodeProps = getRenderNodeProps({
-      attributes: element.attributes,
-      nodeProps,
-      props,
-      type
-    });
-    let children = _children;
-    injectBelowComponents.forEach(withHOC => {
-      const hoc = withHOC({ ...nodeProps,
-        key
+        return (_o$inject$aboveCompon =
+          (_o$inject = o.inject) === null || _o$inject === void 0
+            ? void 0
+            : _o$inject.aboveComponent) !== null && _o$inject$aboveCompon !== void 0
+          ? _o$inject$aboveCompon
+          : [];
+      });
+      const injectBelowComponents = editor.plugins.flatMap((o) => {
+        var _o$inject$belowCompon, _o$inject2;
+
+        return (_o$inject$belowCompon =
+          (_o$inject2 = o.inject) === null || _o$inject2 === void 0
+            ? void 0
+            : _o$inject2.belowComponent) !== null && _o$inject$belowCompon !== void 0
+          ? _o$inject$belowCompon
+          : [];
+      });
+      nodeProps = getRenderNodeProps({
+        attributes: element.attributes,
+        nodeProps,
+        props,
+        type,
       });
+      let children = _children;
+      injectBelowComponents.forEach((withHOC) => {
+        const hoc = withHOC({ ...nodeProps, key });
 
-      if (hoc) {
-        children = hoc({ ...nodeProps,
-          children
-        });
-      }
-    });
-    let component = /*#__PURE__*/React.createElement(Element, nodeProps, children);
-    injectAboveComponents.forEach(withHOC => {
-      const hoc = withHOC({ ...nodeProps,
-        key
+        if (hoc) {
+          children = hoc({ ...nodeProps, children });
+        }
       });
+      let component = /*#__PURE__*/ React.createElement(Element, nodeProps, children);
+      injectAboveComponents.forEach((withHOC) => {
+        const hoc = withHOC({ ...nodeProps, key });
 
-      if (hoc) {
-        component = hoc({ ...nodeProps,
-          children: component
-        });
-      }
-    });
-    return component;
-  }
-};
+        if (hoc) {
+          component = hoc({ ...nodeProps, children: component });
+        }
+      });
+      return component;
+    }
+  };
 
 /**
  * @see {@link RenderElement}
@@ -6974,15 +7295,15 @@ const pluginRenderElement = (editor, {
 
 const pipeRenderElement = (editor, editableProps) => {
   const renderElements = [];
-  editor.plugins.forEach(plugin => {
+  editor.plugins.forEach((plugin) => {
     if (plugin.isElement) {
       renderElements.push(pluginRenderElement(editor, plugin));
     }
   });
-  return nodeProps => {
+  return (nodeProps) => {
     const props = pipeInjectProps(editor, nodeProps);
     let element;
-    renderElements.some(renderElement => {
+    renderElements.some((renderElement) => {
       element = renderElement(props);
       return !!element;
     });
@@ -6992,7 +7313,7 @@ const pipeRenderElement = (editor, editableProps) => {
       return editableProps.renderElement(props);
     }
 
-    return /*#__PURE__*/React.createElement(DefaultElement, props);
+    return /*#__PURE__*/ React.createElement(DefaultElement, props);
   };
 };
 
@@ -7002,30 +7323,24 @@ const pipeRenderElement = (editor, editableProps) => {
  * Else, return `children`.
  */
 
-const pluginRenderLeaf = (editor, {
-  key,
-  type = key,
-  component,
-  props
-}) => nodeProps => {
-  const {
-    leaf,
-    children
-  } = nodeProps;
-
-  if (leaf[type] && !!leaf.text) {
-    const Leaf = component !== null && component !== void 0 ? component : DefaultLeaf;
-    nodeProps = getRenderNodeProps({
-      attributes: leaf.attributes,
-      props,
-      nodeProps,
-      type
-    });
-    return /*#__PURE__*/React.createElement(Leaf, nodeProps, children);
-  }
+const pluginRenderLeaf =
+  (editor, { key, type = key, component, props }) =>
+  (nodeProps) => {
+    const { leaf, children } = nodeProps;
 
-  return children;
-};
+    if (leaf[type] && !!leaf.text) {
+      const Leaf = component !== null && component !== void 0 ? component : DefaultLeaf;
+      nodeProps = getRenderNodeProps({
+        attributes: leaf.attributes,
+        props,
+        nodeProps,
+        type,
+      });
+      return /*#__PURE__*/ React.createElement(Leaf, nodeProps, children);
+    }
+
+    return children;
+  };
 
 /**
  * @see {@link RenderLeaf}
@@ -7033,14 +7348,14 @@ const pluginRenderLeaf = (editor, {
 
 const pipeRenderLeaf = (editor, editableProps) => {
   const renderLeafs = [];
-  editor.plugins.forEach(plugin => {
+  editor.plugins.forEach((plugin) => {
     if (plugin.isLeaf && plugin.key) {
       renderLeafs.push(pluginRenderLeaf(editor, plugin));
     }
   });
-  return nodeProps => {
+  return (nodeProps) => {
     const props = pipeInjectProps(editor, nodeProps);
-    renderLeafs.forEach(renderLeaf => {
+    renderLeafs.forEach((renderLeaf) => {
       const newChildren = renderLeaf(props);
 
       if (newChildren !== undefined) {
@@ -7052,27 +7367,24 @@ const pipeRenderLeaf = (editor, editableProps) => {
       return editableProps.renderLeaf(props);
     }
 
-    return /*#__PURE__*/React.createElement(DefaultLeaf, props);
+    return /*#__PURE__*/ React.createElement(DefaultLeaf, props);
   };
 };
 
-const useEditableProps = ({
-  id = 'main',
-  editableProps
-}) => {
+const useEditableProps = ({ id = "main", editableProps }) => {
   const editor = usePlateEditorRef(id);
-  const keyPlugins = usePlateKey('keyPlugins', id);
+  const keyPlugins = usePlateKey("keyPlugins", id);
   const props = useMemo(() => {
     if (!editor || !keyPlugins) return {};
     const _props = {
       decorate: pipeDecorate(editor),
       renderElement: pipeRenderElement(editor, editableProps),
-      renderLeaf: pipeRenderLeaf(editor, editableProps)
+      renderLeaf: pipeRenderLeaf(editor, editableProps),
     };
-    DOM_HANDLERS.forEach(handlerKey => {
+    DOM_HANDLERS.forEach((handlerKey) => {
       const handler = pipeHandler(editor, {
         editableProps,
-        handlerKey
+        handlerKey,
       });
 
       if (handler) {
@@ -7081,40 +7393,46 @@ const useEditableProps = ({
     });
     return _props;
   }, [editableProps, editor, keyPlugins]);
-  return useMemo(() => ({ ...omit_1(editableProps, [...DOM_HANDLERS, 'renderElement', 'renderLeaf']),
-    ...props
-  }), [editableProps, props]);
+  return useMemo(
+    () => ({
+      ...omit_1(editableProps, [...DOM_HANDLERS, "renderElement", "renderLeaf"]),
+      ...props,
+    }),
+    [editableProps, props]
+  );
 };
 
 var shallow_1 = createCommonjsModule(function (module, exports) {
+  Object.defineProperty(exports, "__esModule", { value: true });
 
-Object.defineProperty(exports, '__esModule', { value: true });
-
-function shallow(objA, objB) {
-  if (Object.is(objA, objB)) {
-    return true;
-  }
-
-  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
-    return false;
-  }
+  function shallow(objA, objB) {
+    if (Object.is(objA, objB)) {
+      return true;
+    }
 
-  var keysA = Object.keys(objA);
+    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
+      return false;
+    }
 
-  if (keysA.length !== Object.keys(objB).length) {
-    return false;
-  }
+    var keysA = Object.keys(objA);
 
-  for (var i = 0; i < keysA.length; i++) {
-    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
+    if (keysA.length !== Object.keys(objB).length) {
       return false;
     }
-  }
 
-  return true;
-}
+    for (var i = 0; i < keysA.length; i++) {
+      if (
+        !Object.prototype.hasOwnProperty.call(objB, keysA[i]) ||
+        !Object.is(objA[keysA[i]], objB[keysA[i]])
+      ) {
+        return false;
+      }
+    }
+
+    return true;
+  }
 
-exports.default = shallow;
+  exports.default = shallow;
 });
 
 var shallow = unwrapExports(shallow_1);
@@ -7125,62 +7443,73 @@ const getStateById = (state, id) => {
 
   return (_state$id = state[id]) !== null && _state$id !== void 0 ? _state$id : {};
 };
-const mergeState = (stateToMerge, stateId) => stateId && set$2(state => ({
-  [stateId]: { ...getStateById(state, stateId),
-    ...stateToMerge
-  }
-}));
-const getSetStateByKey = (key, stateId) => (value, id = stateId) => id && set$2(state => {
-  if (!state[id]) return;
-  return {
-    [id]: { ...getStateById(state, id),
-      [key]: value
-    }
-  };
-});
+const mergeState = (stateToMerge, stateId) =>
+  stateId &&
+  set$2((state) => ({
+    [stateId]: { ...getStateById(state, stateId), ...stateToMerge },
+  }));
+const getSetStateByKey =
+  (key, stateId) =>
+  (value, id = stateId) =>
+    id &&
+    set$2((state) => {
+      if (!state[id]) return;
+      return {
+        [id]: { ...getStateById(state, id), [key]: value },
+      };
+    });
 
-const {
-  getState: get,
-  setState: set$1
-} = plateStore;
-const usePlateActions = storeId => {
-  const storeKeys = usePlateStore(s => Object.keys(s), shallow);
+const { getState: get, setState: set$1 } = plateStore;
+const usePlateActions = (storeId) => {
+  const storeKeys = usePlateStore((s) => Object.keys(s), shallow);
   const stateId = storeId !== null && storeId !== void 0 ? storeId : storeKeys[0];
   return useMemo(() => {
-    const setEditor = getSetStateByKey('editor', stateId);
-    const setValue = getSetStateByKey('value', stateId);
+    const setEditor = getSetStateByKey("editor", stateId);
+    const setValue = getSetStateByKey("value", stateId);
     return {
       setEditor,
       setValue,
-      clearState: (id = stateId) => id && set$1(state => {
-        delete state[id];
-      }),
-      setInitialState: ({
-        enabled = true,
-        value = [{
-          children: [{
-            text: ''
-          }]
-        }]
-      } = {}, id = stateId) => id && set$1(state => {
-        if (state[id]) return;
-        state[id] = {
-          enabled,
-          value
-        };
-      }),
+      clearState: (id = stateId) =>
+        id &&
+        set$1((state) => {
+          delete state[id];
+        }),
+      setInitialState: (
+        {
+          enabled = true,
+          value = [
+            {
+              children: [
+                {
+                  text: "",
+                },
+              ],
+            },
+          ],
+        } = {},
+        id = stateId
+      ) =>
+        id &&
+        set$1((state) => {
+          if (state[id]) return;
+          state[id] = {
+            enabled,
+            value,
+          };
+        }),
       resetEditor: (id = stateId) => {
         const state = !!id && get()[id];
         if (!state) return;
-        const {
-          editor
-        } = state;
-        setEditor(withPlate(createEditor$1(), {
-          id,
-          plugins: editor === null || editor === void 0 ? void 0 : editor.plugins
-        }), id);
+        const { editor } = state;
+        setEditor(
+          withPlate(createEditor$1(), {
+            id,
+            plugins: editor === null || editor === void 0 ? void 0 : editor.plugins,
+          }),
+          id
+        );
       },
-      setEnabled: getSetStateByKey('enabled', stateId)
+      setEnabled: getSetStateByKey("enabled", stateId),
     };
   }, [stateId]);
 };
@@ -7191,9 +7520,7 @@ const incrementKey = (key, id = getPlateId()) => {
   if (!state || !id) return;
   const prev = (_state$key = state[key]) !== null && _state$key !== void 0 ? _state$key : 1;
   plateStore.setState({
-    [id]: { ...state,
-      [key]: prev + 1
-    }
+    [id]: { ...state, [key]: prev + 1 },
   });
 };
 
@@ -7207,8 +7534,10 @@ const incrementKey = (key, id = getPlateId()) => {
  * @param {*} value The value to assign.
  */
 function assignMergeValue(object, key, value) {
-  if ((value !== undefined && !eq_1(object[key], value)) ||
-      (value === undefined && !(key in object))) {
+  if (
+    (value !== undefined && !eq_1(object[key], value)) ||
+    (value === undefined && !(key in object))
+  ) {
     _baseAssignValue(object, key, value);
   }
 }
@@ -7255,11 +7584,11 @@ var isArrayLikeObject_1 = isArrayLikeObject;
  * @returns {*} Returns the property value.
  */
 function safeGet(object, key) {
-  if (key === 'constructor' && typeof object[key] === 'function') {
+  if (key === "constructor" && typeof object[key] === "function") {
     return;
   }
 
-  if (key == '__proto__') {
+  if (key == "__proto__") {
     return;
   }
 
@@ -7315,54 +7644,47 @@ var toPlainObject_1 = toPlainObject;
  */
 function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
   var objValue = _safeGet(object, key),
-      srcValue = _safeGet(source, key),
-      stacked = stack.get(srcValue);
+    srcValue = _safeGet(source, key),
+    stacked = stack.get(srcValue);
 
   if (stacked) {
     _assignMergeValue(object, key, stacked);
     return;
   }
   var newValue = customizer
-    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
+    ? customizer(objValue, srcValue, key + "", object, source, stack)
     : undefined;
 
   var isCommon = newValue === undefined;
 
   if (isCommon) {
     var isArr = isArray_1(srcValue),
-        isBuff = !isArr && isBuffer_1(srcValue),
-        isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);
+      isBuff = !isArr && isBuffer_1(srcValue),
+      isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);
 
     newValue = srcValue;
     if (isArr || isBuff || isTyped) {
       if (isArray_1(objValue)) {
         newValue = objValue;
-      }
-      else if (isArrayLikeObject_1(objValue)) {
+      } else if (isArrayLikeObject_1(objValue)) {
         newValue = _copyArray(objValue);
-      }
-      else if (isBuff) {
+      } else if (isBuff) {
         isCommon = false;
         newValue = _cloneBuffer(srcValue, true);
-      }
-      else if (isTyped) {
+      } else if (isTyped) {
         isCommon = false;
         newValue = _cloneTypedArray(srcValue, true);
-      }
-      else {
+      } else {
         newValue = [];
       }
-    }
-    else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
+    } else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
       newValue = objValue;
       if (isArguments_1(objValue)) {
         newValue = toPlainObject_1(objValue);
-      }
-      else if (!isObject_1(objValue) || isFunction_1(objValue)) {
+      } else if (!isObject_1(objValue) || isFunction_1(objValue)) {
         newValue = _initCloneObject(srcValue);
       }
-    }
-    else {
+    } else {
       isCommon = false;
     }
   }
@@ -7370,7 +7692,7 @@ function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, sta
     // Recursively merge objects and arrays (susceptible to call stack limits).
     stack.set(srcValue, newValue);
     mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
-    stack['delete'](srcValue);
+    stack["delete"](srcValue);
   }
   _assignMergeValue(object, key, newValue);
 }
@@ -7392,22 +7714,25 @@ function baseMerge(object, source, srcIndex, customizer, stack) {
   if (object === source) {
     return;
   }
-  _baseFor(source, function(srcValue, key) {
-    stack || (stack = new _Stack);
-    if (isObject_1(srcValue)) {
-      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
-    }
-    else {
-      var newValue = customizer
-        ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
-        : undefined;
+  _baseFor(
+    source,
+    function (srcValue, key) {
+      stack || (stack = new _Stack());
+      if (isObject_1(srcValue)) {
+        _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
+      } else {
+        var newValue = customizer
+          ? customizer(_safeGet(object, key), srcValue, key + "", object, source, stack)
+          : undefined;
 
-      if (newValue === undefined) {
-        newValue = srcValue;
+        if (newValue === undefined) {
+          newValue = srcValue;
+        }
+        _assignMergeValue(object, key, newValue);
       }
-      _assignMergeValue(object, key, newValue);
-    }
-  }, keysIn_1);
+    },
+    keysIn_1
+  );
 }
 
 var _baseMerge = baseMerge;
@@ -7431,7 +7756,7 @@ function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
     // Recursively merge objects and arrays (susceptible to call stack limits).
     stack.set(srcValue, objValue);
     _baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
-    stack['delete'](srcValue);
+    stack["delete"](srcValue);
   }
   return objValue;
 }
@@ -7446,15 +7771,14 @@ var _customDefaultsMerge = customDefaultsMerge;
  * @returns {Function} Returns the new assigner function.
  */
 function createAssigner(assigner) {
-  return _baseRest(function(object, sources) {
+  return _baseRest(function (object, sources) {
     var index = -1,
-        length = sources.length,
-        customizer = length > 1 ? sources[length - 1] : undefined,
-        guard = length > 2 ? sources[2] : undefined;
+      length = sources.length,
+      customizer = length > 1 ? sources[length - 1] : undefined,
+      guard = length > 2 ? sources[2] : undefined;
 
-    customizer = (assigner.length > 3 && typeof customizer == 'function')
-      ? (length--, customizer)
-      : undefined;
+    customizer =
+      assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
 
     if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
       customizer = length < 3 ? undefined : customizer;
@@ -7504,7 +7828,7 @@ var _createAssigner = createAssigner;
  * _.mergeWith(object, other, customizer);
  * // => { 'a': [1, 3], 'b': [2, 4] }
  */
-var mergeWith = _createAssigner(function(object, source, srcIndex, customizer) {
+var mergeWith = _createAssigner(function (object, source, srcIndex, customizer) {
   _baseMerge(object, source, srcIndex, customizer);
 });
 
@@ -7529,7 +7853,7 @@ var mergeWith_1 = mergeWith;
  * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
  * // => { 'a': { 'b': 2, 'c': 3 } }
  */
-var defaultsDeep = _baseRest(function(args) {
+var defaultsDeep = _baseRest(function (args) {
   args.push(undefined, _customDefaultsMerge);
   return _apply(mergeWith_1, undefined, args);
 });
@@ -7548,7 +7872,7 @@ var defaultsDeep_1 = defaultsDeep;
  */
 function arrayAggregator(array, setter, iteratee, accumulator) {
   var index = -1,
-      length = array == null ? 0 : array.length;
+    length = array == null ? 0 : array.length;
 
   while (++index < length) {
     var value = array[index];
@@ -7571,7 +7895,7 @@ var _arrayAggregator = arrayAggregator;
  * @returns {Function} Returns `accumulator`.
  */
 function baseAggregator(collection, setter, iteratee, accumulator) {
-  _baseEach(collection, function(value, key, collection) {
+  _baseEach(collection, function (value, key, collection) {
     setter(accumulator, value, iteratee(value), collection);
   });
   return accumulator;
@@ -7588,9 +7912,9 @@ var _baseAggregator = baseAggregator;
  * @returns {Function} Returns the new aggregator function.
  */
 function createAggregator(setter, initializer) {
-  return function(collection, iteratee) {
+  return function (collection, iteratee) {
     var func = isArray_1(collection) ? _arrayAggregator : _baseAggregator,
-        accumulator = initializer ? initializer() : {};
+      accumulator = initializer ? initializer() : {};
 
     return func(collection, setter, _baseIteratee(iteratee), accumulator);
   };
@@ -7626,7 +7950,7 @@ var _createAggregator = createAggregator;
  * _.keyBy(array, 'dir');
  * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
  */
-var keyBy = _createAggregator(function(result, value, key) {
+var keyBy = _createAggregator(function (result, value, key) {
   _baseAssignValue(result, key, value);
 });
 
@@ -7663,7 +7987,7 @@ var keyBy_1 = keyBy;
  * _.merge(object, other);
  * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
  */
-var merge = _createAssigner(function(object, source, srcIndex) {
+var merge = _createAssigner(function (object, source, srcIndex) {
   _baseMerge(object, source, srcIndex);
 });
 
@@ -7680,7 +8004,7 @@ var merge_1 = merge;
  * @returns {Object} Returns the array of property values.
  */
 function baseValues(object, props) {
-  return _arrayMap(props, function(key) {
+  return _arrayMap(props, function (key) {
     return object[key];
   });
 }
@@ -7723,21 +8047,16 @@ var values_1 = values;
  * Recursively merge nested plugins into the root plugins
  */
 const mergeDeepPlugins = (editor, _plugin) => {
-  const plugin = { ..._plugin
-  };
-  const {
-    then
-  } = plugin;
+  const plugin = { ..._plugin };
+  const { then } = plugin;
 
   if (then) {
     delete plugin.then;
-    const {
-      plugins: pluginPlugins
-    } = plugin;
+    const { plugins: pluginPlugins } = plugin;
     const pluginThen = mergeDeepPlugins(editor, defaultsDeep_1(then(editor, plugin), plugin)); // merge plugins by key
 
     if (pluginPlugins && pluginThen.plugins) {
-      const merged = merge_1(keyBy_1(pluginPlugins, 'key'), keyBy_1(pluginThen.plugins, 'key'));
+      const merged = merge_1(keyBy_1(pluginPlugins, "key"), keyBy_1(pluginThen.plugins, "key"));
       pluginThen.plugins = values_1(merged);
     }
 
@@ -7747,7 +8066,7 @@ const mergeDeepPlugins = (editor, _plugin) => {
   return plugin;
 };
 
-const setDefaultPlugin = plugin => {
+const setDefaultPlugin = (plugin) => {
   if (plugin.type === undefined) plugin.type = plugin.key;
   if (!plugin.options) plugin.options = {};
   if (!plugin.inject) plugin.inject = {};
@@ -7761,7 +8080,7 @@ const setDefaultPlugin = plugin => {
 
 const flattenDeepPlugins = (editor, plugins) => {
   if (!plugins) return;
-  plugins.forEach(plugin => {
+  plugins.forEach((plugin) => {
     let p = setDefaultPlugin(plugin);
     p = mergeDeepPlugins(editor, p);
     editor.plugins.push(p);
@@ -7788,33 +8107,37 @@ const overridePluginsByKey = (plugin, overrideByKey = {}, nested) => {
 
     if (!nested) {
       // concat new pluginOverrides.plugins to plugin.plugins
-      pluginOverridesPlugins === null || pluginOverridesPlugins === void 0 ? void 0 : pluginOverridesPlugins.forEach(pOverrides => {
-        if (!plugin.plugins) plugin.plugins = [];
-        const found = plugin.plugins.find(p => p.key === pOverrides.key);
-        if (!found) plugin.plugins.push(pOverrides);
-      });
+      pluginOverridesPlugins === null || pluginOverridesPlugins === void 0
+        ? void 0
+        : pluginOverridesPlugins.forEach((pOverrides) => {
+            if (!plugin.plugins) plugin.plugins = [];
+            const found = plugin.plugins.find((p) => p.key === pOverrides.key);
+            if (!found) plugin.plugins.push(pOverrides);
+          });
     }
   }
 
   if (plugin.plugins) {
     // override plugin.plugins
-    plugin.plugins = plugin.plugins.map(p => overridePluginsByKey(p, overrideByKey, true));
+    plugin.plugins = plugin.plugins.map((p) => overridePluginsByKey(p, overrideByKey, true));
   }
 
-  const {
-    then
-  } = plugin;
+  const { then } = plugin;
 
   if (then) {
     // override plugin.then
     plugin.then = (editor, p) => {
       const pluginThen = {
         key: plugin.key,
-        ...then(editor, p)
+        ...then(editor, p),
       };
       return defaultsDeep_1(overridePluginsByKey(pluginThen, overrideByKey), pluginThen);
     };
-  } else if ((_overrideByKey$plugin = overrideByKey[plugin.key]) !== null && _overrideByKey$plugin !== void 0 && _overrideByKey$plugin.then) {
+  } else if (
+    (_overrideByKey$plugin = overrideByKey[plugin.key]) !== null &&
+    _overrideByKey$plugin !== void 0 &&
+    _overrideByKey$plugin.then
+  ) {
     // TODO: recursvie
     plugin.then = overrideByKey[plugin.key].then;
   }
@@ -7831,9 +8154,9 @@ const setPlatePlugins = (editor, plugins) => {
   editor.pluginsByKey = {};
   flattenDeepPlugins(editor, plugins); // override all the plugins one by one, so plugin.overrideByKey effects can be overridden by the next plugin
 
-  editor.plugins.forEach(plugin => {
+  editor.plugins.forEach((plugin) => {
     if (plugin.overrideByKey) {
-      const newPlugins = editor.plugins.map(p => {
+      const newPlugins = editor.plugins.map((p) => {
         return overridePluginsByKey(p, plugin.overrideByKey);
       });
       editor.plugins = [];
@@ -7842,7 +8165,7 @@ const setPlatePlugins = (editor, plugins) => {
       flattenDeepPlugins(editor, newPlugins);
     }
   });
-  incrementKey('keyPlugins', editor.id);
+  incrementKey("keyPlugins", editor.id);
 };
 
 /**
@@ -7854,21 +8177,22 @@ const setPlatePlugins = (editor, plugins) => {
  *   - second param `overrideByKey` can be used to (deeply) override by key a nested plugin (in plugin.plugins).
  */
 
-const createPluginFactory = defaultPlugin => (override, overrideByKey = {}) => {
-  overrideByKey[defaultPlugin.key] = override;
-  return overridePluginsByKey({ ...defaultPlugin
-  }, overrideByKey);
-};
+const createPluginFactory =
+  (defaultPlugin) =>
+  (override, overrideByKey = {}) => {
+    overrideByKey[defaultPlugin.key] = override;
+    return overridePluginsByKey({ ...defaultPlugin }, overrideByKey);
+  };
 
 /**
  * Convert HTML string into HTML element.
  */
 const htmlStringToDOMNode = (rawHtml, stripWhitespace = true) => {
-  const node = document.createElement('body');
+  const node = document.createElement("body");
   node.innerHTML = rawHtml;
 
   if (stripWhitespace) {
-    node.innerHTML = node.innerHTML.replace(/(\r\n|\n|\r|\t)/gm, '');
+    node.innerHTML = node.innerHTML.replace(/(\r\n|\n|\r|\t)/gm, "");
   }
 
   return node;
@@ -7882,11 +8206,11 @@ const htmlStringToDOMNode = (rawHtml, stripWhitespace = true) => {
  */
 
 function isObject(o) {
-  return Object.prototype.toString.call(o) === '[object Object]';
+  return Object.prototype.toString.call(o) === "[object Object]";
 }
 
 function isPlainObject(o) {
-  var ctor,prot;
+  var ctor, prot;
 
   if (isObject(o) === false) return false;
 
@@ -7899,7 +8223,7 @@ function isPlainObject(o) {
   if (isObject(prot) === false) return false;
 
   // If constructor does not have an Object-specific method
-  if (prot.hasOwnProperty('isPrototypeOf') === false) {
+  if (prot.hasOwnProperty("isPrototypeOf") === false) {
     return false;
   }
 
@@ -7913,7 +8237,7 @@ function _defineProperty(obj, key, value) {
       value: value,
       enumerable: true,
       configurable: true,
-      writable: true
+      writable: true,
     });
   } else {
     obj[key] = value;
@@ -7944,14 +8268,10 @@ class AnchorToken extends Token {
   constructor() {
     var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
     super();
-    var {
-      offset,
-      path
-    } = props;
+    var { offset, path } = props;
     this.offset = offset;
     this.path = path;
   }
-
 }
 /**
  * Focus tokens represent the selection's focus point.
@@ -7961,14 +8281,10 @@ class FocusToken extends Token {
   constructor() {
     var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
     super();
-    var {
-      offset,
-      path
-    } = props;
+    var { offset, path } = props;
     this.offset = offset;
     this.path = path;
   }
-
 }
 /**
  * Add an anchor token to the end of a text node.
@@ -7982,7 +8298,7 @@ var addAnchorToken = (text, token) => {
  * Get the offset if a text node has an associated anchor token.
  */
 
-var getAnchorOffset = text => {
+var getAnchorOffset = (text) => {
   return ANCHOR.get(text);
 };
 /**
@@ -7997,13 +8313,41 @@ var addFocusToken = (text, token) => {
  * Get the offset if a text node has an associated focus token.
  */
 
-var getFocusOffset = text => {
+var getFocusOffset = (text) => {
   return FOCUS.get(text);
 };
 
-function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }
+function ownKeys$1(object, enumerableOnly) {
+  var keys = Object.keys(object);
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly) {
+      symbols = symbols.filter(function (sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    }
+    keys.push.apply(keys, symbols);
+  }
+  return keys;
+}
 
-function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+function _objectSpread$1(target) {
+  for (var i = 1; i < arguments.length; i++) {
+    var source = arguments[i] != null ? arguments[i] : {};
+    if (i % 2) {
+      ownKeys$1(Object(source), true).forEach(function (key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys$1(Object(source)).forEach(function (key) {
+        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
+      });
+    }
+  }
+  return target;
+}
 /**
  * Resolve the descedants of a node by normalizing the children that can be
  * passed into a hyperscript creator function.
@@ -8011,19 +8355,19 @@ function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) {
 
 var STRINGS = new WeakSet();
 
-var resolveDescendants = children => {
+var resolveDescendants = (children) => {
   var nodes = [];
 
-  var addChild = child => {
+  var addChild = (child) => {
     if (child == null) {
       return;
     }
 
     var prev = nodes[nodes.length - 1];
 
-    if (typeof child === 'string') {
+    if (typeof child === "string") {
       var text = {
-        text: child
+        text: child,
       };
       STRINGS.add(text);
       child = text;
@@ -8032,9 +8376,14 @@ var resolveDescendants = children => {
     if (Text.isText(child)) {
       var c = child; // HACK: fix typescript complaining
 
-      if (Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c) && Text.equals(prev, c, {
-        loose: true
-      })) {
+      if (
+        Text.isText(prev) &&
+        STRINGS.has(prev) &&
+        STRINGS.has(c) &&
+        Text.equals(prev, c, {
+          loose: true,
+        })
+      ) {
         prev.text += c.text;
       } else {
         nodes.push(c);
@@ -8045,7 +8394,7 @@ var resolveDescendants = children => {
       var n = nodes[nodes.length - 1];
 
       if (!Text.isText(n)) {
-        addChild('');
+        addChild("");
         n = nodes[nodes.length - 1];
       }
 
@@ -8069,7 +8418,6 @@ var resolveDescendants = children => {
  * Create an anchor token.
  */
 
-
 function createAnchor(tagName, attributes, children) {
   return new AnchorToken(attributes);
 }
@@ -8085,9 +8433,13 @@ function createCursor(tagName, attributes, children) {
  */
 
 function createElement(tagName, attributes, children) {
-  return _objectSpread$1(_objectSpread$1({}, attributes), {}, {
-    children: resolveDescendants(children)
-  });
+  return _objectSpread$1(
+    _objectSpread$1({}, attributes),
+    {},
+    {
+      children: resolveDescendants(children),
+    }
+  );
 }
 /**
  * Create a focus token.
@@ -8108,27 +8460,34 @@ function createFragment(tagName, attributes, children) {
  */
 
 function createSelection(tagName, attributes, children) {
-  var anchor = children.find(c => c instanceof AnchorToken);
-  var focus = children.find(c => c instanceof FocusToken);
+  var anchor = children.find((c) => c instanceof AnchorToken);
+  var focus = children.find((c) => c instanceof FocusToken);
 
   if (!anchor || anchor.offset == null || anchor.path == null) {
-    throw new Error("The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.");
+    throw new Error(
+      "The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined."
+    );
   }
 
   if (!focus || focus.offset == null || focus.path == null) {
-    throw new Error("The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.");
+    throw new Error(
+      "The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined."
+    );
   }
 
-  return _objectSpread$1({
-    anchor: {
-      offset: anchor.offset,
-      path: anchor.path
+  return _objectSpread$1(
+    {
+      anchor: {
+        offset: anchor.offset,
+        path: anchor.path,
+      },
+      focus: {
+        offset: focus.offset,
+        path: focus.path,
+      },
     },
-    focus: {
-      offset: focus.offset,
-      path: focus.path
-    }
-  }, attributes);
+    attributes
+  );
 }
 /**
  * Create a `Text` object.
@@ -8138,14 +8497,16 @@ function createText(tagName, attributes, children) {
   var nodes = resolveDescendants(children);
 
   if (nodes.length > 1) {
-    throw new Error("The <text> hyperscript tag must only contain a single node's worth of children.");
+    throw new Error(
+      "The <text> hyperscript tag must only contain a single node's worth of children."
+    );
   }
 
   var [node] = nodes;
 
   if (node == null) {
     node = {
-      text: ''
+      text: "",
     };
   }
 
@@ -8154,7 +8515,6 @@ function createText(tagName, attributes, children) {
   } // COMPAT: If they used the <text> tag we want to guarantee that it won't be
   // merge with other string children.
 
-
   STRINGS.delete(node);
   Object.assign(node, attributes);
   return node;
@@ -8163,7 +8523,7 @@ function createText(tagName, attributes, children) {
  * Create a top-level `Editor` object.
  */
 
-var createEditor = makeEditor => (tagName, attributes, children) => {
+var createEditor = (makeEditor) => (tagName, attributes, children) => {
   var otherChildren = [];
   var selectionChild;
 
@@ -8190,7 +8550,7 @@ var createEditor = makeEditor => (tagName, attributes, children) => {
       var [offset] = anchor;
       selection.anchor = {
         path,
-        offset
+        offset,
       };
     }
 
@@ -8198,17 +8558,21 @@ var createEditor = makeEditor => (tagName, attributes, children) => {
       var [_offset] = focus;
       selection.focus = {
         path,
-        offset: _offset
+        offset: _offset,
       };
     }
   }
 
   if (selection.anchor && !selection.focus) {
-    throw new Error("Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.");
+    throw new Error(
+      "Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead."
+    );
   }
 
   if (!selection.anchor && selection.focus) {
-    throw new Error("Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.");
+    throw new Error(
+      "Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead."
+    );
   }
 
   if (selectionChild != null) {
@@ -8220,9 +8584,37 @@ var createEditor = makeEditor => (tagName, attributes, children) => {
   return editor;
 };
 
-function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly) {
+      symbols = symbols.filter(function (sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    }
+    keys.push.apply(keys, symbols);
+  }
+  return keys;
+}
 
-function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+function _objectSpread(target) {
+  for (var i = 1; i < arguments.length; i++) {
+    var source = arguments[i] != null ? arguments[i] : {};
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function (key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function (key) {
+        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
+      });
+    }
+  }
+  return target;
+}
 /**
  * The default creators for Slate objects.
  */
@@ -8235,7 +8627,7 @@ var DEFAULT_CREATORS = {
   focus: createFocus,
   fragment: createFragment,
   selection: createSelection,
-  text: createText
+  text: createText,
 };
 /**
  * Create a Slate hyperscript function with `options`.
@@ -8243,12 +8635,13 @@ var DEFAULT_CREATORS = {
 
 var createHyperscript = function createHyperscript() {
   var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
-  var {
-    elements = {}
-  } = options;
+  var { elements = {} } = options;
   var elementCreators = normalizeElements(elements);
 
-  var creators = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CREATORS), elementCreators), options.creators);
+  var creators = _objectSpread(
+    _objectSpread(_objectSpread({}, DEFAULT_CREATORS), elementCreators),
+    options.creators
+  );
 
   var jsx = createFactory(creators);
   return jsx;
@@ -8257,10 +8650,13 @@ var createHyperscript = function createHyperscript() {
  * Create a Slate hyperscript function with `options`.
  */
 
-
-var createFactory = creators => {
+var createFactory = (creators) => {
   var jsx = function jsx(tagName, attributes) {
-    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
+    for (
+      var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2;
+      _key < _len;
+      _key++
+    ) {
       children[_key - 2] = arguments[_key];
     }
 
@@ -8279,7 +8675,7 @@ var createFactory = creators => {
       attributes = {};
     }
 
-    children = children.filter(child => Boolean(child)).flat();
+    children = children.filter((child) => Boolean(child)).flat();
     var ret = creator(tagName, attributes, children);
     return ret;
   };
@@ -8290,19 +8686,26 @@ var createFactory = creators => {
  * Normalize a dictionary of element shorthands into creator functions.
  */
 
-
-var normalizeElements = elements => {
+var normalizeElements = (elements) => {
   var creators = {};
 
   var _loop = function _loop(tagName) {
     var props = elements[tagName];
 
-    if (typeof props !== 'object') {
-      throw new Error("Properties specified for a hyperscript shorthand should be an object, but for the custom element <".concat(tagName, ">  tag you passed: ").concat(props));
+    if (typeof props !== "object") {
+      throw new Error(
+        "Properties specified for a hyperscript shorthand should be an object, but for the custom element <"
+          .concat(tagName, ">  tag you passed: ")
+          .concat(props)
+      );
     }
 
     creators[tagName] = (tagName, attributes, children) => {
-      return createElement('element', _objectSpread(_objectSpread({}, props), attributes), children);
+      return createElement(
+        "element",
+        _objectSpread(_objectSpread({}, props), attributes),
+        children
+      );
     };
   };
 
@@ -8328,50 +8731,45 @@ const deserializeHtmlNodeChildren = (editor, node) => {
  */
 
 const htmlBodyToFragment = (editor, element) => {
-  if (element.nodeName === 'BODY') {
-    return jsx('fragment', {}, deserializeHtmlNodeChildren(editor, element));
+  if (element.nodeName === "BODY") {
+    return jsx("fragment", {}, deserializeHtmlNodeChildren(editor, element));
   }
 };
 
 /**
  * Deserialize HTML to break line.
  */
-const htmlBrToNewLine = node => {
-  if (node.nodeName === 'BR') {
-    return '\n';
+const htmlBrToNewLine = (node) => {
+  if (node.nodeName === "BR") {
+    return "\n";
   }
 };
 
 /**
  * Get a deserializer by type, node names, class names and styles.
  */
-const pluginDeserializeHtml = (plugin, {
-  element: el,
-  deserializeLeaf
-}) => {
+const pluginDeserializeHtml = (plugin, { element: el, deserializeLeaf }) => {
   const {
     deserializeHtml: _deserializeHtml,
     isElement: isElementRoot,
     isLeaf: isLeafRoot,
-    type
+    type,
   } = plugin;
   if (!_deserializeHtml) return;
   let node;
   const deserializeHtmls = castArray_1(_deserializeHtml);
-  const deserialized = deserializeHtmls.find(deserializeHtml => {
+  const deserialized = deserializeHtmls.find((deserializeHtml) => {
     const {
-      validNodeName: nodeName = '*',
+      validNodeName: nodeName = "*",
       validStyle,
       validClassName,
       validAttribute,
       attributeNames,
       query,
       isLeaf: isLeafRule,
-      isElement: isElementRule
-    } = deserializeHtml;
-    let {
-      getNode
+      isElement: isElementRule,
     } = deserializeHtml;
+    let { getNode } = deserializeHtml;
     const isElement = isElementRule || isElementRoot;
     const isLeaf = isLeafRule || isLeafRoot;
 
@@ -8390,11 +8788,11 @@ const pluginDeserializeHtml = (plugin, {
     if (!getNode) {
       if (isElement) {
         getNode = () => ({
-          type
+          type,
         });
       } else if (isLeaf) {
         getNode = () => ({
-          [type]: true
+          [type]: true,
         });
       } else {
         return;
@@ -8404,10 +8802,10 @@ const pluginDeserializeHtml = (plugin, {
     if (nodeName) {
       const validNodeName = castArray_1(nodeName); // Ignore if el nodeName is not included in rule validNodeName (except *).
 
-      if (validNodeName.length && !validNodeName.includes(el.nodeName) && nodeName !== '*') return false;
+      if (validNodeName.length && !validNodeName.includes(el.nodeName) && nodeName !== "*")
+        return false;
     } // Ignore if the rule className is not in el class list.
 
-
     if (validClassName && !el.className.includes(validClassName)) return false;
 
     if (validStyle) {
@@ -8416,10 +8814,13 @@ const pluginDeserializeHtml = (plugin, {
 
         const values = castArray_1(value); // Ignore if el style value is not included in rule style values (except *)
 
-        if (!values.includes(el.style[key]) && value !== '*') return false; // Ignore if el style value is falsy (for value *)
+        if (!values.includes(el.style[key]) && value !== "*") return false; // Ignore if el style value is falsy (for value *)
 
-        if (value === '*' && !el.style[key]) return false;
-        const defaultNodeValue = (_plugin$inject$props = plugin.inject.props) === null || _plugin$inject$props === void 0 ? void 0 : _plugin$inject$props.defaultNodeValue; // Ignore if the style value = plugin.inject.props.defaultNodeValue
+        if (value === "*" && !el.style[key]) return false;
+        const defaultNodeValue =
+          (_plugin$inject$props = plugin.inject.props) === null || _plugin$inject$props === void 0
+            ? void 0
+            : _plugin$inject$props.defaultNodeValue; // Ignore if the style value = plugin.inject.props.defaultNodeValue
 
         if (defaultNodeValue && defaultNodeValue === el.style[key]) {
           return false;
@@ -8428,7 +8829,7 @@ const pluginDeserializeHtml = (plugin, {
     }
 
     if (validAttribute) {
-      if (typeof validAttribute === 'string') {
+      if (typeof validAttribute === "string") {
         if (!el.getAttributeNames().includes(validAttribute)) return false;
       } else {
         for (const [attributeName, attributeValue] of Object.entries(validAttribute)) {
@@ -8461,17 +8862,15 @@ const pluginDeserializeHtml = (plugin, {
   });
 
   if (deserialized) {
-    return { ...deserialized,
-      node: node
-    };
+    return { ...deserialized, node: node };
   }
 };
 
 const pipeDeserializeHtmlElement = (editor, element) => {
   let result;
-  editor.plugins.reverse().some(plugin => {
+  editor.plugins.reverse().some((plugin) => {
     result = pluginDeserializeHtml(plugin, {
-      element
+      element,
     });
     return !!result;
   });
@@ -8488,19 +8887,21 @@ const htmlElementToElement = (editor, element) => {
   if (deserialized) {
     var _node$children;
 
-    const {
-      node,
-      withoutChildren
-    } = deserialized;
-    let descendants = (_node$children = node.children) !== null && _node$children !== void 0 ? _node$children : deserializeHtmlNodeChildren(editor, element);
+    const { node, withoutChildren } = deserialized;
+    let descendants =
+      (_node$children = node.children) !== null && _node$children !== void 0
+        ? _node$children
+        : deserializeHtmlNodeChildren(editor, element);
 
     if (!descendants.length || withoutChildren) {
-      descendants = [{
-        text: ''
-      }];
+      descendants = [
+        {
+          text: "",
+        },
+      ];
     }
 
-    return jsx('element', node, descendants);
+    return jsx("element", node, descendants);
   }
 };
 
@@ -8508,23 +8909,19 @@ const htmlElementToElement = (editor, element) => {
  * Recursively merge a source object to children nodes with a query.
  */
 
-const mergeDeepToNodes = options => {
-  applyDeepToNodes({ ...options,
-    apply: merge_1
-  });
+const mergeDeepToNodes = (options) => {
+  applyDeepToNodes({ ...options, apply: merge_1 });
 };
 
 const pipeDeserializeHtmlLeaf = (editor, element) => {
   let node = {};
-  editor.plugins.reverse().forEach(plugin => {
+  editor.plugins.reverse().forEach((plugin) => {
     const deserialized = pluginDeserializeHtml(plugin, {
       element,
-      deserializeLeaf: true
+      deserializeLeaf: true,
     });
     if (!deserialized) return;
-    node = { ...node,
-      ...deserialized.node
-    };
+    node = { ...node, ...deserialized.node };
   });
   return node;
 };
@@ -8545,32 +8942,31 @@ const htmlElementToLeaf = (editor, element) => {
           node: child,
           source: node,
           query: {
-            filter: ([n]) => Text.isText(n)
-          }
+            filter: ([n]) => Text.isText(n),
+          },
         });
       }
 
       arr.push(child);
     } else {
-      const attributes = { ...node
-      }; // attributes should not override child attributes
+      const attributes = { ...node }; // attributes should not override child attributes
 
       if (child.text) {
-        Object.keys(attributes).forEach(key => {
+        Object.keys(attributes).forEach((key) => {
           if (attributes[key] && child[key]) {
             attributes[key] = child[key];
           }
         });
       }
 
-      arr.push(jsx('text', attributes, child));
+      arr.push(jsx("text", attributes, child));
     }
 
     return arr;
   }, []);
 };
 
-const isHtmlText = node => node.nodeType === Node.TEXT_NODE;
+const isHtmlText = (node) => node.nodeType === Node.TEXT_NODE;
 
 /**
  * Deserialize HTML text node to text.
@@ -8580,19 +8976,19 @@ const isHtmlText = node => node.nodeType === Node.TEXT_NODE;
 //   }
 // };
 
-const htmlTextNodeToString = node => {
+const htmlTextNodeToString = (node) => {
   if (isHtmlText(node)) {
-    return node.nodeValue === '\n' ? null : node.textContent;
+    return node.nodeValue === "\n" ? null : node.textContent;
   }
 };
 
-const isHtmlElement = node => node.nodeType === Node.ELEMENT_NODE;
+const isHtmlElement = (node) => node.nodeType === Node.ELEMENT_NODE;
 
 /**
  * Deserialize HTML element or child node.
  */
 
-const deserializeHtmlNode = editor => node => {
+const deserializeHtmlNode = (editor) => (node) => {
   const textNode = htmlTextNodeToString(node);
   if (textNode) return textNode;
   if (!isHtmlElement(node)) return null; // break line
@@ -8621,50 +9017,45 @@ const deserializeHtmlElement = (editor, element) => {
  * Deserialize HTML element to a valid document fragment.
  */
 
-const deserializeHtml = (editor, {
-  element,
-  stripWhitespace = true
-}) => {
+const deserializeHtml = (editor, { element, stripWhitespace = true }) => {
   // for serializer
-  if (typeof element === 'string') {
+  if (typeof element === "string") {
     element = htmlStringToDOMNode(element, stripWhitespace);
   }
 
   const fragment = deserializeHtmlElement(editor, element);
   return normalizeDescendantsToDocumentFragment(editor, {
-    descendants: fragment
+    descendants: fragment,
   });
 };
 
-const parseHtmlDocument = html => {
-  return new DOMParser().parseFromString(html, 'text/html');
+const parseHtmlDocument = (html) => {
+  return new DOMParser().parseFromString(html, "text/html");
 };
 
-const KEY_DESERIALIZE_HTML = 'deserializeHtml';
+const KEY_DESERIALIZE_HTML = "deserializeHtml";
 /**
  * Enables support for deserializing inserted content from HTML format to Slate format.
  */
 
 const createDeserializeHtmlPlugin = createPluginFactory({
   key: KEY_DESERIALIZE_HTML,
-  then: editor => ({
+  then: (editor) => ({
     editor: {
       insertData: {
-        format: 'text/html',
-        getFragment: ({
-          data
-        }) => {
+        format: "text/html",
+        getFragment: ({ data }) => {
           const document = parseHtmlDocument(data);
           return deserializeHtml(editor, {
-            element: document.body
+            element: document.body,
           });
-        }
-      }
-    }
-  })
+        },
+      },
+    },
+  }),
 });
 
-const KEY_DESERIALIZE_AST = 'deserializeAst';
+const KEY_DESERIALIZE_AST = "deserializeAst";
 /**
  * Enables support for deserializing inserted content from Slate Ast format to Slate format
  * while apply a small bug fix.
@@ -8674,39 +9065,36 @@ const createDeserializeAstPlugin = createPluginFactory({
   key: KEY_DESERIALIZE_AST,
   editor: {
     insertData: {
-      format: 'application/x-slate-fragment',
-      getFragment: ({
-        data
-      }) => {
+      format: "application/x-slate-fragment",
+      getFragment: ({ data }) => {
         const decoded = decodeURIComponent(window.atob(data));
         return JSON.parse(decoded);
-      }
-    }
-  }
+      },
+    },
+  },
 });
 
-const {
-  setState: set
-} = eventEditorStore;
+const { setState: set } = eventEditorStore;
 /**
  * Set an editor id by event key.
  */
 
-const setEventEditorId = (event, value) => set(() => ({
-  [event]: value
-}));
+const setEventEditorId = (event, value) =>
+  set(() => ({
+    [event]: value,
+  }));
 
-const KEY_EVENT_EDITOR = 'event-editor';
+const KEY_EVENT_EDITOR = "event-editor";
 const createEventEditorPlugin = createPluginFactory({
   key: KEY_EVENT_EDITOR,
   handlers: {
-    onFocus: editor => () => {
-      setEventEditorId('focus', editor.id);
+    onFocus: (editor) => () => {
+      setEventEditorId("focus", editor.id);
     },
-    onBlur: editor => () => {
-      setEventEditorId('blur', editor.id);
-    }
-  }
+    onBlur: (editor) => () => {
+      setEventEditorId("blur", editor.id);
+    },
+  },
 });
 
 /**
@@ -8714,42 +9102,38 @@ const createEventEditorPlugin = createPluginFactory({
  */
 
 const createHistoryPlugin = createPluginFactory({
-  key: 'history',
-  withOverrides: withHistory
+  key: "history",
+  withOverrides: withHistory,
 });
 
-const KEY_INLINE_VOID = 'inline-void';
+const KEY_INLINE_VOID = "inline-void";
 /**
  * Merge and register all the inline types and void types from the plugins and options,
  * using `editor.isInline` and `editor.isVoid`
  */
 
-const withInlineVoid = editor => {
-  const {
-    isInline
-  } = editor;
-  const {
-    isVoid
-  } = editor;
+const withInlineVoid = (editor) => {
+  const { isInline } = editor;
+  const { isVoid } = editor;
   const inlineTypes = [];
   const voidTypes = [];
-  editor.plugins.forEach(plugin => {
+  editor.plugins.forEach((plugin) => {
     if (!plugin.key) return;
 
     if (plugin.isInline) {
-      inlineTypes.push(plugin.key);
+      inlineTypes.push(plugin.type);
     }
 
     if (plugin.isVoid) {
-      voidTypes.push(plugin.key);
+      voidTypes.push(plugin.type);
     }
   });
 
-  editor.isInline = element => {
+  editor.isInline = (element) => {
     return inlineTypes.includes(element.type) ? true : isInline(element);
   };
 
-  editor.isVoid = element => voidTypes.includes(element.type) ? true : isVoid(element);
+  editor.isVoid = (element) => (voidTypes.includes(element.type) ? true : isVoid(element));
 
   return editor;
 };
@@ -8759,7 +9143,7 @@ const withInlineVoid = editor => {
 
 const createInlineVoidPlugin = createPluginFactory({
   key: KEY_INLINE_VOID,
-  withOverrides: withInlineVoid
+  withOverrides: withInlineVoid,
 });
 
 /**
@@ -8768,10 +9152,13 @@ const createInlineVoidPlugin = createPluginFactory({
  */
 const getInjectedPlugins = (editor, plugin) => {
   const injectedPlugins = [];
-  editor.plugins.forEach(p => {
+  editor.plugins.forEach((p) => {
     var _p$inject$pluginsByKe;
 
-    const injectedPlugin = (_p$inject$pluginsByKe = p.inject.pluginsByKey) === null || _p$inject$pluginsByKe === void 0 ? void 0 : _p$inject$pluginsByKe[plugin.key];
+    const injectedPlugin =
+      (_p$inject$pluginsByKe = p.inject.pluginsByKey) === null || _p$inject$pluginsByKe === void 0
+        ? void 0
+        : _p$inject$pluginsByKe[plugin.key];
     if (injectedPlugin) injectedPlugins.push(injectedPlugin);
   });
   return [plugin, ...injectedPlugins];
@@ -8780,31 +9167,44 @@ const getInjectedPlugins = (editor, plugin) => {
 /**
  * Is the plugin disabled by another plugin.
  */
-const pipeInsertDataQuery = (plugins, {
-  data,
-  dataTransfer
-}) => plugins.every(p => {
-  var _p$editor, _p$editor$insertData;
+const pipeInsertDataQuery = (plugins, { data, dataTransfer }) =>
+  plugins.every((p) => {
+    var _p$editor, _p$editor$insertData;
 
-  const query = (_p$editor = p.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : _p$editor$insertData.query;
-  return !query || query({
-    data,
-    dataTransfer
+    const query =
+      (_p$editor = p.editor) === null || _p$editor === void 0
+        ? void 0
+        : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0
+        ? void 0
+        : _p$editor$insertData.query;
+    return (
+      !query ||
+      query({
+        data,
+        dataTransfer,
+      })
+    );
   });
-});
 
 /**
  * Pipe preInsert then insertFragment.
  */
-const pipeInsertFragment = (editor, injectedPlugins, {
-  fragment,
-  ...options
-}) => {
+const pipeInsertFragment = (editor, injectedPlugins, { fragment, ...options }) => {
   Editor.withoutNormalizing(editor, () => {
-    injectedPlugins.some(p => {
+    injectedPlugins.some((p) => {
       var _p$editor, _p$editor$insertData, _p$editor$insertData$;
 
-      return ((_p$editor = p.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : (_p$editor$insertData$ = _p$editor$insertData.preInsert) === null || _p$editor$insertData$ === void 0 ? void 0 : _p$editor$insertData$.call(_p$editor$insertData, fragment, options)) === true;
+      return (
+        ((_p$editor = p.editor) === null || _p$editor === void 0
+          ? void 0
+          : (_p$editor$insertData = _p$editor.insertData) === null ||
+            _p$editor$insertData === void 0
+          ? void 0
+          : (_p$editor$insertData$ = _p$editor$insertData.preInsert) === null ||
+            _p$editor$insertData$ === void 0
+          ? void 0
+          : _p$editor$insertData$.call(_p$editor$insertData, fragment, options)) === true
+      );
     });
     editor.insertFragment(fragment);
   });
@@ -8813,17 +9213,19 @@ const pipeInsertFragment = (editor, injectedPlugins, {
 /**
  * Pipe editor.insertData.transformData
  */
-const pipeTransformData = (plugins, {
-  data,
-  dataTransfer
-}) => {
-  plugins.forEach(p => {
+const pipeTransformData = (plugins, { data, dataTransfer }) => {
+  plugins.forEach((p) => {
     var _p$editor, _p$editor$insertData;
 
-    const transformData = (_p$editor = p.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : _p$editor$insertData.transformData;
+    const transformData =
+      (_p$editor = p.editor) === null || _p$editor === void 0
+        ? void 0
+        : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0
+        ? void 0
+        : _p$editor$insertData.transformData;
     if (!transformData) return;
     data = transformData(data, {
-      dataTransfer
+      dataTransfer,
     });
   });
   return data;
@@ -8832,66 +9234,69 @@ const pipeTransformData = (plugins, {
 /**
  * Pipe editor.insertData.transformFragment
  */
-const pipeTransformFragment = (plugins, {
-  fragment,
-  ...options
-}) => {
-  plugins.forEach(p => {
+const pipeTransformFragment = (plugins, { fragment, ...options }) => {
+  plugins.forEach((p) => {
     var _p$editor, _p$editor$insertData;
 
-    const transformFragment = (_p$editor = p.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : _p$editor$insertData.transformFragment;
+    const transformFragment =
+      (_p$editor = p.editor) === null || _p$editor === void 0
+        ? void 0
+        : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0
+        ? void 0
+        : _p$editor$insertData.transformFragment;
     if (!transformFragment) return;
     fragment = transformFragment(fragment, options);
   });
   return fragment;
 };
 
-const withInsertData = editor => {
-  const {
-    insertData
-  } = editor;
+const withInsertData = (editor) => {
+  const { insertData } = editor;
 
-  editor.insertData = dataTransfer => {
-    const inserted = editor.plugins.reverse().some(plugin => {
+  editor.insertData = (dataTransfer) => {
+    const inserted = editor.plugins.reverse().some((plugin) => {
       var _fragment;
 
       const insertDataOptions = plugin.editor.insertData;
       if (!insertDataOptions) return false;
       const injectedPlugins = getInjectedPlugins(editor, plugin);
-      const {
-        format,
-        getFragment
-      } = insertDataOptions;
+      const { format, getFragment } = insertDataOptions;
       if (!format) return false;
       let data = dataTransfer.getData(format);
       if (!data) return;
 
-      if (!pipeInsertDataQuery(injectedPlugins, {
-        data,
-        dataTransfer
-      })) {
+      if (
+        !pipeInsertDataQuery(injectedPlugins, {
+          data,
+          dataTransfer,
+        })
+      ) {
         return false;
       }
 
       data = pipeTransformData(injectedPlugins, {
         data,
-        dataTransfer
-      });
-      let fragment = getFragment === null || getFragment === void 0 ? void 0 : getFragment({
-        data,
-        dataTransfer
+        dataTransfer,
       });
-      if (!((_fragment = fragment) !== null && _fragment !== void 0 && _fragment.length)) return false;
+      let fragment =
+        getFragment === null || getFragment === void 0
+          ? void 0
+          : getFragment({
+              data,
+              dataTransfer,
+            });
+      if (!((_fragment = fragment) !== null && _fragment !== void 0 && _fragment.length))
+        return false;
       fragment = pipeTransformFragment(injectedPlugins, {
         fragment,
         data,
-        dataTransfer
+        dataTransfer,
       });
       if (!fragment.length) return false;
       pipeInsertFragment(editor, injectedPlugins, {
         fragment,
         data,
-        dataTransfer
+        dataTransfer,
       });
       return true;
     });
@@ -8901,10 +9306,10 @@ const withInsertData = editor => {
 
   return editor;
 };
-const KEY_INSERT_DATA = 'insertData';
+const KEY_INSERT_DATA = "insertData";
 const createInsertDataPlugin = createPluginFactory({
   key: KEY_INSERT_DATA,
-  withOverrides: withInsertData
+  withOverrides: withInsertData,
 });
 
 /**
@@ -8912,8 +9317,8 @@ const createInsertDataPlugin = createPluginFactory({
  */
 
 const createReactPlugin = createPluginFactory({
-  key: 'react',
-  withOverrides: withReact
+  key: "react",
+  withOverrides: withReact,
 });
 
 /**
@@ -8923,11 +9328,7 @@ const createReactPlugin = createPluginFactory({
  * - `key`: random key for the <Slate> component so each time the editor is created, the component resets.
  * - `options`: Plate options
  */
-const withPlate = (e, {
-  id = 'main',
-  plugins = [],
-  disableCorePlugins
-} = {}) => {
+const withPlate = (e, { id = "main", plugins = [], disableCorePlugins } = {}) => {
   let editor = e;
   editor.id = id;
 
@@ -8938,8 +9339,16 @@ const withPlate = (e, {
   let allPlugins = [];
 
   if (disableCorePlugins !== true) {
-    if (typeof disableCorePlugins !== 'object') {
-      allPlugins = [createReactPlugin(), createHistoryPlugin(), createEventEditorPlugin(), createInlineVoidPlugin(), createInsertDataPlugin(), createDeserializeAstPlugin(), createDeserializeHtmlPlugin()];
+    if (typeof disableCorePlugins !== "object") {
+      allPlugins = [
+        createReactPlugin(),
+        createHistoryPlugin(),
+        createEventEditorPlugin(),
+        createInlineVoidPlugin(),
+        createInsertDataPlugin(),
+        createDeserializeAstPlugin(),
+        createDeserializeHtmlPlugin(),
+      ];
     } else {
       if (!disableCorePlugins.react) {
         allPlugins.push(createReactPlugin());
@@ -8974,7 +9383,7 @@ const withPlate = (e, {
   allPlugins = [...allPlugins, ...plugins];
   setPlatePlugins(editor, allPlugins); // withOverrides
 
-  editor.plugins.forEach(plugin => {
+  editor.plugins.forEach((plugin) => {
     if (plugin.withOverrides) {
       editor = plugin.withOverrides(editor, plugin);
     }
@@ -8982,12 +9391,14 @@ const withPlate = (e, {
   return editor;
 };
 
-const getPlateEnabled = id => {
+const getPlateEnabled = (id) => {
   var _getPlateState;
 
-  return (_getPlateState = getPlateState(id)) === null || _getPlateState === void 0 ? void 0 : _getPlateState.enabled;
+  return (_getPlateState = getPlateState(id)) === null || _getPlateState === void 0
+    ? void 0
+    : _getPlateState.enabled;
 };
-const usePlateEnabled = id => usePlateStore(useCallback(() => getPlateEnabled(id), [id]));
+const usePlateEnabled = (id) => usePlateStore(useCallback(() => getPlateEnabled(id), [id]));
 
 /**
  * Effects to update the plate store from the options.
@@ -8995,34 +9406,31 @@ const usePlateEnabled = id => usePlateStore(useCallback(() => getPlateEnabled(id
  */
 
 const usePlateEffects = ({
-  id = 'main',
+  id = "main",
   value,
   editor: editorProp,
   enabled: enabledProp = true,
   initialValue,
   normalizeInitialValue,
   plugins,
-  disableCorePlugins
+  disableCorePlugins,
 }) => {
-  const {
-    setInitialState,
-    setValue,
-    setEditor,
-    setEnabled,
-    clearState
-  } = usePlateActions(id);
+  const { setInitialState, setValue, setEditor, setEnabled, clearState } = usePlateActions(id);
   const enabled = usePlateEnabled(id);
   const editor = usePlateEditorRef(id);
   const prevEditorRef = useRef(editor); // Clear the state on unmount.
 
-  useEffect(() => () => {
-    clearState();
-  }, [clearState, id]); // Set initial state on mount
+  useEffect(
+    () => () => {
+      clearState();
+    },
+    [clearState, id]
+  ); // Set initial state on mount
 
   useEffect(() => {
     setInitialState({
       enabled: true,
-      value: []
+      value: [],
     });
   }, [id, setInitialState]); // Set initialValue once
 
@@ -9032,11 +9440,17 @@ const usePlateEffects = ({
 
   useEffect(() => {
     value && setValue(value);
-    !initialValue && !value && setValue([{
-      children: [{
-        text: ''
-      }]
-    }]);
+    !initialValue &&
+      !value &&
+      setValue([
+        {
+          children: [
+            {
+              text: "",
+            },
+          ],
+        },
+      ]);
   }, [initialValue, setValue, value]); // Dynamic enabled
 
   useEffect(() => {
@@ -9051,12 +9465,15 @@ const usePlateEffects = ({
 
   useEffect(() => {
     if (!editor && enabled) {
-      const baseEditor = editorProp !== null && editorProp !== void 0 ? editorProp : createEditor$1();
-      setEditor(withPlate(baseEditor, {
-        id,
-        plugins: plugins,
-        disableCorePlugins
-      }));
+      const baseEditor =
+        editorProp !== null && editorProp !== void 0 ? editorProp : createEditor$1();
+      setEditor(
+        withPlate(baseEditor, {
+          id,
+          plugins: plugins,
+          disableCorePlugins,
+        })
+      );
     }
   }, [editorProp, id, plugins, setEditor, editor, enabled, disableCorePlugins]); // Dynamic plugins, no called when setting the editor
 
@@ -9071,7 +9488,7 @@ const usePlateEffects = ({
   useEffect(() => {
     if (editor && normalizeInitialValue) {
       Editor.normalize(editor, {
-        force: true
+        force: true,
       });
     }
   }, [editor, normalizeInitialValue]); // Store previous editor
@@ -9081,27 +9498,37 @@ const usePlateEffects = ({
   }, [editor]);
 };
 
-const getPlateValue = id => {
+const getPlateValue = (id) => {
   var _getPlateState;
 
-  return (_getPlateState = getPlateState(id)) === null || _getPlateState === void 0 ? void 0 : _getPlateState.value;
+  return (_getPlateState = getPlateState(id)) === null || _getPlateState === void 0
+    ? void 0
+    : _getPlateState.value;
 };
-const usePlateValue = id => usePlateStore(useCallback(() => getPlateValue(id), [id]));
+const usePlateValue = (id) => usePlateStore(useCallback(() => getPlateValue(id), [id]));
 
-const pipeOnChange = editor => {
-  const onChanges = editor.plugins.flatMap(plugin => {
+const pipeOnChange = (editor) => {
+  const onChanges = editor.plugins.flatMap((plugin) => {
     var _plugin$handlers$onCh, _plugin$handlers, _plugin$handlers$onCh2;
 
-    return (_plugin$handlers$onCh = (_plugin$handlers = plugin.handlers) === null || _plugin$handlers === void 0 ? void 0 : (_plugin$handlers$onCh2 = _plugin$handlers.onChange) === null || _plugin$handlers$onCh2 === void 0 ? void 0 : _plugin$handlers$onCh2.call(_plugin$handlers, editor, plugin)) !== null && _plugin$handlers$onCh !== void 0 ? _plugin$handlers$onCh : [];
+    return (_plugin$handlers$onCh =
+      (_plugin$handlers = plugin.handlers) === null || _plugin$handlers === void 0
+        ? void 0
+        : (_plugin$handlers$onCh2 = _plugin$handlers.onChange) === null ||
+          _plugin$handlers$onCh2 === void 0
+        ? void 0
+        : _plugin$handlers$onCh2.call(_plugin$handlers, editor, plugin)) !== null &&
+      _plugin$handlers$onCh !== void 0
+      ? _plugin$handlers$onCh
+      : [];
   });
-  return nodes => {
-    return onChanges.some(handler => {
+  return (nodes) => {
+    return onChanges.some((handler) => {
       if (!handler) {
         return false;
       } // The custom event handler may return a boolean to specify whether the event
       // shall be treated as being handled or not.
 
-
       const shouldTreatEventAsHandled = handler(nodes);
 
       if (shouldTreatEventAsHandled != null) {
@@ -9117,32 +9544,33 @@ const pipeOnChange = editor => {
  * Get Slate props stored in a global store.
  */
 
-const useSlateProps = ({
-  id,
-  onChange: _onChange
-} = {}) => {
-  const {
-    setValue
-  } = usePlateActions(id);
+const useSlateProps = ({ id, onChange: _onChange } = {}) => {
+  const { setValue } = usePlateActions(id);
   const editor = usePlateEditorRef(id);
-  const keyPlugins = usePlateKey('keyPlugins', id);
+  const keyPlugins = usePlateKey("keyPlugins", id);
   const value = usePlateValue(id);
-  const onChange = useCallback(newValue => {
-    if (!editor || !keyPlugins) return;
-    const eventIsHandled = pipeOnChange(editor)(newValue);
+  const onChange = useCallback(
+    (newValue) => {
+      if (!editor || !keyPlugins) return;
+      const eventIsHandled = pipeOnChange(editor)(newValue);
 
-    if (!eventIsHandled) {
-      _onChange === null || _onChange === void 0 ? void 0 : _onChange(newValue);
-    }
+      if (!eventIsHandled) {
+        _onChange === null || _onChange === void 0 ? void 0 : _onChange(newValue);
+      }
 
-    setValue(newValue);
-  }, [_onChange, editor, keyPlugins, setValue]);
-  return useMemo(() => ({
-    key: editor === null || editor === void 0 ? void 0 : editor.key,
-    editor,
-    onChange,
-    value
-  }), [editor, onChange, value]);
+      setValue(newValue);
+    },
+    [_onChange, editor, keyPlugins, setValue]
+  );
+  return useMemo(
+    () => ({
+      key: editor === null || editor === void 0 ? void 0 : editor.key,
+      editor,
+      onChange,
+      value,
+    }),
+    [editor, onChange, value]
+  );
 };
 
 /**
@@ -9158,7 +9586,7 @@ const usePlate = ({
   plugins,
   onChange,
   editableProps,
-  normalizeInitialValue
+  normalizeInitialValue,
 }) => {
   usePlateEffects({
     id,
@@ -9166,28 +9594,26 @@ const usePlate = ({
     initialValue,
     editor,
     value,
-    normalizeInitialValue
+    normalizeInitialValue,
   });
   return {
     slateProps: useSlateProps({
       id,
-      onChange
+      onChange,
     }),
     editableProps: useEditableProps({
       id,
-      editableProps
-    })
+      editableProps,
+    }),
   };
 };
 
 /**
  * {@link Editable} with plugins support.
  */
-const EditablePlugins = props => {
-  const {
-    editableProps
-  } = usePlate(props);
-  return /*#__PURE__*/React.createElement(Editable, editableProps);
+const EditablePlugins = (props) => {
+  const { editableProps } = usePlate(props);
+  return /*#__PURE__*/ React.createElement(Editable, editableProps);
 };
 
 /**
@@ -9197,33 +9623,30 @@ const EditablePlugins = props => {
  */
 const useEditorState = () => useSlate();
 
-const EditorStateEffect = /*#__PURE__*/memo(({
-  id
-}) => {
+const EditorStateEffect = /*#__PURE__*/ memo(({ id }) => {
   const editorState = useEditorState();
   useEffect(() => {
-    incrementKey('keyEditor', id);
+    incrementKey("keyEditor", id);
   });
   useEffect(() => {
-    incrementKey('keySelection', id);
+    incrementKey("keySelection", id);
   }, [editorState.selection, id]);
   return null;
 });
 
-const Plate = ({
-  children,
-  renderEditable,
-  ...options
-}) => {
-  const {
-    slateProps,
-    editableProps
-  } = usePlate(options);
+const Plate = ({ children, renderEditable, ...options }) => {
+  const { slateProps, editableProps } = usePlate(options);
   if (!slateProps.editor) return null;
-  const editable = /*#__PURE__*/React.createElement(Editable, editableProps);
-  return /*#__PURE__*/React.createElement(Slate, slateProps, children, /*#__PURE__*/React.createElement(EditorStateEffect, {
-    id: options.id
-  }), renderEditable ? renderEditable(editable) : editable);
+  const editable = /*#__PURE__*/ React.createElement(Editable, editableProps);
+  return /*#__PURE__*/ React.createElement(
+    Slate,
+    slateProps,
+    children,
+    /*#__PURE__*/ React.createElement(EditorStateEffect, {
+      id: options.id,
+    }),
+    renderEditable ? renderEditable(editable) : editable
+  );
 };
 
 /**
@@ -9233,12 +9656,10 @@ const Plate = ({
  */
 const useEditorRef = () => useSlateStatic();
 
-const isHtmlComment = node => node.nodeType === Node.COMMENT_NODE;
+const isHtmlComment = (node) => node.nodeType === Node.COMMENT_NODE;
 
-const parseHtmlElement = html => {
-  const {
-    body
-  } = parseHtmlDocument(html);
+const parseHtmlElement = (html) => {
+  const { body } = parseHtmlDocument(html);
   return body.firstElementChild;
 };
 
@@ -9247,7 +9668,7 @@ const parseHtmlElement = html => {
  * By default, it will use an empty editor.
  * TODO: allow other providers
  */
-const createElementWithSlate = slateProps => {
+const createElementWithSlate = (slateProps) => {
   const {
     editor = withReact(createEditor$1()),
     value = [],
@@ -9255,42 +9676,43 @@ const createElementWithSlate = slateProps => {
     children,
     ...props
   } = slateProps || {};
-  return /*#__PURE__*/React.createElement(Slate, {
-    editor,
-    value,
-    onChange,
-    ...props
-  }, children);
+  return /*#__PURE__*/ React.createElement(
+    Slate,
+    {
+      editor,
+      value,
+      onChange,
+      ...props,
+    },
+    children
+  );
 };
 
 /**
  * Remove all class names that do not start with one of preserveClassNames (`slate-` by default)
  */
-const stripClassNames = (html, {
-  preserveClassNames = ['slate-']
-}) => {
+const stripClassNames = (html, { preserveClassNames = ["slate-"] }) => {
   const allClasses = html.split(/(class="[^"]*")/g);
-  let filteredHtml = '';
+  let filteredHtml = "";
   allClasses.forEach((item, index) => {
     if (index % 2 === 0) {
-      return filteredHtml += item;
+      return (filteredHtml += item);
     }
 
-    const preserveRegExp = new RegExp(preserveClassNames.map(cn => `${cn}[^"\\s]*`).join('|'), 'g');
+    const preserveRegExp = new RegExp(
+      preserveClassNames.map((cn) => `${cn}[^"\\s]*`).join("|"),
+      "g"
+    );
     const slateClassNames = item.match(preserveRegExp);
 
     if (slateClassNames) {
-      filteredHtml += `class="${slateClassNames.join(' ')}"`;
+      filteredHtml += `class="${slateClassNames.join(" ")}"`;
     }
   });
   return filteredHtml;
 };
 
-const elementToHtml = (editor, {
-  props,
-  slateProps,
-  preserveClassNames
-}) => {
+const elementToHtml = (editor, { props, slateProps, preserveClassNames }) => {
   let html = `<div>${props.children}</div>`; // If no type provided we wrap children with div tag
 
   if (!props.element.type) {
@@ -9299,50 +9721,61 @@ const elementToHtml = (editor, {
 
   props = pipeInjectProps(editor, props); // Search for matching plugin based on element type
 
-  editor.plugins.some(plugin => {
+  editor.plugins.some((plugin) => {
     var _plugin$serializeHtml, _plugin$serializeHtml2;
 
-    if (!plugin.isElement || plugin.serializeHtml === null || props.element.type !== plugin.type) return false; // Render element using picked plugins renderElement function and ReactDOM
-
-    html = renderToStaticMarkup(createElementWithSlate({ ...slateProps,
-      children: (_plugin$serializeHtml = (_plugin$serializeHtml2 = plugin.serializeHtml) === null || _plugin$serializeHtml2 === void 0 ? void 0 : _plugin$serializeHtml2.call(plugin, props)) !== null && _plugin$serializeHtml !== void 0 ? _plugin$serializeHtml : pluginRenderElement(editor, plugin)(props)
-    }));
+    if (!plugin.isElement || plugin.serializeHtml === null || props.element.type !== plugin.type)
+      return false; // Render element using picked plugins renderElement function and ReactDOM
+
+    html = renderToStaticMarkup(
+      createElementWithSlate({
+        ...slateProps,
+        children:
+          (_plugin$serializeHtml =
+            (_plugin$serializeHtml2 = plugin.serializeHtml) === null ||
+            _plugin$serializeHtml2 === void 0
+              ? void 0
+              : _plugin$serializeHtml2.call(plugin, props)) !== null &&
+          _plugin$serializeHtml !== void 0
+            ? _plugin$serializeHtml
+            : pluginRenderElement(editor, plugin)(props),
+      })
+    );
     html = stripClassNames(html, {
-      preserveClassNames
+      preserveClassNames,
     });
     return true;
   });
   return html;
 };
 
-const leafToHtml = (editor, {
-  props,
-  slateProps,
-  preserveClassNames
-}) => {
-  const {
-    children
-  } = props;
+const leafToHtml = (editor, { props, slateProps, preserveClassNames }) => {
+  const { children } = props;
   return editor.plugins.reduce((result, plugin) => {
     var _plugin$serializeHtml, _plugin$serializeHtml2;
 
     if (!plugin.isLeaf) return result;
-    props = { ...pipeInjectProps(editor, props),
-      children: encodeURIComponent(result)
-    };
-    const serialized = (_plugin$serializeHtml = (_plugin$serializeHtml2 = plugin.serializeHtml) === null || _plugin$serializeHtml2 === void 0 ? void 0 : _plugin$serializeHtml2.call(plugin, props)) !== null && _plugin$serializeHtml !== void 0 ? _plugin$serializeHtml : pluginRenderLeaf(editor, plugin)(props);
+    props = { ...pipeInjectProps(editor, props), children: encodeURIComponent(result) };
+    const serialized =
+      (_plugin$serializeHtml =
+        (_plugin$serializeHtml2 = plugin.serializeHtml) === null ||
+        _plugin$serializeHtml2 === void 0
+          ? void 0
+          : _plugin$serializeHtml2.call(plugin, props)) !== null && _plugin$serializeHtml !== void 0
+        ? _plugin$serializeHtml
+        : pluginRenderLeaf(editor, plugin)(props);
     if (serialized === children) return result;
-    let html = decodeURIComponent(renderToStaticMarkup(createElementWithSlate({ ...slateProps,
-      children: serialized
-    })));
+    let html = decodeURIComponent(
+      renderToStaticMarkup(createElementWithSlate({ ...slateProps, children: serialized }))
+    );
     html = stripClassNames(html, {
-      preserveClassNames
+      preserveClassNames,
     });
     return html;
   }, children);
 };
 
-const isEncoded = (str = '') => {
+const isEncoded = (str = "") => {
   try {
     return str !== decodeURIComponent(str);
   } catch (error) {
@@ -9351,57 +9784,61 @@ const isEncoded = (str = '') => {
 };
 
 // Remove redundant data attributes
-const stripSlateDataAttributes = rawHtml => rawHtml.replace(/( data-slate)(-node|-type|-leaf)="[^"]+"/gm, '').replace(/( data-testid)="[^"]+"/gm, '');
+const stripSlateDataAttributes = (rawHtml) =>
+  rawHtml
+    .replace(/( data-slate)(-node|-type|-leaf)="[^"]+"/gm, "")
+    .replace(/( data-testid)="[^"]+"/gm, "");
 
 // Remove extra whitespace generated by ReactDOMServer
-const trimWhitespace = rawHtml => rawHtml.replace(/(\r\n|\n|\r|\t)/gm, '');
+const trimWhitespace = (rawHtml) => rawHtml.replace(/(\r\n|\n|\r|\t)/gm, "");
 
 /**
  * Convert Slate Nodes into HTML string
  */
 
-const serializeHtml = (editor, {
-  nodes,
-  slateProps,
-  stripDataAttributes = true,
-  preserveClassNames,
-  stripWhitespace = true
-}) => {
-  let result = nodes.map(node => {
-    if (Text.isText(node)) {
-      return leafToHtml(editor, {
+const serializeHtml = (
+  editor,
+  { nodes, slateProps, stripDataAttributes = true, preserveClassNames, stripWhitespace = true }
+) => {
+  let result = nodes
+    .map((node) => {
+      if (Text.isText(node)) {
+        return leafToHtml(editor, {
+          props: {
+            leaf: node,
+            text: node,
+            children: isEncoded(node.text) ? node.text : encodeURIComponent(node.text),
+            attributes: {
+              "data-slate-leaf": true,
+            },
+            editor,
+          },
+          slateProps,
+          preserveClassNames,
+        });
+      }
+
+      return elementToHtml(editor, {
         props: {
-          leaf: node,
-          text: node,
-          children: isEncoded(node.text) ? node.text : encodeURIComponent(node.text),
+          element: node,
+          children: encodeURIComponent(
+            serializeHtml(editor, {
+              nodes: node.children,
+              preserveClassNames,
+              stripWhitespace,
+            })
+          ),
           attributes: {
-            'data-slate-leaf': true
+            "data-slate-node": "element",
+            ref: null,
           },
-          editor
+          editor,
         },
         slateProps,
-        preserveClassNames
+        preserveClassNames,
       });
-    }
-
-    return elementToHtml(editor, {
-      props: {
-        element: node,
-        children: encodeURIComponent(serializeHtml(editor, {
-          nodes: node.children,
-          preserveClassNames,
-          stripWhitespace
-        })),
-        attributes: {
-          'data-slate-node': 'element',
-          ref: null
-        },
-        editor
-      },
-      slateProps,
-      preserveClassNames
-    });
-  }).join('');
+    })
+    .join("");
 
   if (isEncoded(result)) {
     result = decodeURIComponent(result);
@@ -9418,33 +9855,37 @@ const serializeHtml = (editor, {
   return result;
 };
 
-const getPlateEventId = event => getEventEditorState()[event];
+const getPlateEventId = (event) => getEventEditorState()[event];
 /**
  * Get plate id by `event` key.
  */
 
-const usePlateEventId = event => useEventEditorStore(() => getPlateEventId(event));
+const usePlateEventId = (event) => useEventEditorStore(() => getPlateEventId(event));
 
 /**
  * Get editor state which is updated on editor change.
  */
 
-const usePlateEditorState = id => {
+const usePlateEditorState = (id) => {
   usePlateStore(() => {
     var _getPlateState;
 
-    return (_getPlateState = getPlateState(id)) === null || _getPlateState === void 0 ? void 0 : _getPlateState.keyEditor;
+    return (_getPlateState = getPlateState(id)) === null || _getPlateState === void 0
+      ? void 0
+      : _getPlateState.keyEditor;
   });
   return usePlateEditorRef(id);
 };
 
-const getPlatePlugins = id => {
+const getPlatePlugins = (id) => {
   var _getPlateEditorRef;
 
-  return (_getPlateEditorRef = getPlateEditorRef(id)) === null || _getPlateEditorRef === void 0 ? void 0 : _getPlateEditorRef.plugins;
+  return (_getPlateEditorRef = getPlateEditorRef(id)) === null || _getPlateEditorRef === void 0
+    ? void 0
+    : _getPlateEditorRef.plugins;
 };
-const usePlatePlugins = id => {
-  usePlateKey('keyPlugins', id);
+const usePlatePlugins = (id) => {
+  usePlateKey("keyPlugins", id);
   return getPlatePlugins(id);
 };
 
@@ -9452,20 +9893,26 @@ const usePlatePlugins = id => {
  * Get the editor selection which is updated on editor change.
  */
 
-const usePlateSelection = id => {
+const usePlateSelection = (id) => {
   var _usePlateEditorRef;
 
-  usePlateKey('keySelection', id);
-  return (_usePlateEditorRef = usePlateEditorRef(id)) === null || _usePlateEditorRef === void 0 ? void 0 : _usePlateEditorRef.selection;
+  usePlateKey("keySelection", id);
+  return (_usePlateEditorRef = usePlateEditorRef(id)) === null || _usePlateEditorRef === void 0
+    ? void 0
+    : _usePlateEditorRef.selection;
 };
 
-const usePlateState = id => usePlateStore(useCallback(() => getPlateState(id), [id]), shallow);
+const usePlateState = (id) =>
+  usePlateStore(
+    useCallback(() => getPlateState(id), [id]),
+    shallow
+  );
 
-const isDescendant = node => isElement(node) || isText(node);
+const isDescendant = (node) => isElement(node) || isText(node);
 
 /** Used to compose bitmasks for cloning. */
 var CLONE_DEEP_FLAG = 1,
-    CLONE_SYMBOLS_FLAG = 4;
+  CLONE_SYMBOLS_FLAG = 4;
 
 /**
  * This method is like `_.clone` except that it recursively clones `value`.
@@ -9497,10 +9944,7 @@ var cloneDeep_1 = cloneDeep;
  * Any other properties can be overridden by key using `overrideByKey` in the second param.
  */
 
-const createPlugins = (plugins, {
-  components,
-  overrideByKey
-} = {}) => {
+const createPlugins = (plugins, { components, overrideByKey } = {}) => {
   let allOverrideByKey = {};
 
   if (overrideByKey) {
@@ -9508,14 +9952,14 @@ const createPlugins = (plugins, {
   }
 
   if (components) {
-    Object.keys(components).forEach(key => {
+    Object.keys(components).forEach((key) => {
       if (!allOverrideByKey[key]) allOverrideByKey[key] = {};
       allOverrideByKey[key].component = components[key];
     });
   }
 
   if (Object.keys(allOverrideByKey).length) {
-    return plugins.map(plugin => {
+    return plugins.map((plugin) => {
       return overridePluginsByKey(plugin, allOverrideByKey);
     });
   }
@@ -9538,47 +9982,264 @@ const createPlateEditor = ({
 } = {}) => {
   plugins = createPlugins(plugins, {
     components,
-    overrideByKey
+    overrideByKey,
   });
   return withPlate(editor, {
     plugins,
-    ...withPlateOptions
+    ...withPlateOptions,
   });
 };
 
 const getPluginInjectProps = (editor, key) => {
   var _getPlugin$inject$pro, _getPlugin$inject;
 
-  return (_getPlugin$inject$pro = (_getPlugin$inject = getPlugin(editor, key).inject) === null || _getPlugin$inject === void 0 ? void 0 : _getPlugin$inject.props) !== null && _getPlugin$inject$pro !== void 0 ? _getPlugin$inject$pro : {};
+  return (_getPlugin$inject$pro =
+    (_getPlugin$inject = getPlugin(editor, key).inject) === null || _getPlugin$inject === void 0
+      ? void 0
+      : _getPlugin$inject.props) !== null && _getPlugin$inject$pro !== void 0
+    ? _getPlugin$inject$pro
+    : {};
 };
 
 const getPluginOptions = (editor, key) => {
   var _getPlugin$options;
 
-  return (_getPlugin$options = getPlugin(editor, key).options) !== null && _getPlugin$options !== void 0 ? _getPlugin$options : {};
+  return (_getPlugin$options = getPlugin(editor, key).options) !== null &&
+    _getPlugin$options !== void 0
+    ? _getPlugin$options
+    : {};
 };
 
 /**
  * Get `editor.plugins`
  */
-const getPlugins = editor => {
+const getPlugins = (editor) => {
   var _editor$plugins;
 
-  return (_editor$plugins = editor === null || editor === void 0 ? void 0 : editor.plugins) !== null && _editor$plugins !== void 0 ? _editor$plugins : [];
+  return (_editor$plugins = editor === null || editor === void 0 ? void 0 : editor.plugins) !==
+    null && _editor$plugins !== void 0
+    ? _editor$plugins
+    : [];
 };
 
-const mockPlugin = plugin => ({
-  key: '',
-  type: '',
+const mockPlugin = (plugin) => ({
+  key: "",
+  type: "",
   editor: {},
   inject: {},
   options: {},
-  ...plugin
+  ...plugin,
 });
 
 function pipe(x, ...fns) {
   return fns.reduce((y, fn) => fn(y), x);
 }
 
-export { DOM_HANDLERS, DefaultLeaf, ELEMENT_DEFAULT, EditablePlugins, EditorStateEffect, KEY_DESERIALIZE_AST, KEY_DESERIALIZE_HTML, KEY_EVENT_EDITOR, KEY_INLINE_VOID, KEY_INSERT_DATA, Plate, applyDeepToNodes, createDeserializeAstPlugin, createDeserializeHtmlPlugin, createDocumentNode, createElementWithSlate, createEventEditorPlugin, createHistoryPlugin, createInlineVoidPlugin, createInsertDataPlugin, createNode, createNodeHOC, createNodesHOC, createNodesWithHOC, createPlateEditor, createPluginFactory, createPlugins, createReactPlugin, defaultsDeepToNodes, deleteFragment, deserializeHtml, deserializeHtmlElement, deserializeHtmlNode, deserializeHtmlNodeChildren, elementToHtml, escapeRegExp, eventEditorStore, findDescendant, findHtmlParentElement, findNode, findNodePath, flattenDeepPlugins, getAbove, getBlockAbove, getChildren, getEventEditorState, getHandler, getInjectedPlugins, getLastChild$1 as getLastChild, getLastChildPath, getLastNode, getMark, getNextSiblingNodes, getNode, getNodes, getParent, getPlateEditorRef, getPlateEnabled, getPlateEventId, getPlateId, getPlatePlugins, getPlateState, getPlateValue, getPlugin, getPluginInjectProps, getPluginOptions, getPluginType, getPlugins, getPluginsByKey, getPointBefore, getPointFromLocation, getPointNextToVoid, getPreventDefaultHandler, getPreviousBlockById, getPreviousPath, getQueryOptions, getRangeBefore, getRangeFromBlockStart, getRenderNodeProps, getSelectionText, getSetStateByKey, getSlateClass, getStateById, getText, hasSingleChild, htmlBodyToFragment, htmlBrToNewLine, htmlElementToElement, htmlElementToLeaf, htmlStringToDOMNode, htmlTextNodeToString, incrementKey, insertEmptyElement, insertNodes, isAncestor, isAncestorEmpty, isBlockAboveEmpty, isBlockTextEmptyAfterSelection, isCollapsed, isDefined, isDescendant, isElement, isEncoded, isEnd, isEventHandled, isExpanded, isFirstChild, isHtmlComment, isHtmlElement, isHtmlText, isLastChild, isMarkActive, isNull, isPointAtWordEnd, isRangeAcrossBlocks, isRangeInSingleText, isSelectionAtBlockEnd, isSelectionAtBlockStart, isSelectionExpanded, isStart, isText, isTextByPath, isType, isUndefined, isUndefinedOrNull, isUrl, isWordAfterTrigger, leafToHtml, match, matchPredicate, mergeDeepPlugins, mergeDeepToNodes, mergeNodes, mergeState, mockPlugin, moveChildren, normalizeDescendantsToDocumentFragment, onKeyDownToggleElement, onKeyDownToggleMark, overridePluginsByKey, parseHtmlDocument, parseHtmlElement, pipe, pipeDecorate, pipeDeserializeHtmlElement, pipeDeserializeHtmlLeaf, pipeHandler, pipeInjectProps, pipeInsertDataQuery, pipeInsertFragment, pipeOnChange, pipeRenderElement, pipeRenderLeaf, pipeTransformData, pipeTransformFragment, plateStore, pluginDeserializeHtml, pluginInjectProps, pluginRenderElement, pluginRenderLeaf, queryEditor, queryNode, removeMark, selectEditor, selectEndOfBlockAboveSelection, serializeHtml, setDefaultPlugin, setEventEditorId, setMarks, setNodes, setPlatePlugins, someNode, stripClassNames, stripSlateDataAttributes, toggleMark, toggleNodeType, toggleWrapNodes, trimWhitespace, unhangRange, unsetNodes, unwrapNodes, useEditableProps, useEditorRef, useEditorState, useEventEditorStore, usePlate, usePlateActions, usePlateEditorRef, usePlateEditorState, usePlateEffects, usePlateEnabled, usePlateEventId, usePlateKey, usePlatePlugins, usePlateSelection, usePlateState, usePlateStore, usePlateValue, useSlateProps, withInlineVoid, withInsertData, withPlate, withProps, withProviders, wrapNodes };
+export {
+  DOM_HANDLERS,
+  DefaultLeaf,
+  ELEMENT_DEFAULT,
+  EditablePlugins,
+  EditorStateEffect,
+  KEY_DESERIALIZE_AST,
+  KEY_DESERIALIZE_HTML,
+  KEY_EVENT_EDITOR,
+  KEY_INLINE_VOID,
+  KEY_INSERT_DATA,
+  Plate,
+  applyDeepToNodes,
+  createDeserializeAstPlugin,
+  createDeserializeHtmlPlugin,
+  createDocumentNode,
+  createElementWithSlate,
+  createEventEditorPlugin,
+  createHistoryPlugin,
+  createInlineVoidPlugin,
+  createInsertDataPlugin,
+  createNode,
+  createNodeHOC,
+  createNodesHOC,
+  createNodesWithHOC,
+  createPlateEditor,
+  createPluginFactory,
+  createPlugins,
+  createReactPlugin,
+  defaultsDeepToNodes,
+  deleteFragment,
+  deserializeHtml,
+  deserializeHtmlElement,
+  deserializeHtmlNode,
+  deserializeHtmlNodeChildren,
+  elementToHtml,
+  escapeRegExp,
+  eventEditorStore,
+  findDescendant,
+  findHtmlParentElement,
+  findNode,
+  findNodePath,
+  flattenDeepPlugins,
+  getAbove,
+  getBlockAbove,
+  getChildren,
+  getEventEditorState,
+  getHandler,
+  getInjectedPlugins,
+  getLastChild$1 as getLastChild,
+  getLastChildPath,
+  getLastNode,
+  getMark,
+  getNextSiblingNodes,
+  getNode,
+  getNodes,
+  getParent,
+  getPlateEditorRef,
+  getPlateEnabled,
+  getPlateEventId,
+  getPlateId,
+  getPlatePlugins,
+  getPlateState,
+  getPlateValue,
+  getPlugin,
+  getPluginInjectProps,
+  getPluginOptions,
+  getPluginType,
+  getPlugins,
+  getPluginsByKey,
+  getPointBefore,
+  getPointFromLocation,
+  getPointNextToVoid,
+  getPreventDefaultHandler,
+  getPreviousBlockById,
+  getPreviousPath,
+  getQueryOptions,
+  getRangeBefore,
+  getRangeFromBlockStart,
+  getRenderNodeProps,
+  getSelectionText,
+  getSetStateByKey,
+  getSlateClass,
+  getStateById,
+  getText,
+  hasSingleChild,
+  htmlBodyToFragment,
+  htmlBrToNewLine,
+  htmlElementToElement,
+  htmlElementToLeaf,
+  htmlStringToDOMNode,
+  htmlTextNodeToString,
+  incrementKey,
+  insertEmptyElement,
+  insertNodes,
+  isAncestor,
+  isAncestorEmpty,
+  isBlockAboveEmpty,
+  isBlockTextEmptyAfterSelection,
+  isCollapsed,
+  isDefined,
+  isDescendant,
+  isElement,
+  isEncoded,
+  isEnd,
+  isEventHandled,
+  isExpanded,
+  isFirstChild,
+  isHtmlComment,
+  isHtmlElement,
+  isHtmlText,
+  isLastChild,
+  isMarkActive,
+  isNull,
+  isPointAtWordEnd,
+  isRangeAcrossBlocks,
+  isRangeInSingleText,
+  isSelectionAtBlockEnd,
+  isSelectionAtBlockStart,
+  isSelectionExpanded,
+  isStart,
+  isText,
+  isTextByPath,
+  isType,
+  isUndefined,
+  isUndefinedOrNull,
+  isUrl,
+  isWordAfterTrigger,
+  leafToHtml,
+  match,
+  matchPredicate,
+  mergeDeepPlugins,
+  mergeDeepToNodes,
+  mergeNodes,
+  mergeState,
+  mockPlugin,
+  moveChildren,
+  normalizeDescendantsToDocumentFragment,
+  onKeyDownToggleElement,
+  onKeyDownToggleMark,
+  overridePluginsByKey,
+  parseHtmlDocument,
+  parseHtmlElement,
+  pipe,
+  pipeDecorate,
+  pipeDeserializeHtmlElement,
+  pipeDeserializeHtmlLeaf,
+  pipeHandler,
+  pipeInjectProps,
+  pipeInsertDataQuery,
+  pipeInsertFragment,
+  pipeOnChange,
+  pipeRenderElement,
+  pipeRenderLeaf,
+  pipeTransformData,
+  pipeTransformFragment,
+  plateStore,
+  pluginDeserializeHtml,
+  pluginInjectProps,
+  pluginRenderElement,
+  pluginRenderLeaf,
+  queryEditor,
+  queryNode,
+  removeMark,
+  selectEditor,
+  selectEndOfBlockAboveSelection,
+  serializeHtml,
+  setDefaultPlugin,
+  setEventEditorId,
+  setMarks,
+  setNodes,
+  setPlatePlugins,
+  someNode,
+  stripClassNames,
+  stripSlateDataAttributes,
+  toggleMark,
+  toggleNodeType,
+  toggleWrapNodes,
+  trimWhitespace,
+  unhangRange,
+  unsetNodes,
+  unwrapNodes,
+  useEditableProps,
+  useEditorRef,
+  useEditorState,
+  useEventEditorStore,
+  usePlate,
+  usePlateActions,
+  usePlateEditorRef,
+  usePlateEditorState,
+  usePlateEffects,
+  usePlateEnabled,
+  usePlateEventId,
+  usePlateKey,
+  usePlatePlugins,
+  usePlateSelection,
+  usePlateState,
+  usePlateStore,
+  usePlateValue,
+  useSlateProps,
+  withInlineVoid,
+  withInsertData,
+  withPlate,
+  withProps,
+  withProviders,
+  wrapNodes,
+};
 //# sourceMappingURL=index.es.js.map
diff --git a/node_modules/@udecode/plate-core/dist/index.js b/node_modules/@udecode/plate-core/dist/index.js
index e1a7bc7..ab25a00 100644
--- a/node_modules/@udecode/plate-core/dist/index.js
+++ b/node_modules/@udecode/plate-core/dist/index.js
@@ -8747,11 +8747,11 @@ const withInlineVoid = editor => {
     if (!plugin.key) return;
 
     if (plugin.isInline) {
-      inlineTypes.push(plugin.key);
+      inlineTypes.push(plugin.type);
     }
 
     if (plugin.isVoid) {
-      voidTypes.push(plugin.key);
+      voidTypes.push(plugin.type);
     }
   });
 
